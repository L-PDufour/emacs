<p>Today I’m releasing <a href="https://github.com/skeeto/w64devkit/">w64devkit</a> 2.4.0, mostly for <a href="https://gcc.gnu.org/pipermail/gcc/2025-August/246491.html">GCC 15.2</a>. As
usual, it includes the continuous background improvements, and ideally
each release is the best so far. The <a href="/blog/2020/05/15/">first release</a> included the
Netwide Assembler, <a href="https://www.nasm.us/">NASM</a>, but it’s now been a year since I removed NASM
from the distribution (2.0.0). I’m asked on occasion why, or how to get it
back. Because I value thorough source control logs, my justifications for
this, and all changes, are captured in these logs, so <code class="language-plaintext highlighter-rouge">git log</code> is a kind
of miniature, project blog. I understand this is neither discoverable nor
obvious, especially because the GitHub UI (ugh) lacks anything like <code class="language-plaintext highlighter-rouge">git
log</code> in the terminal. So let’s talk about it here, along with other recent
changes.</p>

<p>NASM is nice assembler, and I still in general prefer its x86 syntax to
the GNU Assembler, GAS. It’s tidy, self-contained, dependency-free other
than a C toolchain, reliable, easy to build and cross compile, which is
why I included it in the first place. However, <em>it’s just not a good fit
for w64dk</em>. It’s redundant with Binutils <code class="language-plaintext highlighter-rouge">as</code>, which is already mandatory
for supporting GCC. As a rule, w64dk is a curation that avoids redundancy,
and a second assembler requires special justification. Originally it was
that the syntax was nicer, but last year I decided that wasn’t enough to
outweigh against NASM’s weaknesses.</p>

<p>First, it doesn’t integrate well with the GNU toolchain, at least not to
the extent that <code class="language-plaintext highlighter-rouge">as</code> does. For example, many people don’t realize they can
assemble GAS assembly through the general <code class="language-plaintext highlighter-rouge">gcc</code> driver.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gcc -c myprogram.s
</code></pre></div></div>

<p>There’s rarely a reason to invoke <code class="language-plaintext highlighter-rouge">as</code> directly. Need a specific assembler
flag? Use <code class="language-plaintext highlighter-rouge">-Wa</code> or <code class="language-plaintext highlighter-rouge">-Xassembler</code>. Going through the compiler driver for
both assembly and linking (i.e. instead of <code class="language-plaintext highlighter-rouge">ld</code>) has the advantage of
operating at a “higher level.” The compiler driver knows about the whole
toolchain, and better understands <a href="https://peter0x44.github.io/posts/cross-compilers/">the sysroot</a>. Use a capital
file extension, <code class="language-plaintext highlighter-rouge">.S</code>, and <code class="language-plaintext highlighter-rouge">gcc</code> will automatically run it through the C
preprocessor.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ gcc -c myprogram.S
</code></pre></div></div>

<p>This is quite nifty, especially for cross builds. NASM isn’t so integrated
and so requires invoking the <code class="language-plaintext highlighter-rouge">nasm</code> command directly. It’s not a big deal,
but it’s friction that adds up.</p>

<p>But even more, the most useful form of assembly in the context of w64dk is
<a href="/blog/2024/12/20/">inline assembly</a>, which of course is completely out of NASM’s lane.
So most of the time you’re going to be writing GAS anyway. Again, NASM is
just not integrated into the toolchain like <code class="language-plaintext highlighter-rouge">as</code>.</p>

<p>Second, NASM is a <em>dreadfully slow</em> assembler — in the vicinity of <em>two
orders of magnitude slower</em> than GAS! If your assembly program is a couple
hundred lines, no big deal. If you’re writing a compiler targeting NASM,
it’s impractical beyond toy programs. Friends don’t let friends use NASM
as a back-end. If you’re so allergic to GAS, note that <a href="https://github.com/yasm/yasm">YASM</a> has
matching syntax and better performance.</p>

<p>Third, and the last nail in the coffin, NASM doesn’t support DWARF debug
information in Windows targets (<code class="language-plaintext highlighter-rouge">win32</code>/<code class="language-plaintext highlighter-rouge">win64</code>). That means you cannot
debug NASM programs with GDB on Windows, at least not with source-level
debugging. Were you even aware GAS has source-level debugging with GDB?
Sure, you can show the assembly pane (<code class="language-plaintext highlighter-rouge">layout asm</code>) and step through the
<em>disassembly</em> with <code class="language-plaintext highlighter-rouge">ni</code>, but stepping through the original source (<code class="language-plaintext highlighter-rouge">layout
src</code>) is a whole different experience. Even better, bring up the register
pane (<code class="language-plaintext highlighter-rouge">layout regs</code>) and you have something akin to a Visual Studio watch
window. It’s such a pleasant experience, and yet no tutorial I’ve seen has
ever mentioned it. It should be the first thing people are taught. <em>Get
your act together, assembly tutorials!</em></p>

<p>In theory, YASM ought to solve this with its <code class="language-plaintext highlighter-rouge">-g dwarf2</code>, but alas this
feature appears to be broken. So that really just leaves GAS as the most
practical game in town for assembly on Windows with GNU-style toolchains.
In case it helps: <a href="https://archive.org/details/h42_Assembly_Language_Programming_for_PDP-11_and_LSL-11_Computers_ISBN_0-697-08164-8/page/n1/mode/2up">Learning a little PDP-11 assembly</a> gave me a
deeper understanding — and appreciation — of why GAS x86 is the way it is.
Makes it sting a little less than before.</p>

<h3 id="compiling-nasm">Compiling NASM</h3>

<p>At the same time w64dk lost NASM, it gained the ability to run Autotools
<code class="language-plaintext highlighter-rouge">configure</code> scripts. It only took a few environment variables as hints for
the script, and <a href="https://github.com/skeeto/w64devkit/commit/7785eb9c">a small hack in the shell</a> to <em>undo</em> an unnecessary
Autotools hack. The typical native <code class="language-plaintext highlighter-rouge">cmd.exe</code> invocation with a command
uses <code class="language-plaintext highlighter-rouge">/c</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd /c echo hello world
</code></pre></div></div>

<p>It’s <a href="/blog/2022/02/18/"><em>roughly</em></a> equivalent to <code class="language-plaintext highlighter-rouge">-c</code> in a unix shell. This is what
you’d use if you’re in another shell and you need to invoke <code class="language-plaintext highlighter-rouge">cmd</code> for a
specific purpose. However, if you’re in an MSYS2 shell with its virtual
file system, <code class="language-plaintext highlighter-rouge">/c</code> looks like a path to the C drive. So MSYS2 “helpfully”
translates the switch to a native path, something like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd C:\ echo hello world
</code></pre></div></div>

<p>Not helpful at all. So Autotools, assuming Cygwin-like environments are
the only that exist, uses a special escape form when invoking <code class="language-plaintext highlighter-rouge">cmd</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd //c echo hello world
</code></pre></div></div>

<p>Which Cygwin-like environments translate into the desired <code class="language-plaintext highlighter-rouge">/c</code>. If you’re
not in such an environment, then <code class="language-plaintext highlighter-rouge">cmd.exe</code> sees the <code class="language-plaintext highlighter-rouge">//c</code>, which doesn’t
work. So the <a href="https://frippery.org/busybox/">busybox-w32</a> shell now pattern matches for precisely:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>cmd //c echo [...]
</code></pre></div></div>

<p>For a similar translation. That’s right, it matches <code class="language-plaintext highlighter-rouge">echo</code> in particular
because that’s the only <code class="language-plaintext highlighter-rouge">cmd</code> feature Autotools uses. So it’s completely
unnecessary, just poor code generation.</p>

<p>With that work in place, you can download a NASM source release, untar it,
run <code class="language-plaintext highlighter-rouge">./configure</code>, <code class="language-plaintext highlighter-rouge">make -j$(nproc)</code>, and copy the resulting <code class="language-plaintext highlighter-rouge">nasm.exe</code>
into w64dk or wherever else on your <code class="language-plaintext highlighter-rouge">$PATH</code> is convenient. The same is
true for quite a bit of software! You can build Binutils, including <code class="language-plaintext highlighter-rouge">as</code>
itself, exactly the same way. Being so easy for users to build their own
tools means I’m less concerned with including extraneous, more specialized
tools, such as NASM.</p>

<h3 id="path-style">Path Style</h3>

<p>Borrowing <a href="https://www.msys2.org/wiki/MSYS2-introduction/#path">a concept from MSYS2</a>, <code class="language-plaintext highlighter-rouge">w64devkit.ini</code> now has <code class="language-plaintext highlighter-rouge">path
style</code> option for controlling the initial <code class="language-plaintext highlighter-rouge">PATH</code>, using <a href="https://github.com/msys2/MSYS2-packages/blob/ae252e94/filesystem/profile#L28-L45">the same names
and configuration</a>. I’ve already found it useful in testing w64dk
itself in a relatively pristine, hermetic environment:</p>

<div class="language-ini highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nn">[w64devkit]</span>
<span class="py">home</span> <span class="p">=</span> <span class="s">.</span>
<span class="err">path</span> <span class="py">style</span> <span class="p">=</span> <span class="s">strict</span>
</code></pre></div></div>

<p>This uses the <code class="language-plaintext highlighter-rouge">w64devkit/</code> directory itself as <code class="language-plaintext highlighter-rouge">$HOME</code>, and <code class="language-plaintext highlighter-rouge">$PATH</code> is
initially just the w64dk <code class="language-plaintext highlighter-rouge">bin/</code> directory. See the <code class="language-plaintext highlighter-rouge">w64devkit.ini</code> header
for full documentation.</p>

<p>Otherwise, most of the major features have been discussed already:
<a href="/blog/2024/06/30/">peports and vc++filt</a>, <a href="/blog/2023/01/18/">pkg-config</a>, and <a href="/blog/2025/02/17/">xxd</a>.</p>


    