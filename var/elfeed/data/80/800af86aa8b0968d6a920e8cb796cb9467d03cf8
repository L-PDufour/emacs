
<p>I already talked about <a href="https://gustedt.wordpress.com/2020/12/14/a-defer-mechanism-for-c/">a proposal for an extension of the C language called<br><strong>defer</strong></a>, that is prospected to either be published in a technical<br>specification or the next revision, C2Y, of the C standard:</p>



<ul class="wp-block-list">
<li><a href="http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2542.pdf">Defer Mechanism for C</a></li>



<li><a href="https://gustedt.gitlabpages.inria.fr/defer">defer reference implementation for C</a></li>
</ul>



<p><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/">EĿlipsis</a> now implements a simple form of this feature by mixing some specific preprocessor extensions (in particular counters) with the usual macro magic.</p>



<span id="more-4172"></span>



<p>This feature is motivated by code patterns as the following, which use<br><code>goto</code> jumps to ensure that certain cleanup code snippets are executed<br>in the correct order and under the right circumstances:</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
void fun() {
   void * const p = malloc(25);
   if (!p) goto DEFER0;

   void*const q = malloc(25);
   if (!q) goto DEFER1;

   if (mtx_lock(&mut)==thrd_error) goto DEFER2;

   // all resources acquired

   // ... use p and q under protection of mut ... then
   mtx_unlock(&mut);

 DEFER2:
   free(q);
 DEFER1:
   free(p);
 DEFER0:;
}
</pre></div>


<p>Such spaghetti patterns are quite commonly used in C because they<br>currently provide the only systematic tool to do such cleanup. The<br>pattern has several disadvantages</p>



<ul class="wp-block-list">
<li>cleanup code appears far from the place where its need is detected</li>



<li>we have to invent a naming scheme for labels that has to be unique within the same function</li>



<li>adding new resources and new cleanup code easily introduces bugs</li>
</ul>



<p>The <code>defer</code> feature avoids all of these. Using this inside a compound<br>statement indicates that that code is to be executed at the end of that<br>compound statement. </p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
#include_directives &lt;ellipsis-defer.h&gt;

void fun() {
  void * const p = malloc(25);
  if (!p) return;
  defer free(p);

  void * const q = malloc(25);
  if (!q) return;
  defer free(q);

  if (mtx_lock(&amp;mut)==thrd_error) return;
  defer mtx_unlock(&amp;mut);

  // all resources acquired

  // ... use p and q under protection of mut ... then
}
</pre></div>


<p>As you can see, this does not force us to make arbitrary naming choices for labels, and has the cleanup close to where its need arises. For this simplified example the idea is that all statements that are prefixed with <code>defer</code> are executed at the end of the function in the reversed order in which they appear lexicographically.</p>



<p><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/">EĿlipsis</a> enables a simple form of this and the point of this blog entry here is to show that already a slightly enhanced preprocessor can be used to hide all that complexity from the programmer. The main idea  is that the labels that are needed have nice properties that only depend on the syntactical placement of the <code>defer</code> statement within a compound statement <code>{...}</code> . In a first phase eĿlipsis translates the function to something like the following.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
void fun() {
  void * const p  = malloc(25);
  if (!p) return;
  /* defer */
  &#91;&#91;__maybe_unused__]] register bool DEFER_LOC_ID_0_2 = false;
  DEFER_TO(DEFER_END_ID_1_3, DEFER_ID_1_7): free(p);

  void * const q  = malloc(25);
  if (!q)   /* return mode 1 */
    switch((DEFER_LOC_ID_0_2  = true))
    default: goto DEFER_ID_1_7;
  /* defer */
  DEFER_TO(DEFER_ID_1_7, DEFER_ID_1_8): free(q);

  if (mtx_lock(&mut)==thrd_error)   /* return mode 1 */
    switch((DEFER_LOC_ID_0_2  = true))
    default: goto DEFER_ID_1_8;
  /* defer */
  DEFER_TO(DEFER_ID_1_8, DEFER_ID_1_9): mtx_unlock(&mut);

  goto DEFER_ID_1_9;
DEFER_END_ID_1_3: ;
}
</pre></div>


<p>So what happend here? </p>



<ul class="wp-block-list">
<li>At each <code>defer</code> two names for labels are added. The first identifies the jump target  of  the next <code>defer</code> code; the second identifies the <code>defer</code> under construction.</li>



<li>The definition of a local variable <code>LOC_ID_0_2</code> has been added. This holds the information if we are currently in the process of executing <code>defer</code> statements or not. This variable is useful when we have nested compound statements; here a <code>return</code> has to continue to execute  <code>defer</code> statements of surrounding compound statements. </li>



<li><code>return</code> statements are essentially replaced by <code>goto</code> with the correct target label, namely the first <code>defer</code> code to be executed when returning from that position. Additionally they set the variable to <code>true</code> such that the change in state is recorded.</li>



<li>At the end of the body we see another <code>goto</code> that ensures that the <code>defer</code> statements are all executed when the end of the function is reached.</li>



<li>After that, there is an additional label that serves as target of the first <code>defer</code>. </li>
</ul>



<p>Note also that the start of the function up to the first <code>defer</code> is not changed and behaves exactly as without any <code>defer</code>.</p>



<p>The resulting code might look complicated, and is even much less readable if the <code>DEFER_TO</code> macro is expanded in addition; you probably don&#8217;t want to see that ever in your life.  But the complexity of that resulting code is only to us humans, we are not able to easily follow each thread of the spaghetti. Modern compilers are perfectly fine with this and basically compile all of this as if they had been presented the linearized code that is on top of this post. In addition they may provide you with valuable feedback if we enable static analysis.</p>



<p>The point here is that already the preprocessor can be used to hide all that complexity from the programmer. </p>



<p>The current implementation in eĿlipsis still has some drawbacks</p>



<ul class="wp-block-list">
<li>There is no way to guess a return type of a function. So functions with non-<code>void</code> return need an extra macro, <code>DEFER_TYPE</code> that provides this information.</li>



<li><code>break</code> and <code>continue</code> statements don&#8217;t  work across <code>defer</code>.</li>
</ul>



<p>The first is really only a minor inconvenience.  If we transform the <code>fun</code> function from above to a <code>main</code> with returns with expressions, such as in</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
int main() {
  DEFER_TYPE(int);
  void * const p = malloc(25);
  if (!p) return EXIT_FAILURE;
  defer free(p);

  void * const q = malloc(25);
  if (!q) return EXIT_FAILURE;
  defer free(q);

  if (mtx_lock(&mut)==thrd_error) return EXIT_FAILURE;
  defer mtx_unlock(&mut);

  // all resources acquired

  // ... use p and q under protection of mut ... then
  return EXIT_SUCCESS;
}
</pre></div>


<p>the information given by <code>DEFER_TYPE</code> is sufficient to transform this into valid C23 code. The replacement done by eĿlipsis then looks even a bit more complicated than before:</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
int main() {
  typeof(int) DEFER_LOC_ID_0_1;
  &#91;&#91;__maybe_unused__]] register bool DEFER_LOC_ID_0_2 = false;
  if (false)
  DEFER_ID_1_10: return DEFER_LOC_ID_0_1;
  void * const p  = malloc(25);
  if (!p) DEFER_RETURN_TO(DEFER_ID_1_10) EXIT_FAILURE;
  /* defer */
  DEFER_TO(DEFER_ID_1_10, DEFER_ID_1_11): free(p);

  void * const q  = malloc(25);
  if (!q) DEFER_RETURN_TO(DEFER_ID_1_11) EXIT_FAILURE;
  /* defer */
  DEFER_TO(DEFER_ID_1_11, DEFER_ID_1_12): free(q);

  if (mtx_lock(&mut)==thrd_error) DEFER_RETURN_TO(DEFER_ID_1_12) EXIT_FAILURE;
  /* defer */
  DEFER_TO(DEFER_ID_1_12, DEFER_ID_1_13): mtx_unlock(&mut);

  DEFER_RETURN_TO(DEFER_ID_1_13) EXIT_SUCCESS;
  goto DEFER_ID_1_13;
&#91;&#91;__maybe_unused__]] DEFER_END_ID_1_4: ;
}
</pre></div>


<ul class="wp-block-list">
<li>Another variable, <code>DEFER_LOC_ID_0_1</code>, is added up front. It holds the return value of the function, if any.</li>



<li>The only &#8220;real&#8221; <code>return</code> statement that is left is an artificial one that is only reachable through a label, here <code>DEFER_ID_1_10</code>.</li>



<li>The original <code>return</code> statements are replaced by a macro <code>DEFER_RETURN_TO(label)</code> where the label identifies the first <code>defer</code> that has to be executed after the return value has been determined.</li>
</ul>



<p>I also have some ideas how to make this <code>defer</code> implementation work with <code>break</code> and <code>continue</code>, but that is unfortunately a bit more nasty.</p>
