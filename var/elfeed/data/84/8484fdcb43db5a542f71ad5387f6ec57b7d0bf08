<p>An early, small hurdle <a href="/blog/2025/04/04/">diving into WebAssembly</a> was allocating my
allocator. On a server or desktop with virtual memory, the allocator asks
the operating system to map fresh pages into its address space (<a href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/brk.html">sbrk</a>,
anonymous mmap, <a href="https://learn.microsoft.com/en-us/windows/win32/api/memoryapi/nf-memoryapi-virtualalloc">VirtualAlloc</a>), which it then dynamically allocates to
different purposes. In an embedded context, dynamic allocation memory is
typically a fixed, static region chosen at link time. The Wasm execution
environment more resembles an embedded system, but both kinds of obtaining
raw memory are viable and useful in different situations.</p>

<p>For the purposes of this discussion, the actual allocator isn’t important.
It could be <a href="/blog/2023/09/27/">a simple arena allocator</a>, or a more general purpose
<a href="https://github.com/skeeto/scratch/blob/master/misc/buddy.c">buddy allocator</a>. It could even be garbage collected with <a href="https://www.hboehm.info/gc/">Boehm
GC</a>. Though WebAssembly’s linear memory is a poor fit for such a
<a href="https://en.wikipedia.org/wiki/Tracing_garbage_collection#Precise_vs._conservative_and_internal_pointers">conservative</a> garbage collector. In a compact address space starting
at zero, and which doesn’t include code, memory addresses will be small
numbers, and less distinguishable from common integer values. There’s also
the issue that the garbage collector cannot scan the Wasm stack, which is
hidden from Wasm programs by design. Only the ABI stack is visible. So a
garbage collector requires cooperation from the compiler — essentially as a
distinct calling convention — to spill all heap pointers on the ABI stack
before function calls. Wasm C and C++ toolchains do not yet support this
in a practical capacity.</p>

<h3 id="exporting-a-static-heap">Exporting a static heap</h3>

<p>Let’s start with the embedded case because it’s simpler, and reserve a
dynamic memory region at link time. WebAssembly has just reached 8 years
old, so it’s early, and as we keep discovering, Wasm tooling is still
immature. <code class="language-plaintext highlighter-rouge">wasm-ld</code> doesn’t understand linker scripts, and there’s no
stable, low-level assembly language on which to build, e.g. to reserve
space, define symbols, etc. WAT is too high level and inflexible for this
purpose, as we’ll soon see. So our only option is to brute force it in a
high-level language:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">char</span> <span class="n">heap</span><span class="p">[</span><span class="mi">16</span><span class="o">&lt;&lt;</span><span class="mi">20</span><span class="p">];</span>  <span class="c1">// 16MiB</span>
</code></pre></div></div>

<p>Plugging it into an arena allocator:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Arena</span><span class="p">;</span>

<span class="n">Arena</span> <span class="nf">getarena</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Arena</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">a</span><span class="p">.</span><span class="n">beg</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">heap</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Unfortunately <code class="language-plaintext highlighter-rouge">heap</code> isn’t generic memory, but a high-level variable with
a specific, fixed type. That’s why it would have been nice to reserve the
memory outside the high-level language. In practice this works fine so
long as everything is aligned, but strictly speaking, allocating any
variable except <code class="language-plaintext highlighter-rouge">char</code> from this arena involves incompatible loads and
stores on a <code class="language-plaintext highlighter-rouge">char</code> array. Clang doesn’t document any <a href="/blog/2024/12/20/">inline assembly
interface</a> for Wasm, but neither does Clang forbid it. That leaves
just enough room to launder the pointer if you’re worried about this
technicality:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Arena</span> <span class="nf">getarena</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Arena</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">a</span><span class="p">.</span><span class="n">beg</span> <span class="o">=</span> <span class="n">heap</span><span class="p">;</span>
    <span class="n">asm</span> <span class="p">(</span><span class="s">""</span> <span class="o">:</span> <span class="s">"+r"</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">beg</span><span class="p">));</span>  <span class="c1">// launder</span>
    <span class="n">a</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">beg</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">heap</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">+r</code> means <code class="language-plaintext highlighter-rouge">a.beg</code> is both input and output. The address of the heap
goes into the black box, and as far as the compiler is concerned, <em>some
mystery address comes out</em> which, critically, has no effective type. The
assembly block is empty (<code class="language-plaintext highlighter-rouge">""</code>), so it’s just a no-op, and we know (<em>wink
wink</em>) it’s really the same address. Because the heap was “used” by the
black box, Clang won’t optimize the heap out of existence beneath us. Also
note that <code class="language-plaintext highlighter-rouge">a.end</code> was derived from the laundered pointer.</p>

<p><strong>Update</strong>: The next C standard <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3238.pdf">will improve this situation</a> and
so pointer laundering will no longer be unnecessary. A straight <code class="language-plaintext highlighter-rouge">char</code>
array could be used as an arena.</p>

<p>This static variable technique works well only in an <em>exported</em> memory
configuration, which is what <code class="language-plaintext highlighter-rouge">wasm-ld</code> uses by default. When a module
exports its memory, it indicates how much linear memory it requires on
start, and the Wasm runtime allocates and zero-initializes it at module
initialization time. C and C++ toolchains depend on that runtime zeroing
to initialize static and global variables, which are defined to be so
initialized. Compilers generate code assuming these variables are zero
initialized. This same paradigm is used for <a href="https://en.wikipedia.org/wiki/.bss">.bss sections</a> in hosted
environments.</p>

<p>In an <em>imported</em> memory configuration, linear memory is uninitialized. The
memory may be re-used from, say, a destroyed module without zeroing, and
may contain arbitrary data. In that case, C and C++ toolchains must zero
the memory explicitly. It could potentially be done with a <code class="language-plaintext highlighter-rouge">memory.fill</code>
instruction in the <em>start section</em>, but LLVM does not support start
sections. Instead it uses an <a href="https://github.com/WebAssembly/bulk-memory-operations/blob/master/proposals/bulk-memory-operations/Overview.md"><em>active data segment</em></a> — a chunk of
data copied into linear memory by the Wasm runtime during initialization,
before running the start function.</p>

<p>That is, when importing memory, LLVM <em>actually stores all those
zeros in the Wasm module</em> so that the runtime can copy it into linear
memory. Wasm has no built-in compression, so <strong>your Wasm module will be at
least as large as your heap</strong>! Exporting or importing memory is determined
at <em>link-time</em>, so at <em>compile-time</em> the compiler must assume the worst
case. If you compile the example above, you get a 16MiB “object” file (in
Wasm format):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang --target=wasm32 -c -O example.c
$ du -h example.o
16.0M   example.o
</code></pre></div></div>

<p>The WAT version of this file is 48MiB — clearly unsuitable as a low-level
assembler. If linking with exported memory, <code class="language-plaintext highlighter-rouge">wasm-ld</code> discards all-zero
active data segments. If using an imported memory configuration, it’s
copied into the final image, producing a huge Wasm image, though highly
compressible. As a rule, avoid importing memory when using an LLVM
toolchain. Regardless, large heaps created this way will have a
significant compile-time cost.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ time echo 'char heap[256&lt;&lt;20];' | clang --target=wasm32 -c -xc -
real    0m0.334s
user    0m0.013s
sys     0m0.262s
</code></pre></div></div>

<p>(If only Clang had some sort of “noinit” variable attribute in order to
allow <code class="language-plaintext highlighter-rouge">heap</code> to be uninitialized…)</p>

<h3 id="growing-a-dynamic-heap">Growing a dynamic heap</h3>

<p>Wasm programs can grow linear memory using an <a href="https://pubs.opengroup.org/onlinepubs/7908799/xsh/brk.html">sbrk</a>-like <a href="https://webassembly.github.io/spec/core/bikeshed/#syntax-instr-memory"><code class="language-plaintext highlighter-rouge">memory.grow</code>
instruction</a>. It operates in quantities of pages (64kB), and returns
the old memory size. Because memory starts at zero, the old memory size is
also the base address of the new allocation. Clang provides access to this
instruction via an undocumented built-in:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">__builtin_wasm_memory_grow</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">);</span>
</code></pre></div></div>

<p>The first parameter selects a memory because <a href="https://github.com/WebAssembly/multi-memory/blob/main/proposals/multi-memory/Overview.md">someday there might be more
than one</a>. From this built-in we can define <code class="language-plaintext highlighter-rouge">sbrk</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="o">*</span><span class="nf">sbrk</span><span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">size_t</span> <span class="n">npages</span> <span class="o">=</span> <span class="p">(</span><span class="n">size</span> <span class="o">+</span> <span class="mh">0xffffu</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>  <span class="c1">// round up</span>
    <span class="kt">size_t</span> <span class="n">old</span>    <span class="o">=</span> <span class="n">__builtin_wasm_memory_grow</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">npages</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">old</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1ul</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="p">)(</span><span class="n">old</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To which Clang compiles (note the <code class="language-plaintext highlighter-rouge">memory.grow</code>):</p>

<div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">func</span> <span class="nv">$sbrk</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">i32</span><span class="p">)</span> <span class="p">(</span><span class="nf">result</span> <span class="nv">i32</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">select</span>
    <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">shl</span>
      <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">tee</span> <span class="mi">0</span>
        <span class="p">(</span><span class="nf">memory</span><span class="o">.</span><span class="nv">grow</span>
          <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">shr_u</span>
            <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">add</span>
              <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">65535</span><span class="p">))</span>
            <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">16</span><span class="p">))))</span>
      <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">16</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">eq</span>
      <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">-1</span><span class="p">))))</span>
</code></pre></div></div>

<p>Applying that to create an arena like before:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Arena</span> <span class="nf">newarena</span><span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">cap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Arena</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">a</span><span class="p">.</span><span class="n">beg</span> <span class="o">=</span> <span class="n">sbrk</span><span class="p">(</span><span class="n">cap</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">beg</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">a</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">beg</span> <span class="o">+</span> <span class="n">cap</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now we can choose the size of the arena, and we can use this to create
multiple arenas (e.g. permanent, scratch, etc.). We could even continue
growing the last-created arena in-place when it’s full.</p>

<p>If there was no <code class="language-plaintext highlighter-rouge">memory.grow</code> instruction, it could be implemented as a
request through an imported function. The embedder using the Wasm runtime
<a href="https://developer.mozilla.org/en-US/docs/WebAssembly/Reference/JavaScript_interface/Memory/grow">can grow the memory on the module’s behalf</a> in the same manner. But
as that documentation indicates, either way growing the memory comes with
a downside in the most common Wasm runtimes, browsers: It “detaches” the
memory from references, which complicates its use for the embedder. If a
Wasm module may grow its memory at any time, the embedder must reacquire
the memory handle after every call. It’s not difficult, but it’s easy to
forget, and mistakes are likely to go unnoticed until later.</p>

<h3 id="importing-a-dynamic-heap">Importing a dynamic heap</h3>

<p>There’s a middle ground where a Wasm module imports a dynamic-sized heap.
That is, linear memory beyond the module’s base initialization. This might
be the case, for instance, in a programming competition, where contestants
submit Wasm modules which must complete a task using the supplied memory.
In that case we don’t reserve a static heap, so we’re not facing the
storing-zeros issue. However, how do we “find” the memory? Linear memory
layout will look something like so:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>0 &lt;-- stack | data | heap --&gt; ?
|-----------------------------|
</code></pre></div></div>

<p>This diagram reflects the more sensible <code class="language-plaintext highlighter-rouge">wasm-ld --stack-first</code> layout,
where the ABI stack overflows off the bottom end of memory. The heap is
just excess memory beyond the data. To find the upper bound, Wasm has a
<a href="https://webassembly.github.io/spec/core/bikeshed/#syntax-instr-memory"><code class="language-plaintext highlighter-rouge">memory.size</code></a> instruction to query linear memory size, which again
Clang provides as an undocumented built-in:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">size_t</span> <span class="nf">__builtin_wasm_memory_size</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
</code></pre></div></div>

<p>Like before, this returns the result in number of 64k pages. That’s the
high end. How do we find the low end? Similar to <code class="language-plaintext highlighter-rouge">__stack_pointer</code>, the
linker creates a <code class="language-plaintext highlighter-rouge">__heap_base</code> constant, which is the address delineating
data and heap in the diagram above. To use it, we need to declare it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">extern</span> <span class="kt">char</span> <span class="n">__heap_base</span><span class="p">[];</span>
</code></pre></div></div>

<p>Notice how it’s an array, not a pointer. It doesn’t <em>hold</em> an address, it
<em>is</em> an address. In an ELF context this would called an <em>absolute symbol</em>.
That’s everything we need to find the bounds of the heap:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Arena</span> <span class="nf">getarena</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Arena</span> <span class="n">a</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">a</span><span class="p">.</span><span class="n">beg</span> <span class="o">=</span> <span class="n">__heap_base</span><span class="p">;</span>
    <span class="n">a</span><span class="p">.</span><span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)(</span><span class="n">__builtin_wasm_memory_size</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then we continue forward using whatever memory the embedder deigned to
provide. Hopefully it’s enough!</p>


    