
<p>In view of the addition of <code>__VA_OPT__</code> first to C++ and now to C23, there had been interest in extending the C preprocessor to include recursion. The basic idea would be that <code>__VA_OPT__</code> can be used as a test within a macro such as in the following</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; gutter: false; title: ; notranslate">
#define AddUp(X, ...) (X __VA_OPT__( + AddUp(__VA_ARGS__)))
</pre></div>


<p>Indeed, the <code>__VA_OPT__</code> clause only inserts its contents if the <code>...</code> part of the parameter list received at least one argument. So at a first glance you may think that this should be fine, and the above will replace an invocation <code>AddUp(a, b, c)</code> by (<code>a + (b + (c)))</code>. There are two reasons why this doesn&#8217;t work well.</p>



<span id="more-4143"></span>



<p>The first reason is simple: the above syntax is already valid but does something else than you might expect. In fact, in current a recursive use of a macro never expands but keeps the name of the macro intact. So the result of the macro as written would be (<code>a + AddUp(b, c))</code>, which is not very helpful in this case.</p>



<p>This property for recursive invocation can not be changed easily, because a lot of existing code would become invalid. So to enable real recursion we have to invent a new syntax, for example </p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; gutter: false; title: ; notranslate">
#define AddUp(X, ...) (X __VA_OPT__( + RECURSIVE(__VA_ARGS__)))
</pre></div>


<p><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/">eĿlipsis</a> now has a feature that emulates this behavior by defining a stack of macros that call each other. It is slightly more complicated than to write the <code>#define</code> directive above, but it is easy enough to play around and test it:</p>



<p><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/ellipsis-recursive_8dirs.html">https://gustedt.gitlabpages.inria.fr/ellipsis/ellipsis-recursive_8dirs.html</a></p>



<p>This approach works well up to a limited size of the argument list, but is doomed to fail when you would try to have it scale to long lists, say a couple of hundred. Indeed, the second reason why recursion over the argument list does not work well in C is the following observation</p>



<div class="wp-block-jetpack-markdown"><blockquote>
<p>C preprocessor recursion over variadic argument lists has
quadratic complexity.</p>
</blockquote>
</div>



<p>This is due to the fact that the C preprocessor always expands arguments. If you&#8217;d pass a list of <code>n</code> items into <code>AddUp</code> the preprocessor sees these <code>n</code> items plus <code>n-1</code> comma tokens, so in total <code>2n-1</code> tokens. The overall work that is done on one recursion level is thus proportional to <code>2n-1</code>. If we add that up over all recursion levels, we have a work of <code>1 + 3 + 5 + ... + 2n-1</code> which is <code>n²</code>.</p>



<p>As this grows quite rapidly with the size of the argument list, the potential of such a recursion is a bit limited.</p>



<p><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/">eĿlipsis</a> has a second feature that completely avoids this, tail recursion</p>



<p><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/extensions.html#tail">https://gustedt.gitlabpages.inria.fr/ellipsis/extensions.html#tail</a></p>



<p>It works similar to the above but avoids to expand the <code>__VA_ARGS__</code> parameter</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; gutter: false; title: ; notranslate">
#define AddUp(X, ...) (X __VA_OPT__( + __VA_TAIL__()))
</pre></div>


<p>Here the construct <code>__VA_TAIL__()</code> stands in for a recursive call of the surrounding macro, only that <code>__VA_ARGS__</code> is not expanded but passed through directly to the call. Since the elements of the list are not touched individually, each recursion level has constant complexity and the overall complexity of a recursive call is linear. Also, again because none of the elements of the list is touched individually, we cannot copy the argument list and therefore a second <code>__VA_TAIL__()</code> construct would not work and thus results in an empty list.</p>



<p>In fact, <code>__VA_TAIL__()</code> also admits another syntax where we place an identifier inside the parenthesis to name the macro that is to be tail called. In the example above we could in fact have used  <code>__VA_TAIL__(AddUp)</code> with the same result. Here is a more sophisticated example</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; gutter: false; title: ; notranslate">
#define LEFT(X, ...) X __VA_OPT__( + (__VA_TAIL__(RIGHT)))
#define RIGHT(X, ...) __VA_OPT__((__VA_TAIL__(LEFT)) + ) X
</pre></div>


<p>This does indeed shuffle the arguments to the left or to the right according to the parity of their position in the list.</p>



<div class="wp-block-jetpack-markdown"><p><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/">eĿlipsis</a> implements this feature quite efficiently: the tail recursion resolves into an iteration over the argument list:</p>
<ul>
<li>It collects tokens that appear on the left of the construct in a list. For <code>AddUp</code> this would be <code>(a + (b + ...</code></li>
<li>It collects those that appear on the right on a stack. For <code>AddOn</code> this would just consist of closing parenthesis <code>...))</code>.</li>
</ul>
<p>At the end of the iteration these two result lists are then just spliced together to form the overall result.</p>
</div>
