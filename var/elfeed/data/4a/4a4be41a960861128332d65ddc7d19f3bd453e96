
<p><strong>Planner programming</strong> is a programming technique where you solve problems by providing a goal and actions, and letting the planner find actions that reach the goal. In a previous edition of <a href="https://leanpub.com/logic/" target="_blank">Logic for Programmers</a>, I demonstrated how this worked by solving the 
<a href="https://en.wikipedia.org/wiki/24_(puzzle)" target="_blank">24 puzzle</a> with planning. For <a href="https://buttondown.com/hillelwayne/archive/a48fce5b-8a05-4302-b620-9b26f057f145/" target="_blank">reasons discussed here</a> I replaced that example with something more practical (orchestrating deployments), but left the <a href="https://github.com/logicforprogrammers/book-assets/tree/master/code/chapter-misc" target="_blank">code online</a> for posterity.</p>
<p>Recently I saw a family member try and fail to vibe code a tool that would find all valid 24 puzzles, and realized I could adapt the puzzle solver to also be a puzzle generator. First I'll explain the puzzle rules, then the original solver, then the generator.<sup id="fnref:complex"><a class="footnote-ref" href="#fn:complex">1</a></sup> For a much longer intro to planning, see <a href="https://www.hillelwayne.com/post/picat/" target="_blank">here</a>.</p>
<h3>The rules of 24</h3>
<p>You're given four numbers and have to find some elementary equation (<code>+-*/</code>+groupings) that uses all four numbers and results in 24. Each number must be used exactly once, but do not need to be used in the starting puzzle order. Some examples:</p>
<ul>
<li><code>[6, 6, 6, 6]</code> -&gt; <code>6+6+6+6=24</code></li>
<li><code>[1, 1, 6, 6]</code> -&gt; <code>(6+6)*(1+1)=24</code></li>
<li><code>[4, 4, 4, 5]</code> -&gt; <code>4*(5+4/4)=24</code></li>
</ul>
<p>Some setups are impossible, like <code>[1, 1, 1, 1]</code>. Others are possible only with non-elementary operations, like <code>[1, 5, 5, 324]</code> (which requires exponentiation).</p>
<h2>The solver</h2>
<p>We will use the <a href="http://picat-lang.org/" target="_blank">Picat</a>, the only language that I know has a built-in planner module. The current state of our plan with be represented by a single list with all of the numbers.</p>
<div class="codehilite"><pre><span></span><code><span class="s s-Atom">import</span> <span class="s s-Atom">planner</span><span class="p">,</span> <span class="s s-Atom">math</span><span class="p">.</span>
<span class="s s-Atom">import</span> <span class="s s-Atom">cp</span><span class="p">.</span>

<span class="nf">action</span><span class="p">(</span><span class="nv">S0</span><span class="p">,</span> <span class="nv">S1</span><span class="p">,</span> <span class="nv">Action</span><span class="p">,</span> <span class="nv">Cost</span><span class="p">)</span> <span class="s s-Atom">?=&gt;</span>
  <span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">S0</span><span class="p">)</span>
  <span class="p">,</span> <span class="nv">S0</span> <span class="s s-Atom">:=</span> <span class="nf">delete</span><span class="p">(</span><span class="nv">S0</span><span class="p">,</span> <span class="nv">X</span><span class="p">)</span> <span class="c1">% , is `and`</span>
  <span class="p">,</span> <span class="nf">member</span><span class="p">(</span><span class="nv">Y</span><span class="p">,</span> <span class="nv">S0</span><span class="p">)</span>
  <span class="p">,</span> <span class="nv">S0</span> <span class="s s-Atom">:=</span> <span class="nf">delete</span><span class="p">(</span><span class="nv">S0</span><span class="p">,</span> <span class="nv">Y</span><span class="p">)</span>
  <span class="p">,</span> <span class="p">(</span>
      <span class="nv">A</span> <span class="o">=</span> <span class="err">$</span><span class="p">(</span><span class="nv">X</span> <span class="o">+</span> <span class="nv">Y</span><span class="p">)</span> 
    <span class="p">;</span> <span class="nv">A</span> <span class="o">=</span> <span class="err">$</span><span class="p">(</span><span class="nv">X</span> <span class="o">-</span> <span class="nv">Y</span><span class="p">)</span>
    <span class="p">;</span> <span class="nv">A</span> <span class="o">=</span> <span class="err">$</span><span class="p">(</span><span class="nv">X</span> <span class="o">*</span> <span class="nv">Y</span><span class="p">)</span>
    <span class="p">;</span> <span class="nv">A</span> <span class="o">=</span> <span class="err">$</span><span class="p">(</span><span class="nv">X</span> <span class="o">/</span> <span class="nv">Y</span><span class="p">),</span> <span class="nv">Y</span> <span class="o">&gt;</span> <span class="mi">0</span>
    <span class="p">)</span>
    <span class="p">,</span> <span class="nv">S1</span> <span class="o">=</span> <span class="nv">S0</span> <span class="s s-Atom">++</span> <span class="p">[</span><span class="nf">apply</span><span class="p">(</span><span class="nv">A</span><span class="p">)]</span>
  <span class="p">,</span> <span class="nv">Action</span> <span class="o">=</span> <span class="nv">A</span>
  <span class="p">,</span> <span class="nv">Cost</span> <span class="o">=</span> <span class="mi">1</span>
  <span class="p">.</span>
</code></pre></div>
<p>This is our "action", and it works in three steps:</p>
<ol>
<li>Nondeterministically pull two different values out of the input, deleting them</li>
<li>Nondeterministically pick one of the basic operations</li>
<li>The new state is the remaining elements, appended with that operation applied to our two picks.</li>
</ol>
<p>Let's walk through this with <code>[1, 6, 1, 7]</code>. There are four choices for <code>X</code> and three four <code>Y</code>. If the planner chooses <code>X=6</code> and <code>Y=7</code>, <code>A = $(6 + 7)</code>. This is an uncomputed term in the same way lisps might use quotation. We can resolve the computation with <code>apply</code>, as in the line <code>S1 = S0 ++ [apply(A)]</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">final</span><span class="p">([</span><span class="nv">N</span><span class="p">])</span> <span class="s s-Atom">=&gt;</span>
  <span class="nv">N</span> <span class="o">=:=</span> <span class="mf">24.</span> <span class="c1">% handle floating point</span>
</code></pre></div>
<p>Our final goal is just a list where the only element is 24. This has to be a little floating point-sensitive to handle floating point divison, done by <code>=:=</code>.</p>
<div class="codehilite"><pre><span></span><code><span class="s s-Atom">main</span> <span class="s s-Atom">=&gt;</span>
  <span class="nv">Start</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">]</span>
  <span class="p">,</span> <span class="nf">best_plan</span><span class="p">(</span><span class="nv">Start</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">Plan</span><span class="p">)</span>
  <span class="p">,</span> <span class="nf">printf</span><span class="p">(</span><span class="s2">"%w %w%n"</span><span class="p">,</span> <span class="nv">Start</span><span class="p">,</span> <span class="nv">Plan</span><span class="p">)</span>
  <span class="p">.</span>
</code></pre></div>
<p>For <code>main,</code> we just find the best plan with the maximum cost of <code>4</code> and print it. When run from the command line, <code>picat</code> automatically executes whatever is in <code>main</code>.</p>
<div class="codehilite"><pre><span></span><code>$ picat 24.pi
[1,5,5,6] [1 + 5,5 * 6,30 - 6]
</code></pre></div>
<p>I don't want to spoil any more 24 puzzles, so let's stop showing the plan:</p>
<div class="codehilite"><pre><span></span><code>main =&gt;
<span class="gd">- , printf("%w %w%n", Start, Plan)</span>
<span class="gi">+ , printf("%w%n", Start)</span>
</code></pre></div>
<h3>Generating puzzles</h3>
<p>Picat provides a <code>find_all(X, p(X))</code> function, which ruturns all <code>X</code> for which <code>p(X)</code> is true. In theory, we could write <code>find_all(S, best_plan(S, 4, _)</code>. In practice, there are an infinite number of valid puzzles, so we need to bound S somewhat. We also don't want to find any redundant puzzles, such as <code>[6, 6, 6, 4]</code> and <code>[4, 6, 6, 6]</code>. </p>
<p>We can solve both issues by writing a helper <code>valid24(S)</code>, which will check that <code>S</code> a sorted list of integers within some bounds, like <code>1..8</code>, and also has a valid solution.</p>
<div class="codehilite"><pre><span></span><code><span class="nf">valid24</span><span class="p">(</span><span class="nv">Start</span><span class="p">)</span> <span class="s s-Atom">=&gt;</span>
  <span class="nv">Start</span> <span class="o">=</span> <span class="nf">new_list</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span>
  <span class="p">,</span> <span class="nv">Start</span> <span class="s s-Atom">::</span> <span class="mf">1..8</span> <span class="c1">% every value in 1..8</span>
  <span class="p">,</span> <span class="nf">increasing</span><span class="p">(</span><span class="nv">Start</span><span class="p">)</span> <span class="c1">% sorted ascending</span>
  <span class="p">,</span> <span class="nf">solve</span><span class="p">(</span><span class="nv">Start</span><span class="p">)</span> <span class="c1">% turn into values</span>
  <span class="p">,</span> <span class="nf">best_plan</span><span class="p">(</span><span class="nv">Start</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">Plan</span><span class="p">)</span>
  <span class="p">.</span>
</code></pre></div>
<p>This leans on Picat's constraint solving features to automatically find bounded sorted lists, which is why we need the <code>solve</code> step.<sup id="fnref:efficiency"><a class="footnote-ref" href="#fn:efficiency">2</a></sup> Now we can just loop through all of the values in <code>find_all</code> to get all solutions:</p>
<div class="codehilite"><pre><span></span><code><span class="s s-Atom">main</span> <span class="s s-Atom">=&gt;</span>
  <span class="nf">foreach</span><span class="p">([</span><span class="nv">S</span><span class="p">]</span> <span class="s s-Atom">in</span> <span class="nf">find_all</span><span class="p">(</span>
    <span class="p">[</span><span class="nv">Start</span><span class="p">],</span>
    <span class="nf">valid24</span><span class="p">(</span><span class="nv">Start</span><span class="p">)))</span>
    <span class="nf">printf</span><span class="p">(</span><span class="s2">"%w%n"</span><span class="p">,</span> <span class="nv">S</span><span class="p">)</span>
  <span class="s s-Atom">end</span><span class="p">.</span>
</code></pre></div>
<div class="codehilite"><pre><span></span><code>$ picat 24.pi

[1,1,1,8]
[1,1,2,6]
[1,1,2,7]
[1,1,2,8]
# etc
</code></pre></div>
<h3>Finding hard puzzles</h3>
<p>Last Friday I realized I could do something more interesting with this. Once I have found a plan, I can apply further constraints to the plan, for example to find problems that can be solved with division:</p>
<div class="codehilite"><pre><span></span><code>valid24(Start, Plan) =&gt;
<span class="w"> </span> Start = new_list(4)
<span class="w"> </span> , Start :: 1..8
<span class="w"> </span> , increasing(Start)
<span class="w"> </span> , solve(Start)
<span class="w"> </span> , best_plan(Start, 4, Plan)
<span class="gi">+ , member($(_ / _), Plan)</span>
<span class="w"> </span> .
</code></pre></div>
<p>In playing with this, though, I noticed something weird: there are some solutions that appear if I sort <em>up</em> but not <em>down</em>. For example, <code>[3,3,4,5]</code> appears in the solution set, but <code>[5, 4, 3, 3]</code> doesn't appear if I replace <code>increasing</code> with <code>decreasing</code>.</p>
<p>As far as I can tell, this is because Picat only finds one best plan, and <code>[5, 4, 3, 3]</code> has <em>two</em> solutions: <code>4*(5-3/3)</code> and <code>3*(5+4)-3</code>. <code>best_plan</code> is a <em>deterministic</em> operator, so Picat commits to the first best plan it finds. So if it finds <code>3*(5+4)-3</code> first, it sees that the solution doesn't contain a division, throws <code>[5, 4, 3, 3]</code> away as a candidate, and moves on to the next puzzle.</p>
<p>There's a couple ways we can fix this. We could replace <code>best_plan</code> with <code>best_plan_nondet</code>, which can backtrack to find new plans (at the cost of an enormous number of duplicates). Or we could modify our <code>final</code> to only accept plans with a division: </p>
<div class="codehilite"><pre><span></span><code>% Hypothetical change
final([N]) =&gt;
<span class="gi">+ member($(_ / _), current_plan()),</span>
<span class="w"> </span> N =:= 24.
</code></pre></div>
<p>My favorite "fix" is to ask another question entirely. While I was looking for puzzles that can be solved with division, what I actually want is puzzles that <em>must</em> be solved with division. What if I rejected any puzzle that has a solution <em>without</em> division?</p>
<div class="codehilite"><pre><span></span><code><span class="gi">+ plan_with_no_div(S, P) =&gt; best_plan_nondet(S, 4, P), not member($(_ / _), P).</span>

valid24(Start, Plan) =&gt;
<span class="w"> </span> Start = new_list(4)
<span class="w"> </span> , Start :: 1..8
<span class="w"> </span> , increasing(Start)
<span class="w"> </span> , solve(Start)
<span class="w"> </span> , best_plan(Start, 4, Plan)
<span class="gd">- , member($(_ / _), Plan)</span>
<span class="gi">+ , not plan_with_no_div(Start, _)</span>
<span class="w"> </span> .
</code></pre></div>
<p>The new line's a bit tricky. <code>plan_with_div</code> nondeterministically finds a plan, and then fails if the plan contains a division.<sup id="fnref:not"><a class="footnote-ref" href="#fn:not">3</a></sup> Since I used <code>best_plan_nondet</code>, it can backtrack from there and find a new plan. This means <code>plan_with_no_div</code> only fails if not such plan exists. And in <code>valid24</code>, we only succeed if <code>plan_with_no_div</code> fails, guaranteeing that the only existing plans use division. Since this doesn't depend on the plan found via <code>best_plan</code>, it doesn't matter how the values in <code>Start</code> are arranged, this will not miss any valid puzzles.</p>
<h4>Aside for my <a href="https://leanpub.com/logic/" target="_blank">logic book readers</a></h4>
<p>The new clause is equivalent to <code>!(some p: Plan(p) &amp;&amp; !(div in p))</code>. Applying the simplifications we learned:</p>
<ol>
<li><code>!(some p: Plan(p) &amp;&amp; !(div in p))</code> (init)</li>
<li><code>all p: !(plan(p) &amp;&amp; !(div in p))</code> (all/some duality)</li>
<li><code>all p: !plan(p) || div in p)</code> (De Morgan's law)</li>
<li><code>all p: plan(p) =&gt; div in p</code> (implication definition)</li>
</ol>
<p>Which more obviously means "if P is a valid plan, then it contains a division".</p>
<h4>Back to finding hard puzzles</h4>
<p><em>Anyway</em>, with <code>not plan_with_no_div</code>, we are filtering puzzles on the set of possible solutions, not just specific solutions. And this gives me an idea: what if we find puzzles that have only one solution? </p>
<div class="codehilite"><pre><span></span><code><span class="gh">different_plan(S, P) =&gt; best_plan_nondet(S, 4, P2), P2 != P.</span>

valid24(Start, Plan) =&gt;
<span class="gi">+ , not different_plan(Start, Plan)</span>
</code></pre></div>
<p>I tried this from <code>1..8</code> and got:</p>
<div class="codehilite"><pre><span></span><code>[1,2,7,7]
[1,3,4,6]
[1,6,6,8]
[3,3,8,8]
</code></pre></div>
<p>These happen to be some of the <a href="https://www.4nums.com/game/difficulties/" target="_blank">hardest 24 puzzles known</a>, though not all of them. Note this is assuming that <code>(X + Y)</code> and <code>(Y + X)</code> are <em>different</em> solutions. If we say they're the same (by appending writing <code>A = $(X + Y), X &lt;= Y</code> in our action) then we got a lot more puzzles, many of which are considered "easy". Other "hard" things we can look for include plans that require fractions:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">plan_with_no_fractions</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="nv">P</span><span class="p">)</span> <span class="s s-Atom">=&gt;</span> 
  <span class="nf">best_plan_nondet</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">P</span><span class="p">)</span>
  <span class="p">,</span> <span class="o">not</span><span class="p">(</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">P</span><span class="p">),</span>
    <span class="nf">round</span><span class="p">(</span><span class="nf">apply</span><span class="p">(</span><span class="nv">X</span><span class="p">))</span> <span class="s s-Atom">=\=</span> <span class="nv">X</span>
  <span class="p">).</span>

<span class="c1">% insert `not plan...` in valid24 as usual</span>
</code></pre></div>
<p>Finally, we could try seeing if a negative number is required:</p>
<div class="codehilite"><pre><span></span><code><span class="nf">plan_with_no_negatives</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="nv">P</span><span class="p">)</span> <span class="s s-Atom">=&gt;</span> 
  <span class="nf">best_plan_nondet</span><span class="p">(</span><span class="nv">S</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nv">P</span><span class="p">)</span>
  <span class="p">,</span> <span class="o">not</span><span class="p">(</span>
    <span class="nf">member</span><span class="p">(</span><span class="nv">X</span><span class="p">,</span> <span class="nv">P</span><span class="p">),</span>
    <span class="nf">apply</span><span class="p">(</span><span class="nv">X</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span>
  <span class="p">).</span>
</code></pre></div>
<p>Interestingly this one returns no solutions, so you are never required to construct a negative number as part of a standard 24 puzzle.</p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:complex">
<p>The code below is different than old book version, as it uses more fancy logic programming features that aren't good in learning material. <a class="footnote-backref" href="#fnref:complex" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:efficiency">
<p><code>increasing</code> is a constraint predicate. We could alternatively write <code>sorted</code>, which is a Picat logical predicate and must be placed after <code>solve</code>. There doesn't seem to be any efficiency gains either way. <a class="footnote-backref" href="#fnref:efficiency" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:not">
<p>I don't know what the standard is in Picat, but in Prolog, the convention is to use <code>\+</code> instead of <code>not</code>. They mean the same thing, so I'm using <code>not</code> because it's clearer to non-LPers. <a class="footnote-backref" href="#fnref:not" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
</ol>
</div>
