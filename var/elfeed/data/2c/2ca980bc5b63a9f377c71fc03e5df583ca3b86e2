
<p>Greetings everyone! You might have noticed that it's September and I don't have the next version of <em>Logic for Programmers</em> ready. As penance, <a href="https://leanpub.com/logic/c/september-2025-kuBCrhBnUzb7" target="_blank">here's ten free copies of the book</a>.</p>
<p>So a few months ago I wrote <a href="https://buttondown.com/hillelwayne/archive/five-kinds-of-nondeterminism/" target="_blank">a newsletter</a> about how we use nondeterminism in formal methods.  The overarching idea:</p>
<ol>
<li>Nondeterminism is when multiple paths are possible from a starting state.</li>
<li>A system preserves a property if it holds on <em>all</em> possible paths. If even one path violates the property, then we have a bug.</li>
</ol>
<p>An intuitive model of this is that for this is that when faced with a nondeterministic choice, the system always makes the <em>worst possible choice</em>. This is sometimes called <strong>demonic nondeterminism</strong> and is favored in formal methods because we are paranoid to a fault.</p>
<p>The opposite would be <strong>angelic nondeterminism</strong>, where the system always makes the <em>best possible choice</em>. A property then holds if <em>any</em> possible path satisfies that property.<sup id="fnref:duals"><a class="footnote-ref" href="#fn:duals">1</a></sup> This is not as common in FM, but it still has its uses! "Players can access the secret level" or "<a href="https://www.hillelwayne.com/post/safety-and-liveness/#other-properties" target="_blank">We can always shut down the computer</a>" are <strong>reachability</strong> properties, that something is possible even if not actually done.</p>
<p>In broader computer science research, I'd say that angelic nondeterminism is more popular, due to its widespread use in complexity analysis and programming languages.</p>
<h3>Complexity Analysis</h3>
<p>P is the set of all "decision problems" (<em>basically</em>, boolean functions) can be solved in polynomial time: there's an algorithm that's worst-case in <code>O(n)</code>, <code>O(n²)</code>, <code>O(n³)</code>, etc.<sup id="fnref:big-o"><a class="footnote-ref" href="#fn:big-o">2</a></sup>  NP is the set of all problems that can be solved in polynomial time by an algorithm with <em>angelic nondeterminism</em>.<sup id="fnref:TM"><a class="footnote-ref" href="#fn:TM">3</a></sup> For example, the question "does list <code>l</code> contain <code>x</code>" can be solved in O(1) time by a nondeterministic algorithm:</p>
<div class="codehilite"><pre><span></span><code>fun is_member(l: List[T], x: T): bool {
  if l == [] {return false};

  guess i in 0..&lt;(len(l)-1);
  return l[i] == x;
}
</code></pre></div>
<p>Say call <code>is_member([a, b, c, d], c)</code>. The best possible choice would be to guess <code>i = 2</code>, which would correctly return true. Now call <code>is_member([a, b], d)</code>. No matter what we guess, the algorithm correctly returns false. and just return false. Ergo, O(1). NP stands for "Nondeterministic Polynomial". </p>
<p>(And I just now realized something pretty cool: you can say that P is the set of all problems solvable in polynomial time under <em>demonic nondeterminism</em>, which is a nice parallel between the two classes.)</p>
<p>Computer scientists have proven that angelic nondeterminism doesn't give us any more "power": there are no problems solvable with AN that aren't also solvable deterministically. The big question is whether AN is more <em>efficient</em>: it is widely believed, but not <em>proven</em>, that there are problems in NP but not in P. Most famously, "Is there any variable assignment that makes this boolean formula true?" A polynomial AN algorithm is again easy:</p>
<div class="codehilite"><pre><span></span><code>fun SAT(f(x1, x2, …: bool): bool): bool {
   N = num_params(f)
   for i in 1..=num_params(f) {
     guess x_i in {true, false}
   }

   return f(x_1, x_2, …)
}
</code></pre></div>
<p>The best deterministic algorithms we have to solve the same problem are worst-case exponential with the number of boolean parameters. This a real frustrating problem because real computers don't have angelic nondeterminism, so problems like SAT remain hard. We can solve most "well-behaved" instances of the problem <a href="https://www.hillelwayne.com/post/np-hard/" target="_blank">in reasonable time</a>, but the worst-case instances get intractable real fast.</p>
<h3>Means of Abstraction</h3>
<div class="subscribe-form"></div>
<p>We can directly turn an AN algorithm into a (possibly much slower) deterministic algorithm, such as by <a href="https://en.wikipedia.org/wiki/Backtracking" target="_blank">backtracking</a>. This makes AN a pretty good abstraction over what an algorithm is doing. Does the regex <code>(a+b)\1+</code> match "abaabaabaab"? Yes, if the regex engine nondeterministically guesses that it needs to start at the third letter and make the group <code>aab</code>. How does my PL's regex implementation find that match? I dunno, backtracking or <a href="https://swtch.com/~rsc/regexp/regexp1.html" target="_blank">NFA construction</a> or something, I don't need to know the deterministic specifics in order to use the nondeterministic abstraction.</p>
<p>Neel Krishnaswami has <a href="https://semantic-domain.blogspot.com/2013/07/what-declarative-languages-are.html" target="_blank">a great definition of 'declarative language'</a>: "any language with a semantics has some nontrivial existential quantifiers in it". I'm not sure if this is <em>identical</em> to saying "a language with an angelic nondeterministic abstraction", but they must be pretty close, and all of his examples match:</p>
<ul>
<li>SQL's selects and joins</li>
<li>Parsing DSLs</li>
<li>Logic programming's unification</li>
<li>Constraint solving</li>
</ul>
<p>On top of that I'd add CSS selectors and <a href="https://www.hillelwayne.com/post/picat/" target="_blank">planner's actions</a>; all nondeterministic abstractions over a deterministic implementation. He also says that the things programmers hate most in declarative languages are features that "that expose the operational model": constraint solver search strategies, Prolog cuts, regex backreferences, etc. Which again matches my experiences with angelic nondeterminism: I dread features that force me to understand the deterministic implementation. But they're necessary, since P probably != NP and so we need to worry about operational optimizations.</p>
<h3>Eldritch Nondeterminism</h3>
<p>If you need to know the <a href="https://en.wikipedia.org/wiki/PP_(complexity)" target="_blank">ratio of good/bad paths</a>, <a href="https://en.wikipedia.org/wiki/%E2%99%AFP" target="_blank">the number of good paths</a>, or probability, or anything more than "there is a good path" or "there is a bad path", you are beyond the reach of heaven or hell.</p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:duals">
<p>Angelic and demonic nondeterminism are <a href="https://buttondown.com/hillelwayne/archive/logical-duals-in-software-engineering/" target="_blank">duals</a>: angelic returns "yes" if <code>some choice: correct</code> and demonic returns "no" if <code>!all choice: correct</code>, which is the same as <code>some choice: !correct</code>. <a class="footnote-backref" href="#fnref:duals" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:big-o">
<p>Pet peeve about Big-O notation: <code>O(n²)</code> is the <em>set</em> of all algorithms that, for sufficiently large problem sizes, grow no faster that quadratically. "Bubblesort has <code>O(n²)</code> complexity" <em>should</em> be written <code>Bubblesort in O(n²)</code>, <em>not</em> <code>Bubblesort = O(n²)</code>. <a class="footnote-backref" href="#fnref:big-o" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:TM">
<p>To be precise, solvable in polynomial time by a <em>Nondeterministic Turing Machine</em>, a very particular model of computation. We can broadly talk about P and NP without framing everything in terms of Turing machines, but some details of complexity classes (like the existence "weak NP-hardness") kinda need Turing machines to make sense. <a class="footnote-backref" href="#fnref:TM" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
</ol>
</div>
