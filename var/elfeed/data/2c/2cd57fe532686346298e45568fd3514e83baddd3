
<p>I'm way too discombobulated from getting next month's release of <a href="https://leanpub.com/logic/" target="_blank">Logic for Programmers</a> ready, so I'm pulling a idea from the slush pile. Basically I wanted to come up with a mental model of arrays as a concept that explained APL-style multidimensional arrays and tables but also why there weren't multitables.</p>
<p>So, arrays. In all languages they are basically the same: they map a sequence of numbers (I'll use <code>1..N</code>)<sup id="fnref:1-indexing"><a class="footnote-ref" href="#fn:1-indexing">1</a></sup> to homogeneous values (values of a single type). This is in contrast to the other two foundational types, associative arrays (which map an arbitrary type to homogeneous values) and structs (which map a fixed set of keys to <em>heterogeneous</em> values). Arrays appear in PLs earlier than the other two, possibly because they have the simplest implementation and the most obvious application to scientific computing. The OG FORTRAN had arrays. </p>
<p>I'm interested in two structural extensions to arrays. The first, found in languages like nushell and frameworks like Pandas, is the <em>table</em>. Tables have string keys like a struct <em>and</em> indexes like an array. Each row is a struct, so you can get "all values in this column" or "all values for this row". They're heavily used in databases and data science.</p>
<p>The other extension is the <strong>N-dimensional array</strong>, mostly seen in APLs like Dyalog and J. Think of this like arrays-of-arrays(-of-arrays), except all arrays at the same depth have the same length. So <code>[[1,2,3],[4]]</code> is not a 2D array, but <code>[[1,2,3],[4,5,6]]</code> is. This means that N-arrays can be queried on any axis.</p>
<div class="codehilite"><pre><span></span><code><span class="w"> </span><span class="o">]</span><span class="nv">x</span><span class="w"> </span><span class="o">=:</span><span class="w"> </span><span class="nv">i</span><span class="o">.</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">3</span>
<span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span>
<span class="mi">3</span><span class="w"> </span><span class="mi">4</span><span class="w"> </span><span class="mi">5</span>
<span class="mi">6</span><span class="w"> </span><span class="mi">7</span><span class="w"> </span><span class="mi">8</span>
<span class="w">   </span><span class="mi">0</span><span class="w"> </span><span class="o">{</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="c1">NB. first row</span>
<span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w"> </span><span class="mi">2</span>
<span class="w">   </span><span class="mi">0</span><span class="w"> </span><span class="o">{"</span><span class="mi">1</span><span class="w"> </span><span class="nv">x</span><span class="w"> </span><span class="c1">NB. first column</span>
<span class="mi">0</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">6</span>
</code></pre></div>
<p>So, I've had some ideas on a conceptual model of arrays that explains all of these variations and possibly predicts new variations. I wrote up my notes and did the bare minimum of editing and polishing. Somehow it ended up being 2000 words.</p>
<h3>1-dimensional arrays</h3>
<p>A one-dimensional array is a function over <code>1..N</code> for some N. </p>
<p>To be clear this is <em>math</em> functions, not programming functions. Programming functions take values of a type and perform computations on them. Math functions take values of a fixed set and return values of another set. So the array <code>[a, b, c, d]</code> can be represented by the function <code>(1 -&gt; a ++ 2 -&gt; b ++ 3 -&gt; c ++ 4 -&gt; d)</code>. Let's write the set of all four element character arrays as <code>1..4 -&gt; char</code>. <code>1..4</code> is the function's <strong>domain</strong>.</p>
<p>The set of all character arrays is the empty array + the functions with domain <code>1..1</code> + the functions with domain <code>1..2</code> + ... Let's call this set <code>Array[Char]</code>. Our compilers can enforce that a type belongs to <code>Array[Char]</code>, but some operations care about the more specific type, like matrix multiplication. This is either checked with the runtime type or, in exotic enough languages, with static dependent types.</p>
<p>(This is actually how TLA+ does things: the basic collection types are functions and sets, and a function with domain 1..N is a sequence.)</p>
<h3>2-dimensional arrays</h3>
<p>Now take the 3x4 matrix</p>
<div class="codehilite"><pre><span></span><code><span class="w">   </span><span class="nv">i</span><span class="o">.</span><span class="w"> </span><span class="mi">3</span><span class="w"> </span><span class="mi">4</span>
<span class="mi">0</span><span class="w"> </span><span class="mi">1</span><span class="w">  </span><span class="mi">2</span><span class="w">  </span><span class="mi">3</span>
<span class="mi">4</span><span class="w"> </span><span class="mi">5</span><span class="w">  </span><span class="mi">6</span><span class="w">  </span><span class="mi">7</span>
<span class="mi">8</span><span class="w"> </span><span class="mi">9</span><span class="w"> </span><span class="mi">10</span><span class="w"> </span><span class="mi">11</span>
</code></pre></div>
<p>There are two equally valid ways to represent the array function:</p>
<ol>
<li>A function that takes a row and a column and returns the value at that index, so it would look like <code>f(r: 1..3, c: 1..4) -&gt; Int</code>.</li>
<li>A function that takes a row and returns that column as an array, aka another function: <code>f(r: 1..3) -&gt; g(c: 1..4) -&gt; Int</code>.<sup id="fnref:associative"><a class="footnote-ref" href="#fn:associative">2</a></sup></li>
</ol>
<p>Man, (2) looks a lot like <a href="https://en.wikipedia.org/wiki/Currying" target="_blank">currying</a>! In Haskell, functions can only have one parameter. If you write <code>(+) 6 10</code>, <code>(+) 6</code> first returns a <em>new</em> function <code>f y = y + 6</code>, and then applies <code>f 10</code> to get 16. So <code>(+)</code> has the type signature <code>Int -&gt; Int -&gt; Int</code>: it's a function that takes an <code>Int</code> and returns a function of type <code>Int -&gt; Int</code>.<sup id="fnref:typeclass"><a class="footnote-ref" href="#fn:typeclass">3</a></sup></p>
<p>Similarly, our 2D array can be represented as an array function that returns array functions: it has type <code>1..3 -&gt; 1..4 -&gt; Int</code>, meaning it takes a row index and returns <code>1..4 -&gt; Int</code>, aka a single array.</p>
<p>(This differs from conventional array-of-arrays because it forces all of the subarrays to have the same domain, aka the same length. If we wanted to permit ragged arrays, we would instead have the type <code>1..3 -&gt; Array[Int]</code>.)</p>
<p>Why is this useful? A couple of reasons. First of all, we can apply function transformations to arrays, like "<a href="https://blog.zdsmith.com/series/combinatory-programming.html" target="_blank">combinators</a>". For example, we can flip any function of type <code>a -&gt; b -&gt; c</code> into a function of type <code>b -&gt; a -&gt; c</code>. So given a function that takes rows and returns columns, we can produce one that takes columns and returns rows. That's just a matrix transposition! </p>
<p>Second, we can extend this to any number of dimensions: a three-dimensional array is one with type <code>1..M -&gt; 1..N -&gt; 1..O -&gt; V</code>. We can still use function transformations to rearrange the array along any ordering of axes.</p>
<p>Speaking of dimensions:</p>
<h3>What are dimensions, anyway</h3>
<div class="subscribe-form"></div>
<p>Okay, so now imagine we have a <code>Row</code> × <code>Col</code> grid of pixels, where each pixel is a struct of type <code>Pixel(R: int, G: int, B: int)</code>. So the array is</p>
<div class="codehilite"><pre><span></span><code>Row -&gt; Col -&gt; Pixel
</code></pre></div>
<p>But we can also represent the <em>Pixel struct</em> with a function: <code>Pixel(R: 0, G: 0, B: 255)</code> is the function where <code>f(R) = 0</code>, <code>f(G) = 0</code>, <code>f(B) = 255</code>, making it a function of type <code>{R, G, B} -&gt; Int</code>. So the array is actually the function</p>
<div class="codehilite"><pre><span></span><code>Row -&gt; Col -&gt; {R, G, B} -&gt; Int
</code></pre></div>
<p>And then we can rearrange the parameters of the function like this:</p>
<div class="codehilite"><pre><span></span><code>{R, G, B} -&gt; Row -&gt; Col -&gt; Int
</code></pre></div>
<p>Even though the set <code>{R, G, B}</code> is not of form 1..N, this clearly has a real meaning: <code>f[R]</code> is the function mapping each coordinate to that coordinate's red value. What about <code>Row -&gt; {R, G, B} -&gt; Col -&gt; Int</code>?  That's for each row, the 3 × Col array mapping each color to that row's intensities.</p>
<p>Really <em>any finite set</em> can be a "dimension". Recording the monitor over a span of time? <code>Frame -&gt; Row -&gt; Col -&gt; Color -&gt; Int</code>. Recording a bunch of computers over some time? <code>Computer -&gt; Frame -&gt; Row …</code>.</p>
<p>This is pretty common in constraint satisfaction! Like if you're conference trying to assign talks to talk slots, your array might be type <code>(Day, Time, Room) -&gt; Talk</code>, where Day/Time/Room are enumerations.</p>
<p>An implementation constraint is that most programming languages <em>only</em> allow integer indexes, so we have to replace Rooms and Colors with numerical enumerations over the set. As long as the set is finite, this is always possible, and for struct-functions, we can always choose the indexing on the lexicographic ordering of the keys. But we lose type safety.</p>
<h3>Why tables are different</h3>
<p>One more example: <code>Day -&gt; Hour -&gt; Airport(name: str, flights: int, revenue: USD)</code>. Can we turn the struct into a dimension like before? </p>
<p>In this case, no. We were able to make <code>Color</code> an axis because we could turn <code>Pixel</code> into a <code>Color -&gt; Int</code> function, and we could only do that because all of the fields of the struct had the same type. This time, the fields are <em>different</em> types. So we can't convert <code>{name, flights, revenue}</code> into an axis. <sup id="fnref:name-dimension"><a class="footnote-ref" href="#fn:name-dimension">4</a></sup> One thing we can do is convert it to three <em>separate</em> functions:</p>
<div class="codehilite"><pre><span></span><code>airport: Day -&gt; Hour -&gt; Str
flights: Day -&gt; Hour -&gt; Int
revenue: Day -&gt; Hour -&gt; USD
</code></pre></div>
<p>But we want to keep all of the data in one place. That's where <strong>tables</strong> come in: an array-of-structs is isomorphic to a struct-of-arrays:</p>
<div class="codehilite"><pre><span></span><code>AirportColumns(
    airport: Day -&gt; Hour -&gt; Str,
    flights: Day -&gt; Hour -&gt; Int,
    revenue: Day -&gt; Hour -&gt; USD,
)
</code></pre></div>
<p>The table is a sort of <em>both</em> representations simultaneously. If this was a pandas dataframe, <code>df["airport"]</code> would get the airport column, while <code>df.loc[day1]</code> would get the first day's data. I don't think many table implementations support more than one axis dimension but there's no reason they <em>couldn't</em>. </p>
<p>These are also possible transforms:</p>
<div class="codehilite"><pre><span></span><code>Hour -&gt; NamesAreHard(
    airport: Day -&gt; Str,
    flights: Day -&gt; Int,
    revenue: Day -&gt; USD,
)

Day -&gt; Whatever(
    airport: Hour -&gt; Str,
    flights: Hour -&gt; Int,
    revenue: Hour -&gt; USD,
)
</code></pre></div>
<p>In my mental model, the heterogeneous struct acts as a "block" in the array. We can't remove it, we can only push an index into the fields or pull a shared column out. But there's no way to convert a heterogeneous table into an array.</p>
<h3>Actually there is a terrible way</h3>
<p>Most languages have unions or <del>product</del> sum types that let us say "this is a string OR integer". So we can make our airport data <code>Day -&gt; Hour -&gt; AirportKey -&gt; Int | Str | USD</code>. Heck, might as well just say it's <code>Day -&gt; Hour -&gt; AirportKey -&gt; Any</code>. But would anybody really be mad enough to use that in practice?</p>
<p><a href="https://code.jsoftware.com/wiki/Vocabulary/lt" target="_blank">Oh wait J does exactly that</a>. J has an opaque datatype called a "box". A "table" is a function <code>Dim1 -&gt; Dim2 -&gt; Box</code>. You can see some examples of what that looks like <a href="https://code.jsoftware.com/wiki/DB/Flwor" target="_blank">here</a></p>
<h3>Misc Thoughts and Questions</h3>
<p>The heterogeneity barrier seems like it explains why we don't see multiple axes of table columns, while we do see multiple axes of array dimensions. But is that actually why? Is there a system out there that <em>does</em> have multiple columnar axes?</p>
<p>The array <code>x = [[a, b, a], [b, b, b]]</code> has type <code>1..2 -&gt; 1..3 -&gt; {a, b}</code>. Can we rearrange it to <code>1..2 -&gt; {a, b} -&gt; 1..3</code>? No. But we <em>can</em> rearrange it to <code>1..2 -&gt; {a, b} -&gt; PowerSet(1..3)</code>, which maps rows and characters to columns <em>with</em> that character. <code>[(a -&gt; {1, 3} ++ b -&gt; {2}), (a -&gt; {} ++ b -&gt; {1, 2, 3}]</code>. </p>
<p>We can also transform <code>Row -&gt; PowerSet(Col)</code> into <code>Row -&gt; Col -&gt; Bool</code>, aka a boolean matrix. This makes sense to me as both forms are means of representing directed graphs.</p>
<p>Are other function combinators useful for thinking about arrays?</p>
<p>Does this model cover pivot tables? Can we extend it to relational data with multiple tables?</p>
<hr/>
<h3>Systems Distributed Talk (will be) Online</h3>
<p>The premier will be August 6 at 12 CST, <a href="https://www.youtube.com/watch?v=d9cM8f_qSLQ" target="_blank">here</a>! I'll be there to answer questions / mock my own performance / generally make a fool of myself.</p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:1-indexing">
<p><a href="https://buttondown.com/hillelwayne/archive/why-do-arrays-start-at-0/" target="_blank">Sacrilege</a>! But it turns out in this context, it's easier to use 1-indexing than 0-indexing. In the years since I wrote that article I've settled on "each indexing choice matches different kinds of mathematical work", so mathematicians and computer scientists are best served by being able to choose their index. But software engineers need consistency, and 0-indexing is overall a net better consistency pick. <a class="footnote-backref" href="#fnref:1-indexing" title="Jump back to footnote 1 in the text">↩</a></p>
</li>
<li id="fn:associative">
<p>This is <em>right-associative</em>: <code>a -&gt; b -&gt; c</code> means <code>a -&gt; (b -&gt; c)</code>, not <code>(a -&gt; b) -&gt; c</code>. <code>(1..3 -&gt; 1..4) -&gt; Int</code> would be the associative array that maps length-3 arrays to integers. <a class="footnote-backref" href="#fnref:associative" title="Jump back to footnote 2 in the text">↩</a></p>
</li>
<li id="fn:typeclass">
<p>Technically it has type <code>Num a =&gt; a -&gt; a -&gt; a</code>, since <code>(+)</code> works on floats too. <a class="footnote-backref" href="#fnref:typeclass" title="Jump back to footnote 3 in the text">↩</a></p>
</li>
<li id="fn:name-dimension">
<p>Notice that if each <code>Airport</code> had a unique name, we <em>could</em> pull it out into <code>AirportName -&gt; Airport(flights, revenue)</code>, but we still are stuck with two different values. <a class="footnote-backref" href="#fnref:name-dimension" title="Jump back to footnote 4 in the text">↩</a></p>
</li>
</ol>
</div>
