<p>Patrice Roy’s new book, <a href="https://www.packtpub.com/en-us/product/c-memory-management-9781805129806"><em>C++ Memory Management</em></a>, has made me more
conscious of object lifetimes. C++ is stricter than C about lifetimes, and
common, textbook memory management that’s sound in C is less so in C++ —
<em>more than I realized</em>. The book also presents a form of arena allocation
so watered down as to enjoy none of the benefits. (Despite its precision
otherwise, the second half is also littered with <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/blob/9e4c4ea7/chapter12/Vector-better.cpp#L45">integer overflows</a>
lacking <a href="/blog/2024/05/24/">the appropriate checks</a>, and near the end has some <a href="https://github.com/PacktPublishing/C-Plus-Plus-Memory-Management/blob/9e4c4ea7/chapter14/Vector_with_allocator_cpp23.cpp#L118-L119">pointer
overflows</a> invalidating the check.) However, I’m grateful for the new
insights, and it’s made me revisit <a href="/blog/2024/04/14/">my own C++ arena allocation</a>. In
this new light I see I got it subtly wrong myself!</p>

<p>Surprising to most C++ programmers, but not language lawyers, <a href="https://wg21.link/P0593#idiomatic-c-code-as-c">idiomatic C
memory allocation was ill-formed in C++ until recently</a>:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="nf">newint</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="o">*</span><span class="n">r</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>  <span class="c1">// &lt;-- undefined behavior before C++20</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This program allocates memory for an object but never starts a lifetime.
Assignment without a lifetime is invalid. Pointer casts are that much more
suspicious in C++, and due to lifetime semantics, in many cases indicate
incorrect code. (To be clear, I’m not arguing in favor of these semantics,
but reasoning about the facts on the ground.) C++20 carved out special
exceptions for <code class="language-plaintext highlighter-rouge">malloc</code> and friends, but addressing this kind of thing in
general is the purpose of the brand new <a href="https://en.cppreference.com/w/cpp/memory/start_lifetime_as.html"><code class="language-plaintext highlighter-rouge">start_lifetime_as</code></a> (and
similar), the slightly older <a href="https://en.cppreference.com/w/cpp/memory/construct_at.html"><code class="language-plaintext highlighter-rouge">construct_at</code></a>, or a classic placement
new. They all start lifetimes. The last looks like:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="o">*</span><span class="nf">newint</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="kt">int</span><span class="p">{</span><span class="n">v</span><span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That’s no good as a C/C++ polyglot, though per the differing old semantics
that was impossible anyway without macros. Which is basically cheating. An
important detail: The corrected version has no casts, and it returns the
result of <code class="language-plaintext highlighter-rouge">new</code>. That’s important because only the pointer returned by
<code class="language-plaintext highlighter-rouge">new</code> is imbued as a pointer to the new lifetime, <em>not</em> <code class="language-plaintext highlighter-rouge">r</code>. There are no
side effects affecting the provenance of <code class="language-plaintext highlighter-rouge">r</code>, which still points to raw
memory as far as the language is concerned.</p>

<p>With that in mind let’s revisit my arena from last time, which does not
necessarily benefit from the recent changes, not being one of the special
case C standard library functions:</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="nc">Arena</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="o">*</span><span class="n">alloc</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">ptrdiff_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
    <span class="kt">ptrdiff_t</span> <span class="n">pad</span>  <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">-</span> <span class="n">pad</span><span class="p">)</span><span class="o">/</span><span class="n">size</span><span class="p">);</span>  <span class="c1">// OOM policy</span>
    <span class="n">T</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="n">T</span> <span class="o">*</span><span class="p">)(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span> <span class="n">pad</span><span class="p">);</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+=</span> <span class="n">pad</span> <span class="o">+</span> <span class="n">count</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">new</span><span class="p">((</span><span class="kt">void</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">r</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="n">T</span><span class="p">{};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Hey, look, placement new! I did that to produce a nicer interface, but I
lucked out also starting lifetimes appropriately. Except it returns the
wrong pointer. This allocator discards the pointer blessed with the new
lifetime. Both pointers have the same address but different provenance.
That matters. But I’m calling <code class="language-plaintext highlighter-rouge">new</code> many times, so how do I fix this?
Array new, duh.</p>

<div class="language-c++ highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="o">*</span><span class="nf">alloc</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">ptrdiff_t</span> <span class="n">size</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
    <span class="kt">ptrdiff_t</span> <span class="n">pad</span>  <span class="o">=</span> <span class="o">-</span><span class="p">(</span><span class="kt">uintptr_t</span><span class="p">)</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">&amp;</span> <span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">count</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">-</span> <span class="n">pad</span><span class="p">)</span><span class="o">/</span><span class="n">size</span><span class="p">);</span>  <span class="c1">// OOM policy</span>
    <span class="kt">void</span> <span class="o">*</span><span class="n">r</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+</span> <span class="n">pad</span><span class="p">;</span>
    <span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">+=</span> <span class="n">pad</span> <span class="o">+</span> <span class="n">count</span><span class="o">*</span><span class="n">size</span><span class="p">;</span>
    <span class="k">return</span> <span class="k">new</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="n">T</span><span class="p">[</span><span class="n">count</span><span class="p">]{};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Wow… that’s actually much better anyway. No explicit casts, no loop. Why
didn’t I think of this in the first place? The catch is I can’t forward
constructor arguments, emplace-style — the part that gave me the trouble
with perfect forwarding — but that’s for the best. Forwarding more than
once was unsound, made more obvious by the array new.</p>

<p>Since I’m thinking about lifetimes, what about the other end? My arena
does not call destructors, by design, and starts new lifetimes on top of
objects that are technically still alive. Is that undefined behavior? As
far as I can tell <a href="https://en.cppreference.com/w/cpp/language/lifetime.html#Storage_reuse">this is allowed</a>, even for non-trivial destructors,
with the caveat that it might leak resources. In this case the resource is
memory managed by the arena, so that’s fine of course.</p>

<p>So addressing pointer provenance also produced a nicer definition. What a
great result from reading that book! While researching, I noticed Jonathan
Müller, who personally gave me great advice and feedback on my previous
article, <a href="https://www.youtube.com/watch?v=oZyhq4D-QL4">talked about lifetimes</a> just a couple weeks later. I
recommend both.</p>


    