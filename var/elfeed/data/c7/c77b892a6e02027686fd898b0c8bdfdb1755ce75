<p>The Rust team is happy to announce a new version of Rust, 1.88.0. Rust is a programming language empowering everyone to build reliable and efficient software.</p>
<p>If you have a previous version of Rust installed via <code>rustup</code>, you can get 1.88.0 with:</p>
<pre class="z-code"><code><span class="z-text z-plain">$ rustup update stable
</span></code></pre>
<p>If you don't have it already, you can <a href="https://www.rust-lang.org/install.html">get <code>rustup</code></a> from the appropriate page on our website, and check out the <a href="https://doc.rust-lang.org/stable/releases.html#version-1880-2025-06-26">detailed release notes for 1.88.0</a>.</p>
<p>If you'd like to help us out by testing future releases, you might consider updating locally to use the beta channel (<code>rustup default beta</code>) or the nightly channel (<code>rustup default nightly</code>). Please <a href="https://github.com/rust-lang/rust/issues/new/choose">report</a> any bugs you might come across!</p>
<h2 id="what-s-in-1-88-0-stable"><a class="anchor" href="#what-s-in-1-88-0-stable" aria-hidden="true"></a>
What's in 1.88.0 stable</h2>
<h3 id="let-chains"><a class="anchor" href="#let-chains" aria-hidden="true"></a>
Let chains</h3>
<p>This feature allows <code>&amp;&amp;</code>-chaining <code>let</code> statements inside <code>if</code> and <code>while</code> conditions, even intermingling with boolean expressions, so there is less distinction between <code>if</code>/<code>if let</code> and <code>while</code>/<code>while let</code>. The patterns inside the <code>let</code> sub-expressions can be irrefutable or refutable, and bindings are usable in later parts of the chain as well as the body.</p>
<p>For example, this snippet combines multiple conditions which would have required nesting <code>if let</code> and <code>if</code> blocks before:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-keyword z-control z-rust">if</span> <span class="z-storage z-type z-rust">let</span> <span class="z-meta z-path z-rust">Channel<span class="z-punctuation z-accessor z-rust">::</span></span>Stable<span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>v</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span> <span class="z-keyword z-operator z-assignment z-rust">=</span> <span class="z-support z-function z-rust">release_info</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span><span class="z-source z-rust">    <span class="z-keyword z-operator z-logical z-rust">&amp;&amp;</span> <span class="z-storage z-type z-rust">let</span> Semver <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span> major<span class="z-punctuation z-separator z-rust">,</span> minor<span class="z-punctuation z-separator z-rust">,</span> <span class="z-keyword z-operator z-range z-rust">..</span> </span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span> <span class="z-keyword z-operator z-assignment z-rust">=</span> v
</span><span class="z-source z-rust">    <span class="z-keyword z-operator z-logical z-rust">&amp;&amp;</span> major <span class="z-keyword z-operator z-comparison z-rust">==</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">1</span>
</span><span class="z-source z-rust">    <span class="z-keyword z-operator z-logical z-rust">&amp;&amp;</span> minor <span class="z-keyword z-operator z-comparison z-rust">==</span> <span class="z-constant z-numeric z-integer z-decimal z-rust">88</span>
</span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    <span class="z-support z-macro z-rust">println!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>`let_chains` was stabilized in this version<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span></code></pre>
<p>Let chains are only available in the Rust 2024 edition, as this feature depends on the <a href="https://doc.rust-lang.org/edition-guide/rust-2024/temporary-if-let-scope.html"><code>if let</code> temporary scope</a> change for more consistent drop order.</p>
<p>Earlier efforts tried to work with all editions, but some difficult edge cases threatened the integrity of the implementation. 2024 made it feasible, so please upgrade your crate's edition if you'd like to use this feature!</p>
<h3 id="naked-functions"><a class="anchor" href="#naked-functions" aria-hidden="true"></a>
Naked functions</h3>
<p>Rust now supports writing naked functions with no compiler-generated epilogue and prologue, allowing full control over the generated assembly for a particular function. This is a more ergonomic alternative to defining functions in a <code>global_asm!</code> block. A naked function is marked with the <code>#[unsafe(naked)]</code> attribute, and its body consists of a single <code>naked_asm!</code> call.</p>
<p>For example:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">unsafe</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">naked</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-modifier z-rust">unsafe</span> <span class="z-keyword z-other z-rust">extern</span> <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>sysv64<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span> <span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">wrapping_add</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">a</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">u64</span>, <span class="z-variable z-parameter z-rust">b</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">u64</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-&gt;</span> <span class="z-storage z-type z-rust">u64</span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Equivalent to `a.wrapping_add(b)`.
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-path z-rust">core<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">arch<span class="z-punctuation z-accessor z-rust">::</span></span>naked_asm<span class="z-keyword z-operator z-logical z-rust">!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>lea rax, [rdi + rsi]<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>ret<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">    </span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre>
<p>The handwritten assembly block defines the <em>entire</em> function body: unlike non-naked functions, the compiler does not add any special handling for arguments or return values. Naked functions are used in low-level settings like Rust's <a href="https://github.com/rust-lang/compiler-builtins"><code>compiler-builtins</code></a>, operating systems, and embedded applications.</p>
<p>Look for a more detailed post on this soon!</p>
<h3 id="boolean-configuration"><a class="anchor" href="#boolean-configuration" aria-hidden="true"></a>
Boolean configuration</h3>
<p>The <code>cfg</code> predicate language now supports boolean literals, <code>true</code> and <code>false</code>, acting as a configuration that is always enabled or disabled, respectively. This works in Rust <a href="https://doc.rust-lang.org/reference/conditional-compilation.html">conditional compilation</a> with <code>cfg</code> and <code>cfg_attr</code> attributes and the built-in <code>cfg!</code> macro, and also in Cargo <code>[target]</code> tables in both <a href="https://doc.rust-lang.org/cargo/reference/config.html#target">configuration</a> and <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#platform-specific-dependencies">manifests</a>.</p>
<p>Previously, empty predicate lists could be used for unconditional configuration, like <code>cfg(all())</code> for enabled and <code>cfg(any())</code> for disabled, but this meaning is rather implicit and easy to get backwards. <code>cfg(true)</code> and <code>cfg(false)</code> offer a more direct way to say what you mean.</p>
<p>See <a href="https://rust-lang.github.io/rfcs/3695-cfg-boolean-literals.html">RFC 3695</a> for more background!</p>
<h3 id="cargo-automatic-cache-cleaning"><a class="anchor" href="#cargo-automatic-cache-cleaning" aria-hidden="true"></a>
Cargo automatic cache cleaning</h3>
<p>Starting in 1.88.0, Cargo will automatically run garbage collection on the cache in its home directory!</p>
<p>When building, Cargo downloads and caches crates needed as dependencies. Historically, these downloaded files would never be cleaned up, leading to an unbounded amount of disk usage in Cargo's home directory. In this version, Cargo introduces a garbage collection mechanism to automatically clean up old files (e.g. <code>.crate</code> files). Cargo will remove files downloaded from the network if not accessed in 3 months, and files obtained from the local system if not accessed in 1 month. Note that this automatic garbage collection will not take place if running offline (using <code>--offline</code> or <code>--frozen</code>).</p>
<p>Cargo 1.78 and newer track the access information needed for this garbage collection. This was introduced well before the actual cleanup that's starting now, in order to reduce cache churn for those that still use prior versions. If you regularly use versions of Cargo even older than 1.78, in addition to running current versions of Cargo, and you expect to have some crates accessed exclusively by the older versions of Cargo and don't want to re-download those crates every ~3 months, you may wish to set <code>cache.auto-clean-frequency = "never"</code> in the Cargo configuration, as described in the <a href="https://doc.rust-lang.org/nightly/cargo/reference/config.html#cache">docs</a>.</p>
<p>For more information, see the original <a href="https://blog.rust-lang.org/2023/12/11/cargo-cache-cleaning/">unstable announcement</a> of this feature. Some parts of that design remain unstable, like the <code>gc</code> subcommand tracked in <a href="https://github.com/rust-lang/cargo/issues/13060">cargo#13060</a>, so there's still more to look forward to!</p>
<h3 id="stabilized-apis"><a class="anchor" href="#stabilized-apis" aria-hidden="true"></a>
Stabilized APIs</h3>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.update"><code>Cell::update</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.pointer.html#impl-Default-for-*const+T"><code>impl Default for *const T</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.pointer.html#impl-Default-for-*mut+T"><code>impl Default for *mut T</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/ffi/c_str/index.html"><code>mod ffi::c_str</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/collections/struct.HashMap.html#method.extract_if"><code>HashMap::extract_if</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/collections/struct.HashSet.html#method.extract_if"><code>HashSet::extract_if</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/hint/fn.select_unpredictable.html"><code>hint::select_unpredictable</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.line"><code>proc_macro::Span::line</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.column"><code>proc_macro::Span::column</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.start"><code>proc_macro::Span::start</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.end"><code>proc_macro::Span::end</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.file"><code>proc_macro::Span::file</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/proc_macro/struct.Span.html#method.local_file"><code>proc_macro::Span::local_file</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_chunks"><code>&lt;[T]&gt;::as_chunks</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_rchunks"><code>&lt;[T]&gt;::as_rchunks</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_chunks_unchecked"><code>&lt;[T]&gt;::as_chunks_unchecked</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_chunks_mut"><code>&lt;[T]&gt;::as_chunks_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_rchunks_mut"><code>&lt;[T]&gt;::as_rchunks_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.slice.html#method.as_chunks_unchecked_mut"><code>&lt;[T]&gt;::as_chunks_unchecked_mut</code></a></li>
</ul>
<p>These previously stable APIs are now stable in const contexts:</p>
<ul>
<li><a href="https://doc.rust-lang.org/stable/std/ptr/struct.NonNull.html#method.replace"><code>NonNull&lt;T&gt;::replace</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/primitive.pointer.html#method.replace"><code>&lt;*mut T&gt;::replace</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/ptr/fn.swap_nonoverlapping.html"><code>std::ptr::swap_nonoverlapping</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.replace"><code>Cell::replace</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.get"><code>Cell::get</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.get_mut"><code>Cell::get_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.from_mut"><code>Cell::from_mut</code></a></li>
<li><a href="https://doc.rust-lang.org/stable/std/cell/struct.Cell.html#method.as_slice_of_cells"><code>Cell::as_slice_of_cells</code></a></li>
</ul>
<h3 id="other-changes"><a class="anchor" href="#other-changes" aria-hidden="true"></a>
Other changes</h3>
<p>The <code>i686-pc-windows-gnu</code> target has been demoted to Tier 2, as mentioned in an <a href="https://blog.rust-lang.org/2025/05/26/demoting-i686-pc-windows-gnu/">earlier post</a>. This won't have any immediate effect for users, since both the compiler and standard library tools will still be distributed by <code>rustup</code> for this target. However, with less testing than it had at Tier 1, it has more chance of accumulating bugs in the future.</p>
<p>Check out everything that changed in <a href="https://github.com/rust-lang/rust/releases/tag/1.88.0">Rust</a>, <a href="https://doc.rust-lang.org/nightly/cargo/CHANGELOG.html#cargo-188-2025-06-26">Cargo</a>, and <a href="https://github.com/rust-lang/rust-clippy/blob/master/CHANGELOG.md#rust-188">Clippy</a>.</p>
<h2 id="contributors-to-1-88-0"><a class="anchor" href="#contributors-to-1-88-0" aria-hidden="true"></a>
Contributors to 1.88.0</h2>
<p>Many people came together to create Rust 1.88.0. We couldn't have done it without all of you. <a href="https://thanks.rust-lang.org/rust/1.88.0/">Thanks!</a></p>
