<p>Rust <a href="/2025/06/26/Rust-1.88.0/">1.88.0</a> stabilizes the <code>#[unsafe(naked)]</code> attribute and the <code>naked_asm!</code> macro which are used to define naked functions.</p>
<p>A naked function is marked with the <code>#[unsafe(naked)]</code> attribute, and its body consists of a single <code>naked_asm!</code> call. For example:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> SAFETY: Respects the 64-bit System-V ABI.
</span></span><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">unsafe</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">naked</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-keyword z-other z-rust">extern</span> <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>sysv64<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span> <span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">wrapping_add</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">a</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">u64</span>, <span class="z-variable z-parameter z-rust">b</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">u64</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-&gt;</span> <span class="z-storage z-type z-rust">u64</span></span> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Equivalent to `a.wrapping_add(b)`.
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-path z-rust">core<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">arch<span class="z-punctuation z-accessor z-rust">::</span></span>naked_asm<span class="z-keyword z-operator z-logical z-rust">!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>lea rax, [rdi + rsi]<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>ret<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">    </span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre>
<p>What makes naked functions special — and gives them their name — is that the handwritten assembly block defines the <em>entire</em> function body. Unlike non-naked functions, the compiler does not add any special handling for arguments or return values.</p>
<p>This feature is a more ergonomic alternative to defining functions using <code>global_asm!</code>. Naked functions are used in low-level settings like Rust's <a href="https://github.com/rust-lang/compiler-builtins"><code>compiler-builtins</code></a>, operating systems, and embedded applications.</p>
<h2 id="why-use-naked-functions"><a class="anchor" href="#why-use-naked-functions" aria-hidden="true"></a>
Why use naked functions?</h2>
<p>But wait, if naked functions are just syntactic sugar for <code>global_asm!</code>, why add them in the first place?</p>
<p>To see the benefits, let's rewrite the <code>wrapping_add</code> example from the introduction using <code>global_asm!</code>:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> SAFETY: `wrapping_add` is defined in this module,
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> and expects the 64-bit System-V ABI.
</span></span><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">unsafe</span> <span class="z-keyword z-other z-rust">extern</span> <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>sysv64<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span> <span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust">    safe <span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">wrapping_add</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span><span class="z-variable z-parameter z-rust">a</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">u64</span>, <span class="z-variable z-parameter z-rust">b</span><span class="z-punctuation z-separator z-rust">:</span> <span class="z-storage z-type z-rust">u64</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> <span class="z-meta z-function z-return-type z-rust"><span class="z-punctuation z-separator z-rust">-&gt;</span> <span class="z-storage z-type z-rust">u64</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-function z-return-type z-rust"></span></span></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-meta z-path z-rust">core<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">arch<span class="z-punctuation z-accessor z-rust">::</span></span>global_asm<span class="z-keyword z-operator z-logical z-rust">!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-string z-quoted z-double z-raw z-rust"><span class="z-storage z-type z-string z-rust">r</span><span class="z-punctuation z-definition z-string z-begin z-rust">#&quot;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">        // Platform-specific directives that set up a function.
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">        .section .text.wrapping_add,&quot;ax&quot;,@progbits
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">        .p2align 2
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">        .globl wrapping_add
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">        .type wrapping_add,@function
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">wrapping_add:
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">        lea rax, [rdi + rsi]
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">        ret
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">.Ltmp0:
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">        .size wrapping_add, .Ltmp0-wrapping_add
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-raw z-rust">    <span class="z-punctuation z-definition z-string z-end z-rust">&quot;#</span></span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></code></pre>
<p>The assembly block starts and ends with the directives (<code>.section</code>, <code>.p2align</code>, etc.) that are required to define a function. These directives are mechanical, but they are different between object file formats. A naked function will automatically emit the right directives.</p>
<p>Next, the <code>wrapping_add</code> name is hardcoded, and will not participate in Rust's name mangling. That makes it harder to write cross-platform code, because different targets have different name mangling schemes (e.g. x86_64 macOS prefixes symbols with <code>_</code>, but Linux does not). The unmangled symbol is also globally visible — so that the <code>extern</code> block can find it — which can cause symbol resolution conflicts. A naked function's name does participate in name mangling and won't run into these issues.</p>
<p>A further limitation that this example does not show is that functions defined using global assembly cannot use generics. Especially const generics are useful in combination with assembly.</p>
<p>Finally, having just one definition provides a consistent place for (safety) documentation and attributes, with less risk of them getting out of date. Proper safety comments are essential for naked functions. The <code>naked</code> attribute is unsafe because the ABI (<code>sysv64</code> in our example), the signature, and the implementation have to be consistent.</p>
<h2 id="how-did-we-get-here"><a class="anchor" href="#how-did-we-get-here" aria-hidden="true"></a>
How did we get here?</h2>
<p>Naked functions have been in the works for a long time.</p>
<p>The <a href="https://github.com/rust-lang/rfcs/pull/1201">original RFC</a> for naked functions is from 2015. That RFC was superseded by <a href="https://github.com/rust-lang/rfcs/pull/2972">RFC 2972</a> in 2020. Inline assembly in Rust had changed substantially at that point, and the new RFC limited the body of naked functions to a single <code>asm!</code> call with some additional constraints. And now, 10 years after the initial proposal, naked functions are stable.</p>
<p>Two additional notable changes helped prepare naked functions for stabilization:</p>
<h5 id="introduction-of-the-naked-asm-macro"><a class="anchor" href="#introduction-of-the-naked-asm-macro" aria-hidden="true"></a>
Introduction of the <code>naked_asm!</code> macro</h5>
<p>The body of a naked function must be a single <code>naked_asm!</code> call. This macro is a blend between <code>asm!</code> (it is in a function body) and <code>global_asm!</code> (only some <a href="https://doc.rust-lang.org/1.88.0/reference/inline-assembly.html#r-asm.operand-type">operand types</a> are accepted).</p>
<p>The initial implementation of RFC 2972 added lints onto a standard <code>asm!</code> call in a naked function. This approach made it hard to write clear error messages and documentation. With the dedicated <code>naked_asm!</code> macro the behavior is much easier to specify.</p>
<h5 id="lowering-to-global-asm"><a class="anchor" href="#lowering-to-global-asm" aria-hidden="true"></a>
Lowering to <code>global_asm!</code></h5>
<p>The initial implementation relied on LLVM to lower functions with the <code>naked</code> attribute for code generation. This approach had two issues:</p>
<ul>
<li>LLVM would sometimes add unexpected additional instructions to what the user wrote.</li>
<li>Rust has non-LLVM code generation backends now, and they would have had to implement LLVM's (unspecified!) behavior.</li>
</ul>
<p>The implementation that is stabilized now instead converts the naked function into a piece of global assembly. The code generation backends can already emit global assembly, and this strategy guarantees that the whole body of the function is just the instructions that the user wrote.</p>
<h2 id="what-s-next-for-assembly"><a class="anchor" href="#what-s-next-for-assembly" aria-hidden="true"></a>
What's next for assembly?</h2>
<p>We're working on further assembly ergonomics improvements. If naked functions are something you are excited about and (may) use, we'd appreciate you testing these new features and providing feedback on their designs.</p>
<h5 id="extern-custom-functions"><a class="anchor" href="#extern-custom-functions" aria-hidden="true"></a>
<code>extern "custom"</code> functions</h5>
<p>Naked functions usually get the <code>extern "C"</code> calling convention. But often that calling convention is a lie. In many cases, naked functions don't implement an ABI that Rust knows about. Instead they use some custom calling convention that is specific to that function.</p>
<p>The <a href="https://github.com/rust-lang/rust/issues/140829"><code>abi_custom</code></a> feature adds <code>extern "custom"</code> functions and blocks, which allows us to correctly write code like this example from <a href="https://github.com/rust-lang/compiler-builtins/blob/267ae1fa43785448bfb0aebafc4e352c936dd4cf/compiler-builtins/src/arm.rs#L52-L63">compiler-builtins</a>:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#!</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">feature</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">abi_custom</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> Division and modulo of two numbers using Arm&#39;s nonstandard ABI.
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span>
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> ```c
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> typedef struct { int quot; int rem; } idiv_return;
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span>  __value_in_regs idiv_return __aeabi_idivmod(int num, int denom);
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-documentation z-rust"><span class="z-punctuation z-definition z-comment z-rust">///</span> ```
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> SAFETY: The assembly implements the expected ABI, and &quot;custom&quot;
</span></span><span class="z-source z-rust"><span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> ensures this function cannot be called directly.
</span></span><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">unsafe</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">naked</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust"><span class="z-storage z-modifier z-rust">pub</span> <span class="z-storage z-modifier z-rust">unsafe</span> <span class="z-keyword z-other z-rust">extern</span> <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>custom<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span> <span class="z-meta z-function z-rust"><span class="z-meta z-function z-rust"><span class="z-storage z-type z-function z-rust">fn</span> </span><span class="z-entity z-name z-function z-rust">__aeabi_idivmod</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-begin z-rust">(</span></span><span class="z-meta z-function z-rust"><span class="z-meta z-function z-parameters z-rust"><span class="z-punctuation z-section z-parameters z-end z-rust">)</span></span></span></span><span class="z-meta z-function z-rust"> </span><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-begin z-rust">{</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust">    <span class="z-meta z-path z-rust">core<span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">arch<span class="z-punctuation z-accessor z-rust">::</span></span>naked_asm<span class="z-keyword z-operator z-logical z-rust">!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>push {{r0, r1, r4, lr}}<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span> <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Back up clobbers.
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>bl {trampoline}<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span>         <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Call an `extern &quot;C&quot;` function for a / b.
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>pop {{r1, r2}}<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>muls r2, r2, r0<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span>         <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Perform the modulo.
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>subs r1, r1, r2<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>pop {{r4, pc}}<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span>          <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> Restore clobbers, implicit return by setting `pc`.
</span></span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">        trampoline <span class="z-keyword z-operator z-assignment z-rust">=</span> sym <span class="z-keyword z-other z-rust">crate</span><span class="z-meta z-path z-rust"><span class="z-punctuation z-accessor z-rust">::</span></span><span class="z-meta z-path z-rust">arm<span class="z-punctuation z-accessor z-rust">::</span></span>__aeabi_idiv<span class="z-punctuation z-separator z-rust">,</span>
</span></span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"><span class="z-meta z-group z-rust">    </span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span><span class="z-punctuation z-terminator z-rust">;</span>
</span></span></span><span class="z-source z-rust"><span class="z-meta z-function z-rust"><span class="z-meta z-block z-rust"></span><span class="z-meta z-block z-rust"><span class="z-punctuation z-section z-block z-end z-rust">}</span></span></span>
</span></code></pre>
<p>A consequence of using a custom calling convention is that such functions cannot be called using a Rust call expression; the compiler simply does not know how to generate correct code for such a call. Instead the compiler will error when the program does try to call an <code>extern "custom"</code> function, and the only way to execute the function is using inline assembly.</p>
<h5 id="cfg-on-lines-of-inline-assembly"><a class="anchor" href="#cfg-on-lines-of-inline-assembly" aria-hidden="true"></a>
<code>cfg</code> on lines of inline assembly</h5>
<p>The <a href="https://github.com/rust-lang/rust/issues/140364"><code>cfg_asm</code></a> feature adds the ability to annotate individual lines of an assembly block with <code>#[cfg(...)]</code> or <code>#[cfg_attr(..., ...)]</code>. Configuring specific sections of assembly is useful to make assembly depend on, for instance, the target, target features, or feature flags. For example:</p>
<pre data-lang="rust" class="language-rust z-code"><code class="language-rust" data-lang="rust"><span class="z-source z-rust"><span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#!</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">feature</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">cfg_asm</span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span><span class="z-source z-rust">
</span><span class="z-source z-rust"><span class="z-support z-macro z-rust">global_asm!</span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> ...
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> If enabled, initialise the SP. This is normally
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> initialised by the CPU itself or by a bootloader, but
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> some debuggers fail to set it when resetting the
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> target, leading to stack corruptions.
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-meta z-annotation z-rust"><span class="z-punctuation z-definition z-annotation z-rust">#</span><span class="z-punctuation z-section z-group z-begin z-rust">[</span><span class="z-variable z-annotation z-rust">cfg</span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-begin z-rust">(</span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust">feature <span class="z-keyword z-operator z-rust">=</span> <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>set-sp<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span></span></span><span class="z-meta z-annotation z-parameters z-rust"><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span></span><span class="z-punctuation z-section z-group z-end z-rust">]</span></span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">    <span class="z-string z-quoted z-double z-rust"><span class="z-punctuation z-definition z-string z-begin z-rust">&quot;</span>ldr r0, =_stack_start
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"><span class="z-string z-quoted z-double z-rust">     msr msp, r0<span class="z-punctuation z-definition z-string z-end z-rust">&quot;</span></span><span class="z-punctuation z-separator z-rust">,</span>
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">
</span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust">     <span class="z-comment z-line z-double-slash z-rust"><span class="z-punctuation z-definition z-comment z-rust">//</span> ...
</span></span></span><span class="z-source z-rust"><span class="z-meta z-group z-rust"></span><span class="z-meta z-group z-rust"><span class="z-punctuation z-section z-group z-end z-rust">)</span></span>
</span></code></pre>
<p>This example is from the <a href="https://github.com/rust-embedded/cortex-m/blob/c3d664bba1148cc2d0f963ebeb788aa347ba81f7/cortex-m-rt/src/lib.rs#L528-L636">cortex-m</a> crate that currently has to use a custom macro that duplicates the whole assembly block for every use of <code>#[cfg(...)]</code>. With <code>cfg_asm</code>, that will no longer be necessary.</p>
