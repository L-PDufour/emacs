<p>C23 has <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3037.pdf">a new rule for struct, union, and enum compatibility</a>
finally appearing in compilers starting with GCC 15, released this past
April, and Clang later this year. The same struct defined in different
translation units (TU) has always been compatible — essential to how they
work. Until this rule change, each such definition within a TU was a
distinct, incompatible type. The new rule says that, <em>ackshually</em>, they
are compatible! This unlocks some type parameterization using macros.</p>

<p>How can a TU have multiple definitions of a struct? Scope. Prior to C23
this wouldn’t compile because the compound literal type and the return
type were distinct types:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Example</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">Example</span> <span class="nf">example</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">struct</span> <span class="n">Example</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span> <span class="p">};</span>
    <span class="k">return</span> <span class="p">(</span><span class="k">struct</span> <span class="n">Example</span><span class="p">){</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Otherwise the definition of <code class="language-plaintext highlighter-rouge">struct Example</code> within <code class="language-plaintext highlighter-rouge">example</code> was fine, if
strange. At first this may not seem like a big deal, but let’s <a href="/blog/2025/01/19/">revisit my
technique for dynamic arrays</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">T</span>        <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span> <span class="n">len</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span> <span class="n">cap</span><span class="p">;</span>
<span class="p">}</span> <span class="n">SliceT</span><span class="p">;</span>
</code></pre></div></div>

<p>Where I write out one of these for each <code class="language-plaintext highlighter-rouge">T</code> that I might want to put into
a slice. With the new rule we can change it slightly, taking note of the
introduction of a tag (the name after <code class="language-plaintext highlighter-rouge">struct</code>):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define Slice(T)        \
    struct Slice##T {   \
        T        *data; \
        ptrdiff_t len;  \
        ptrdiff_t cap;  \
    }
</span></code></pre></div></div>

<p>This makes the “write it out ahead of time” thing simpler, but with the
new rule we can skip the “ahead of time” part and conjure slice types on
demand. Each declaration with the same <code class="language-plaintext highlighter-rouge">T</code> is compatible with the others
due to matching tags and fields. So, for example, with this macro we can
declare functions using slices parameterized for different element types.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Slice</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="n">range</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="n">Arena</span> <span class="o">*</span><span class="p">);</span>

<span class="kt">float</span> <span class="nf">mean</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="kt">float</span><span class="p">));</span>

<span class="n">Slice</span><span class="p">(</span><span class="n">Str</span><span class="p">)</span> <span class="n">split</span><span class="p">(</span><span class="n">Str</span><span class="p">,</span> <span class="kt">char</span> <span class="n">delim</span><span class="p">,</span> <span class="n">Arena</span> <span class="o">*</span><span class="p">);</span>
<span class="n">Str</span> <span class="nf">join</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="n">Str</span><span class="p">),</span> <span class="kt">char</span> <span class="n">delim</span><span class="p">,</span> <span class="n">Arena</span> <span class="o">*</span><span class="p">);</span>
</code></pre></div></div>

<p>Or using it with <a href="/blog/2025/03/02/">our model parser</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Vec3</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="kt">int32_t</span> <span class="n">n</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Face</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Vec3</span><span class="p">)</span> <span class="n">verts</span><span class="p">;</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Vec3</span><span class="p">)</span> <span class="n">norms</span><span class="p">;</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Face</span><span class="p">)</span> <span class="n">faces</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Model</span><span class="p">;</span>

<span class="k">typedef</span> <span class="n">Slice</span><span class="p">(</span><span class="n">Vec3</span><span class="p">)</span> <span class="n">Polygon</span><span class="p">;</span>
</code></pre></div></div>

<p>I worried these macros might confuse my tools, particularly <a href="https://github.com/universal-ctags/ctags">Universal
Ctags</a> because <a href="https://github.com/skeeto/w64devkit">it’s important to me</a>. Everything handles
prototypes better than expected, but ctags doesn’t see fields with slice
types. Overall they’re like a very limited form of C++ templates. Though
only the types are parameterized, not the functions operating on those
types. Outside of unwarranted macro abuse, this new technique does nothing
regarding generic functions. On the other hand, my generic slice function
complements the new technique, especially with the help of C23’s new
<code class="language-plaintext highlighter-rouge">typeof</code> to mitigate <code class="language-plaintext highlighter-rouge">_Alignof</code>’s limitations:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span> <span class="kt">char</span> <span class="o">*</span><span class="n">beg</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span> <span class="p">}</span> <span class="n">Arena</span><span class="p">;</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">alloc</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">align</span><span class="p">);</span>

<span class="cp">#define push(a, s)                          \
  ((s)-&gt;len == (s)-&gt;cap                     \
    ? (s)-&gt;data = push_(                    \
        (a),                                \
        (s)-&gt;data,                          \
        &amp;(s)-&gt;cap,                          \
        sizeof(*(s)-&gt;data),                 \
        _Alignof(typeof(*(s)-&gt;data))        \
      ),                                    \
      (s)-&gt;data + (s)-&gt;len++                \
    : (s)-&gt;data + (s)-&gt;len++)
</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">push_</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">void</span> <span class="o">*</span><span class="n">data</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="o">*</span><span class="n">pcap</span><span class="p">,</span> <span class="kt">int</span> <span class="n">size</span><span class="p">,</span> <span class="kt">int</span> <span class="n">align</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">ptrdiff_t</span> <span class="n">cap</span> <span class="o">=</span> <span class="o">*</span><span class="n">pcap</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span> <span class="o">!=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">data</span> <span class="o">+</span> <span class="n">cap</span><span class="o">*</span><span class="n">size</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="o">*</span><span class="n">copy</span> <span class="o">=</span> <span class="n">alloc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">cap</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">copy</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">cap</span><span class="o">*</span><span class="n">size</span><span class="p">);</span>
        <span class="n">data</span> <span class="o">=</span> <span class="n">copy</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">ptrdiff_t</span> <span class="n">extend</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">?</span> <span class="n">cap</span> <span class="o">:</span> <span class="mi">4</span><span class="p">;</span>
    <span class="n">alloc</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">extend</span><span class="p">,</span> <span class="n">size</span><span class="p">,</span> <span class="n">align</span><span class="p">);</span>
    <span class="o">*</span><span class="n">pcap</span> <span class="o">=</span> <span class="n">cap</span> <span class="o">+</span> <span class="n">extend</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>This exploits the fact that implementations adopting the new tag rule also
have <a href="https://www.open-std.org/jtc1/sc22/wg14/www/docs/n3322.pdf">the upcoming C2y null pointer rule</a> (note: also requires a
cooperating libc). Putting it together, now I can write stuff like this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Slice</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="n">generate_primes</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">limit</span><span class="p">,</span> <span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Slice</span><span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span> <span class="n">primes</span> <span class="o">=</span> <span class="p">{};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">limit</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">*</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">)</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int64_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">limit</span><span class="p">;</span> <span class="n">n</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">bool</span> <span class="n">valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">valid</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">&lt;</span><span class="n">primes</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">valid</span> <span class="o">=</span> <span class="n">n</span> <span class="o">%</span> <span class="n">primes</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
            <span class="o">*</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">primes</span><span class="p">)</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">primes</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>But it doesn’t take long to run into limitations. It makes little sense to
define, say, a <code class="language-plaintext highlighter-rouge">Map(K, V)</code> without a generic function to manipulate it.
This also doesn’t work:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Str</span><span class="p">)</span>          <span class="n">names</span><span class="p">;</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="kt">float</span><span class="p">))</span> <span class="n">edges</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Graph</span><span class="p">;</span>
</code></pre></div></div>

<p>Due to <code class="language-plaintext highlighter-rouge">Slice##T</code> in the macro, required to establish a unique tag for
each element type. The parameter to the macro must be an identifier, so
you have to build up to it (or define another macro), which sort of
defeats the purpose, which was entirely about convenience.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">Slice</span><span class="p">(</span><span class="kt">float</span><span class="p">)</span> <span class="n">Edges</span><span class="p">;</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Str</span><span class="p">)</span>   <span class="n">names</span><span class="p">;</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Edges</span><span class="p">)</span> <span class="n">edges</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Graph</span><span class="p">;</span>
</code></pre></div></div>

<p>The benefits are small enough that perhaps it’s not worth the costs, but
it’s been at least worth investigating. I’ve written a small demo of the
technique if you’d like to see it in action, or test the abilities of your
local C implementation: <a href="https://gist.github.com/skeeto/3fe27cd81ca5bdb4926b12e03bdfbc62"><code class="language-plaintext highlighter-rouge">demo.c</code></a></p>


    