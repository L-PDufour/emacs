<p>Fuzz testing is incredibly effective for mechanically discovering software
defects, yet remains underused and neglected. Pick any program that must
gracefully accept complex input, written <em>in any language</em>, which has not
yet been been fuzzed, and fuzz testing usually reveals at least one bug.
At least one program currently installed on your own computer certainly
qualifies. Perhaps even most of them. <a href="https://danluu.com/everything-is-broken/">Everything is broken</a> and
low-hanging fruit is everywhere. After fuzz testing ~1,000 projects <a href="/blog/2019/01/25/">over
the past six years</a>, I’ve accumulated tips for picking that fruit.
The checklist format has worked well in the past (<a href="/blog/2024/12/20/">1</a>, <a href="/blog/2023/01/08/">2</a>), so
I’ll use it again. This article discusses <a href="https://aflplus.plus/">AFL++</a> on source-available
C and C++ targets, running on glibc-based Linux distributions, currently
the <em>indisputable</em> best fuzzing platform for C and C++.</p>

<p>My tips complement the official, upstream documentation, so consult them,
too:</p>

<ul>
  <li><a href="https://afl-1.readthedocs.io/en/latest/tips.html">Performance Tips</a> on the AFL++ website</li>
  <li><a href="https://lcamtuf.coredump.cx/afl/technical_details.txt">Technical “whitepaper” for afl-fuzz</a></li>
</ul>

<p>Even if a program has been fuzz tested, applying the techniques in this
article may reveal defects missed by previous fuzz testing.</p>

<h3 id="1-configure-sanitizers-and-assertions">(1) Configure sanitizers and assertions</h3>

<p>More assertions means more effective fuzzing, and sanitizers are a kind of
automatically-inserted assertions. By default, fuzz with both Address
Sanitizer (ASan) and Undefined Behavior Sanitizer (UBSan):</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ afl-gcc-fast -g3 -fsanitize=address,undefined ...
</code></pre></div></div>

<p>ASan’s default configuration is not ideal, and should be adjusted via the
<code class="language-plaintext highlighter-rouge">ASAN_OPTIONS</code> environment variable. If customized at all, AFL++ requires
at least these options:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>export ASAN_OPTIONS="abort_on_error=1:halt_on_error=1:symbolize=0"
</code></pre></div></div>

<p>Except <code class="language-plaintext highlighter-rouge">symbolize=0</code>, <a href="/blog/2022/06/26/">this <em>ought to be</em> the ASan default</a>. When
debugging a discovered crash, you’ll want UBSan set up the same way so
that it behaves under in a debugger. To improve fuzzing, make ASan even
more sensitive to defects by detecting use-after-return bugs. It slows
fuzzing slightly, but it’s well worth the cost:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ASAN_OPTIONS+=":detect_stack_use_after_return=1"
</code></pre></div></div>

<p>By default ASan fills the first 4KiB of fresh allocations with a pattern,
to help detect use-after-free bugs. That’s not nearly enough for fuzzing.
Crank it up to completely fill virtually all allocations with a pattern:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ASAN_OPTIONS+=":max_malloc_fill_size=$((1&lt;&lt;30))"
</code></pre></div></div>

<p>In the default configuration, if a program allocates more than 4KiB with
<code class="language-plaintext highlighter-rouge">malloc</code> then, say, uses <code class="language-plaintext highlighter-rouge">strlen</code> on the uninitialized memory, no bug will
be detected. There’s almost certainly a zero somewhere after 4KiB. Until I
noticed it, the 4KiB limit hid a number of bugs from my fuzz testing. Per
(4), fulling filling allocations with a pattern better isolates tests when
using persistent mode.</p>

<p>When fuzzing C++ and linking GCC’s libstdc++, consider <code class="language-plaintext highlighter-rouge">-D_GLIBCXX_DEBUG</code>.
ASan cannot “see” out-of-bounds accesses within a container’s capacity,
and the extra assertions fill in the gaps. Mind that it changes the ABI,
though fuzz testing will instantly highlight such mismatches.</p>

<h3 id="2-prefer-the-persistent-mode">(2) Prefer the persistent mode</h3>

<p>While AFL++ can fuzz many programs in-place without writing a single line
of code (<code class="language-plaintext highlighter-rouge">afl-gcc</code>, <code class="language-plaintext highlighter-rouge">afl-clang</code>), prefer AFL++’s <a href="https://github.com/AFLplusplus/AFLplusplus/blob/stable/instrumentation/README.persistent_mode.md">persistent mode</a>
(<code class="language-plaintext highlighter-rouge">afl-gcc-fast</code>, <code class="language-plaintext highlighter-rouge">afl-clang-fast</code>). It’s typically an order of magnitude
faster and worth the effort. Though it also has pitfalls (see (4), (5)). I
keep a file on hand, <code class="language-plaintext highlighter-rouge">fuzztmpl.c</code> — the progenitor of all my fuzz testers:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span>
<span class="n">__AFL_FUZZ_INIT</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__AFL_INIT</span><span class="p">();</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">src</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">buf</span> <span class="o">=</span> <span class="n">__AFL_FUZZ_TESTCASE_BUF</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">__AFL_LOOP</span><span class="p">(</span><span class="mi">10000</span><span class="p">))</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="n">__AFL_FUZZ_TESTCASE_LEN</span><span class="p">;</span>
        <span class="n">src</span> <span class="o">=</span> <span class="n">realloc</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">src</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
        <span class="c1">// ... send src to target ...</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I <a href="https://vimhelp.org/insert.txt.html#%3Aread"><code class="language-plaintext highlighter-rouge">:r</code></a> this into my Vim buffer, then modify as needed. It’s a
stripped and improved version of the official template, which itself has a
serious flaw (see (5)). There are unstated constraints about the position
of <code class="language-plaintext highlighter-rouge">buf</code> and <code class="language-plaintext highlighter-rouge">len</code> in the code, so if in doubt, refer to the original
template.</p>

<h3 id="3-include-source-files-not-header-files">(3) Include source files, not header files</h3>

<p>We’re well into the 21st century. Nobody is compiling software on 16-bit
machines anymore. Don’t get hung up on the one translation unit (TU) per
source file mindset. When fuzz testing, we need at most two TUs: One TU
for instrumented code and one TU for uninstrumented code. In most cases
the latter takes the form of a library (libc, libstdc++, etc.) and we
don’t need to think about it.</p>

<p>Fuzz testing typically requires only a subset of the program. Including
just those sources straight in the template is both effective and simple.
In my template I put includes just <em>above</em> <code class="language-plaintext highlighter-rouge">unistd.h</code> so that the header
isn’t visible to the sources unless they include it themselves.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#include</span> <span class="cpf">"src/utils.c"</span><span class="cp">
#include</span> <span class="cpf">"src/parser.c"</span><span class="cp">
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>I know, if you’ve never seen this before it looks bonkers. This isn’t what
they taught you in college. Trust me, <a href="https://en.wikipedia.org/wiki/Unity_build">this simple technique</a> will
save you a thousand lines of build configuration. Otherwise you’ll need to
manage different object files between fuzz testing and otherwise.</p>

<p>Perhaps more importantly, you can now fuzz test <em>any arbitrary function</em>
in the program, including static functions! They’re all right there in the
same TU. You’re not limited to public-facing interfaces. Perhaps you can
skip (7) and test against a better internal interface. It also gives you
direct access to static variables so that you can clear/reset them between
tests, per (4).</p>

<p>Programs are often not designed for fuzz testing, or testing generally,
and it may be difficult to tease apart tightly-coupled components. Many of
the programs I’ve fuzz tested look like this. This technique lets you take
a hacksaw to the program and substitute troublesome symbols just for fuzz
testing without modifying a single original source line. For example, if
the source I’m testing contains a <code class="language-plaintext highlighter-rouge">main</code> function, I can remove it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define main oldmain
#  include "src/utils.c"
#  include "src/parser.c"
#undef main
#include</span> <span class="cpf">&lt;unistd.h&gt;</span><span class="cp">
</span></code></pre></div></div>

<p>Sure, better to improve the program so that such hacks are unnecessary,
but most cases I’m fuzz testing as part of a drive-by review of some open
source project. It allows me to quickly discover defects in the original,
unmodified program, and produces simpler bug reports like, “Compile with
ASan, open this 50-byte file, and then the program will crash.”</p>

<h3 id="4-isolate-fuzz-tests-from-each-other">(4) Isolate fuzz tests from each other</h3>

<p>Tests should be unaffected by previous tests. This is challenging in
persistent mode, sometimes even impractical. That means resetting all
global state, even something like the internal <code class="language-plaintext highlighter-rouge">strtok</code> buffer if that
function is used. Add fuzz testing to your list of reasons to eschew
global variables.</p>

<p>It’s mitigated by (1), but otherwise uninitialized heap memory may hold
contents from previous tests, breaking isolation. Besides interference
with fuzzing instrumentation, bugs found this way are wickedly difficult
to reproduce.</p>

<p>Don’t pass uninitialized memory into a test, e.g. an output parameter
allocated on the stack. Zero-initialize or fill it with a pattern. If it
accepts an arena, fill it with a pattern before each test.</p>

<p>Typically you have little control over heap addresses, which likely varies
across tests and depends on the behavior previous tests. If the program
<a href="/blog/2025/01/19/#hash-hardening-bonus">depends on address values</a>, this may affect the results and make
reproduction difficult, so watch for that.</p>

<h3 id="5-do-not-test-directly-on-the-fuzz-test-buffer">(5) Do not test directly on the fuzz test buffer</h3>

<p>Passing <code class="language-plaintext highlighter-rouge">buf</code> and <code class="language-plaintext highlighter-rouge">len</code> straight into the target is the most common
mistake, especially when fuzzing better-designed C programs, and
particularly because the official template encourages it.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">myprogram</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>  <span class="c1">// BAD!</span>
</code></pre></div></div>

<p>While it’s a great sign the program doesn’t depend on null termination, it
creates a subtle trap. The underlying buffer allocated by AFL++ is larger
than <code class="language-plaintext highlighter-rouge">len</code>, and ASan will not detect read overflows on inputs! Instead
pass a copy sized to fit, which is the purpose of <code class="language-plaintext highlighter-rouge">src</code> in my template.
Adjust the type of <code class="language-plaintext highlighter-rouge">src</code> as needed.</p>

<p>If the program expects null-terminated input then you’ll need to do this
anyway in order to append the null byte. If it accepts an “owning” type
like <code class="language-plaintext highlighter-rouge">std::string</code>, then it’s also already done on your behalf. With
“non-owning” views like <code class="language-plaintext highlighter-rouge">std::string_view</code> you’ll still want to your own
size-fit copy.</p>

<p>If you see a program’s checked in fuzz test using <code class="language-plaintext highlighter-rouge">buf</code> directly, make
this change and see if anything new pops out. It’s worked for me on a
number of occasions.</p>

<h3 id="6-dont-bother-freeing-memory">(6) Don’t bother freeing memory</h3>

<p>In general, avoid doing work irrelevant to the fuzz test. The official
tips say to “use a simpler target” and “instrument just what you need,”
and keeping destructors out of the tests helps in both cases. Unless the
program is especially memory-hungry, you won’t run out of memory before
AFL++ resets the target process.</p>

<p>If not for (1), it also helps with isolation (4), as different tests are
less likely contaminated with uninitialized memory from previous tests.</p>

<p>As an exception, if you want your destructor included in the fuzz test,
then use it in the test. Also, it’s easy to exhaust non-memory resources,
particularly file descriptors, and you may need to <a href="https://man7.org/linux/man-pages/man2/close_range.2.html">clean those up</a>
in order to fuzz test reliably.</p>

<p>Of course, if the target uses <a href="/blog/2023/09/27/">arena allocation</a> then none of this
matters! It also makes for perfect isolation, as even addresses won’t vary
between tests.</p>

<h3 id="7-use-a-memory-file-descriptor-to-back-named-paths">(7) Use a memory file descriptor to back named paths</h3>

<p>Many interfaces are, shall we say, <em>not so well-designed</em> and only accept
input from a named file system path, insisting on opening and reading the
file themselves. Testing such interfaces presents challenges, especially
if you’re interested in parallel fuzzing. Fortunately there’s usually an
easy out: Create a memory file descriptor and use its <code class="language-plaintext highlighter-rouge">/proc</code> name.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">fd</span> <span class="o">=</span> <span class="n">memfd_create</span><span class="p">(</span><span class="s">"fuzz"</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="n">assert</span><span class="p">(</span><span class="n">fd</span> <span class="o">==</span> <span class="mi">3</span><span class="p">);</span>
<span class="k">while</span> <span class="p">(...)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">ftruncate</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">pwrite</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">myprogram</span><span class="p">(</span><span class="s">"/proc/self/fd/3"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With standard input as 0, output as 1, and error as 2, I’ve assumed the
memory file descriptor will land on 3, which makes the test code a little
simpler. If it’s not 3 then something’s probably gone wrong anyway, and
aborting is the best option. If you don’t want to assume, use <code class="language-plaintext highlighter-rouge">snprintf</code>
or whatever to construct the path name from <code class="language-plaintext highlighter-rouge">fd</code>.</p>

<p>Using <code class="language-plaintext highlighter-rouge">pwrite</code> (instead of <code class="language-plaintext highlighter-rouge">write</code>) leaves the file description offset at
the beginning of the file.</p>

<p>Thanks to the memory file descriptor, fuzz test data doesn’t land in
permanent storage, so less wear and tear on your SSD from the occasional
flush. Because of <code class="language-plaintext highlighter-rouge">/proc</code>, the file is unique to the process despite the
common path name, so no problems parallel fuzzing. No cleanup needed,
either.</p>

<p>If the program wants a file descriptor — i.e. it wants a socket because
you’re fuzzing some internal function — pass the file descriptor directly:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">myprogram</span><span class="p">(</span><span class="n">fd</span><span class="p">);</span>
</code></pre></div></div>

<p>If it accepts a <code class="language-plaintext highlighter-rouge">FILE *</code>, you <em>could</em> <code class="language-plaintext highlighter-rouge">fopen</code> the <code class="language-plaintext highlighter-rouge">/proc</code> path, but better
to use <code class="language-plaintext highlighter-rouge">fdmemopen</code> to create a <code class="language-plaintext highlighter-rouge">FILE *</code> on the object:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">myprogram</span><span class="p">(</span><span class="n">fdmemopen</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">,</span> <span class="s">"rb"</span><span class="p">));</span>
</code></pre></div></div>

<p>Note how, per (6), we don’t need to bother with <code class="language-plaintext highlighter-rouge">fclose</code> because it’s not
associated with a file descriptor.</p>

<h3 id="8-configure-the-target-for-smaller-buffers">(8) Configure the target for smaller buffers</h3>

<p>A common sight in <a href="http://catb.org/jargon/html/C/C-Programmers-Disease.html">diseased programs</a> are “generous” fixed buffer
sizes:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define MY_MAX_BUFFER_LENGTH 65536
</span>
<span class="kt">void</span> <span class="nf">example</span><span class="p">(...)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">path</span><span class="p">[</span><span class="n">PATH_MAX</span><span class="p">];</span>  <span class="c1">// typically 4,096</span>
    <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="n">MY_MAX_BUFFER_LENGTH</span><span class="p">];</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>These huge buffers tend to hide bugs. Turn those stones over! It takes a
lot of fuzzing time to max them out and excite the unhappy paths — or the
super-unhappy paths, overflows. Better if the fuzz test can reach worst
case conditions quickly and explore the execution paths out of it.</p>

<p>So when you see these, cut them way down, possibly using (3). Change 65536
to, say, 16 and see what happens. If fuzzing finds a crash on the short
buffer, typically extending the input to crash on the original buffer size
is straightforward, e.g. repeat one of the bytes even more than it already
repeats.</p>

<h3 id="conclusion-and-samples">Conclusion and samples</h3>

<p>Hopefully something here will help you catch a defect that would have
otherwise gone unnoticed. Even better, perhaps awareness of these fuzzing
techniques will prevent the bug in the first place. Thanks to my template,
some solid tooling, and the know-how in this article, I can whip up a fuzz
test in a couple of minutes. But that ease means I discard it as just as
casually, and so I don’t take time to capture and catalog most. If you’d
like to see some samples, <a href="https://old.reddit.com/r/C_Programming/comments/15wouat/_/jx2ld4a/">I do have an old, short list</a>. Perhaps
after another kiloproject of fuzz testing I’ll pick up more techniques.</p>


    