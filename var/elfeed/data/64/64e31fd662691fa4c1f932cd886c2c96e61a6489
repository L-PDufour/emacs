<p>xxd is a versatile hexdump utility with a “reverse” feature, originally
written between 1990–1996. The Vim project soon adopted it, and it’s lived
there ever since. If you have Vim, you also have xxd. Its primary use
cases are (1) the basis for a hex editor due to its <code class="language-plaintext highlighter-rouge">-r</code> reverse option
that can <em>unhexdump</em> its previous output, and (2) a data embedding tool
for C and C++ (<code class="language-plaintext highlighter-rouge">-i</code>). The former provides Vim’s rudimentary hex editor
functionality. The second case is of special interest to <a href="https://github.com/skeeto/w64devkit">w64devkit</a>:
<code class="language-plaintext highlighter-rouge">xxd -i</code> appears in many builds that <a href="/blog/2016/11/15/">embed arbitrary data</a>. It’s
important that w64devkit has a compatible implementation, and a freshly
rewritten, improved xxd, <strong><a href="https://github.com/skeeto/w64devkit/blob/master/src/rexxd.c">rexxd</a></strong>, now replaces the original xxd (as
<code class="language-plaintext highlighter-rouge">xxd</code>).</p>

<p>For those unfamiliar with xxd, examples are in order. Its default hexdump
output looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo hello world | xxd | tee dump
00000000: 6865 6c6c 6f20 776f 726c 640a            hello world.
</code></pre></div></div>

<p>Octets display in pairs with an ASCII text listing on the right. All
configurable. I can run this in reverse (<code class="language-plaintext highlighter-rouge">-r</code>), recovering the original
input:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ xxd -r dump
hello world
</code></pre></div></div>

<p>The tool reads the offset before the colon, the hexadecimal octets, and
ignores the text column. By editing <code class="language-plaintext highlighter-rouge">dump</code> with a text editor, I can
change the raw octets of the original input. From this point of view, the
hexdump is actually a program of two alternating instructions: seek and
write. xxd <em>seeks</em> to the offset, <em>writes</em> the octets, then repeats. It
also doesn’t truncate the output file, so a hexdump can express binary
patches as a seek/write program.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo hello world &gt;hello
$ echo 6: 65766572796f6e650a | xxd -r - hello
$ cat hello
hello everyone
</code></pre></div></div>

<p>That seeks to offset <code class="language-plaintext highlighter-rouge">0x6</code>, then writes the 9 octets. The xxd parser is
flexible, and I did not need to follow the default format. It figured out
the format on its own, and rexxd further improves on this. We can use it
to create large files out of thin air, too:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo 3fffffff: 00 | xxd -r - &gt;1G
</code></pre></div></div>

<p>This command creates an all-zero, 1GiB file, <code class="language-plaintext highlighter-rouge">1G</code>, by seeking to just
before 1GiB then writing a zero. I used <code class="language-plaintext highlighter-rouge">&gt;1G</code> so that the shell would
truncate the file before starting <code class="language-plaintext highlighter-rouge">xxd</code> — in case it was larger or
contained non-zeros.</p>

<p>This is a “smart seek” of course, and its not literally seeking on every
line. The tool tracks its file position and only seeks when necessary. If
seeking fails, it simulates the seek using a write if possible. When would
it not be possible? Lines need not be in order, of course, and so it may
need to seek backwards. Lines can also overlap in contents. If it weren’t
for buffering — or if rexxd had a <a href="https://utcc.utoronto.ca/~cks/space/blog/unix/UnifiedBufferCache">unified buffer cache</a> — then by
using the same file for input and output an “xxd program” could write new
instructions for itself and <a href="/blog/2016/04/30/">accidentally become Turing-complete</a>.</p>

<p>The other common mode, <code class="language-plaintext highlighter-rouge">-i</code>, looks like this:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo hello world &gt;hello
$ xxd -i hello hello.c
</code></pre></div></div>

<p>Which produces this <code class="language-plaintext highlighter-rouge">hello.c</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">hello</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mh">0x68</span><span class="p">,</span> <span class="mh">0x65</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="mh">0x6f</span><span class="p">,</span> <span class="mh">0x20</span><span class="p">,</span> <span class="mh">0x77</span><span class="p">,</span> <span class="mh">0x6f</span><span class="p">,</span> <span class="mh">0x72</span><span class="p">,</span> <span class="mh">0x6c</span><span class="p">,</span> <span class="mh">0x64</span><span class="p">,</span> <span class="mh">0x0a</span>
<span class="p">};</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">hello_len</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
</code></pre></div></div>

<p>Note how it converted the file name into variable names. Characters
disallowed in variable names become underscores <code class="language-plaintext highlighter-rouge">_</code>. When reading from
standard input, xxd only emits the octets. Unless the new-ish <code class="language-plaintext highlighter-rouge">-n</code> name
option is given, in which case that becomes the variable name. This
remains popular because, <a href="https://en.cppreference.com/w/c/preprocessor/embed"><code class="language-plaintext highlighter-rouge">#embed</code></a> notwithstanding, as of this
writing all major toolchains remain stubborn about embedding data on their
own.</p>

<h3 id="the-case-for-replacement">The case for replacement</h3>

<p>The idea of replacing it began with backporting the <code class="language-plaintext highlighter-rouge">-n</code> name option to
Vim 9.0 xxd. The feature did not appear in a release until a year ago, 28
years after <code class="language-plaintext highlighter-rouge">-i</code>, despite its obviousness. I’ve also felt that <code class="language-plaintext highlighter-rouge">xxd</code> is
slower than it could be, and a momentary examination reveals it’s buggier
than it ought to be. <a href="/blog/2025/02/05/">As expected</a>, a few seconds of fuzz testing
<code class="language-plaintext highlighter-rouge">xxd -r</code> reveals bugs, and it doesn’t even require writing a single line
of code:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ afl-gcc -fsanitize=address,undefined xxd.c
$ mkdir inputs
$ echo &gt;inputs/sample
$ afl-fuzz -i inputs/ -o fuzzout/ ./a.out -r
</code></pre></div></div>

<p>The Windows port is lacking in the usual ways, unable to handle Unicode
paths. The new Vim 9.1 xxd <code class="language-plaintext highlighter-rouge">-R</code> color feature broke the Windows port, and
if w64devkit included Vim 9.1 then I’d need to patch out the new bugs. As
demonstrated above, at least it’s trivial to compile! It’s a single source
file, <code class="language-plaintext highlighter-rouge">xxd.c</code>, and requires no configuration. I love that.</p>

<p>The more I looked, the more problems I found. It’s not doing anything
terribly complex, so I expected it wouldn’t be difficult to rewrite it
with a better foundation. So I did. Ignoring tests and documentation, my
rewrite is about twice as long. In exchange, it’s <em>substantially faster</em>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ dd if=/dev/urandom of=bigfile bs=1M count=64

$ time orig-xxd bigfile dump
real    0m 4.40s
user    0m 2.89s
sys     0m 1.46s

$ time rexxd bigfile dump
real    0m 0.31s
user    0m 0.07s
sys     0m 0.21s
</code></pre></div></div>

<p>Same in reverse:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ time orig-xxd -r dump nul
real    0m 5.81s
user    0m 5.67s
sys     0m 0.07s

$ time rexxd -r dump nul
real    0m 0.33s
user    0m 0.23s
sys     0m 0.09s
</code></pre></div></div>

<p>Or embedding data with rexxd:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ time orig-xxd -i bigfile bigfile.c
real    0m 10.32s
user    0m 9.85s
sys     0m 0.37s

$ time rexxd -i bigfile bigfile.c
real    0m 0.40s
user    0m 0.07s
sys     0m 0.34s
</code></pre></div></div>

<p>I wanted to keep it portable and simple, so that’s without <a href="/blog/2021/12/04/">fancy SIMD
processing</a>. Just <a href="/blog/2022/04/30/">SWAR parsing</a>, <a href="/blog/2017/10/06/">branch avoidance</a>,
no division on hot paths, and sound architecture. I also optimized for the
typical case at the cost of the atypical case. It’s a little unfair to
compare it to a program probably first written on a 16-bit machine, but
there was time for it to pick up these techniques over the decades, too.</p>

<p>Unicode support works well:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ cat π
3.14159265358979323846264338327950288419716939937510582097494
$ rexxd -i π π.c
</code></pre></div></div>

<p>Producing this source with Unicode variables:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">unsigned</span> <span class="kt">char</span> <span class="err">π</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x2e</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x31</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span> <span class="mh">0x39</span><span class="p">,</span> <span class="mh">0x32</span><span class="p">,</span> <span class="mh">0x36</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span> <span class="mh">0x33</span><span class="p">,</span> <span class="mh">0x35</span><span class="p">,</span>
  <span class="c1">// ...</span>
  <span class="mh">0x34</span><span class="p">,</span> <span class="mh">0x0a</span>
<span class="p">};</span>
<span class="kt">unsigned</span> <span class="kt">int</span> <span class="err">π</span><span class="n">_len</span> <span class="o">=</span> <span class="mi">62</span><span class="p">;</span>
</code></pre></div></div>

<p>Whereas the original xxd on Windows has the <a href="/blog/2021/12/30/">usual CRT problems</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ orig-xxd -i π
orig-xxd: p: No such file or directory
</code></pre></div></div>

<p>It also struggles with 64-bit offsets, particularly on 32-bit hosts and
LLP64 hosts like Windows. In contrast, I designed rexxd to robustly
process file offsets as 64-bit on all hosts. Its tests operate on a
virtual file system with virtual files at those sizes, so those paths
really have been tested, too.</p>

<p>The original xxd only uses static allocation, which places small range
limits on the configuration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ orig-xxd -c 1000
orig-xxd: invalid number of columns (max. 256).
</code></pre></div></div>

<p>In rexxd everything is <a href="/blog/2023/09/27/">arena allocated</a> of course, and options are
limited only by the available memory, so the above, and more, would work.
The arena helps make the SWAR tricks possible, too, providing a fast
runway to load more data at a time.</p>

<p>While reverse engineering the original, I documented bugs I discovered and
noted them with a <code class="language-plaintext highlighter-rouge">BUG:</code> comment if you wanted to see more. I’m not aiming
for bug compatibility, so these are not present in rexxd.</p>

<h3 id="platform-layer">Platform layer</h3>

<p>The <a href="https://manpages.debian.org/bookworm/xxd/xxd.1.en.html">xxd man page</a> suggests using strace to examine the execution of
<code class="language-plaintext highlighter-rouge">-r</code> reverse. That is, to monitor the seeks and writes of a binary patch
in order to debug it. That’s so insightful that I decided to build that as
a new <code class="language-plaintext highlighter-rouge">-x</code> option (think <code class="language-plaintext highlighter-rouge">sh -x</code>). That is, <em>rexxd has a built-in strace
on all platforms!</em> The trace is expressed in terms of unix system calls,
even on Windows:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ printf '00:41 \n02:42 \n04:43' | rexxd -x -r - data.bin
open("data.bin", O_CREAT|O_WRONLY, 0666) = 1
read(0, ..., 4096) = 19
write(1, "A", 1) = 1
lseek(1, 2, SEEK_SET) = 2
read(0, ..., 4096) = 0
write(1, "B", 1) = 1
lseek(1, 4, SEEK_SET) = 4
write(1, "C", 1) = 1
exit(0) = ?
</code></pre></div></div>

<p>Is this doing some kind of self-<a href="/blog/2018/06/23/">ptrace</a> debugger voodoo? Nope. Like
<a href="/blog/2023/01/18/">u-config</a>, it has a <em>platform layer</em>, and it simply logs the platform
layer calls — except for the trace printout itself of course. While the
intention is to debug binary patches, it was also quite insightful in
examining rexxd itself. It helped me spot that rexxd flushed more often
than strictly necessary.</p>

<p>To port rexxd to any system, define <code class="language-plaintext highlighter-rouge">Plt</code> as needed, implement these five
<code class="language-plaintext highlighter-rouge">plt_</code> functions, then call <code class="language-plaintext highlighter-rouge">xxd</code>. The five functions mostly have the
expected unix-like semantics:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Plt</span> <span class="n">Plt</span><span class="p">;</span>
<span class="n">b32</span>  <span class="nf">plt_open</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="p">,</span> <span class="n">i32</span> <span class="n">fd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">b32</span> <span class="n">trunc</span><span class="p">,</span> <span class="n">Arena</span> <span class="o">*</span><span class="p">);</span>
<span class="n">i64</span>  <span class="nf">plt_seek</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="p">,</span> <span class="n">i32</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i64</span> <span class="n">off</span><span class="p">,</span> <span class="n">i32</span> <span class="n">whence</span><span class="p">);</span>
<span class="n">i32</span>  <span class="nf">plt_read</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">i32</span> <span class="n">len</span><span class="p">);</span>
<span class="n">b32</span>  <span class="nf">plt_write</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="p">,</span> <span class="n">i32</span> <span class="n">fd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">i32</span> <span class="n">len</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">plt_exit</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="p">,</span> <span class="n">i32</span><span class="p">);</span>
<span class="n">i32</span>  <span class="nf">xxd</span><span class="p">(</span><span class="n">i32</span> <span class="n">argc</span><span class="p">,</span> <span class="n">u8</span> <span class="o">**</span><span class="n">argv</span><span class="p">,</span> <span class="n">Plt</span> <span class="o">*</span><span class="p">,</span> <span class="n">byte</span> <span class="o">*</span><span class="n">heap</span><span class="p">,</span> <span class="n">iz</span> <span class="n">heapsize</span><span class="p">);</span>
</code></pre></div></div>

<p>If the platform wants these functions to be “virtual” then it can put
function pointers in the <code class="language-plaintext highlighter-rouge">Plt</code> struct. Otherwise it stores anything it
might need in <code class="language-plaintext highlighter-rouge">Plt</code>. Global variables are never necessary. The application
layer doesn’t use the standard library except (indirectly) <code class="language-plaintext highlighter-rouge">memset</code> and
<code class="language-plaintext highlighter-rouge">memcpy</code>, and it allocates everything it uses from the provided <code class="language-plaintext highlighter-rouge">heap</code>
parameter.</p>

<p><code class="language-plaintext highlighter-rouge">plt_open</code> is a little unusual in that it picks the file descriptor: 0 to
replace standard input, or 1 to replace standard output. All platforms
currently use a virtual file descriptor table, and these do not map onto
the real process file descriptors. But they could! Calls are straced in
the application layer, so they log virtual file descriptors as seen by
rexxd. The arena parameter offers scratch space for the Windows platform
layer to convert paths from narrow to wide for <code class="language-plaintext highlighter-rouge">CreateFileW</code>, so it can
handle <a href="https://learn.microsoft.com/en-us/windows/win32/fileio/maximum-file-path-limitation">long path names</a> with ease.</p>

<p><code class="language-plaintext highlighter-rouge">plt_read</code> doesn’t accept a file descriptor because there’s only one from
which to read, 0. <code class="language-plaintext highlighter-rouge">plt_write</code> on the other hand allows writing to standard
error, 2.</p>

<p><code class="language-plaintext highlighter-rouge">plt_exit</code> doesn’t return, of course. In tests it <a href="/blog/2023/02/12/">longjmps</a> back
to the top level, as though returning from <code class="language-plaintext highlighter-rouge">xxd</code> with a status. This lets
me skip allocation null pointer checks, with OOM unwinding safely back to
the top level. Since rexxd allocates everything from the arena, it’s all
automatically deallocated, so it’s a clean exit.</p>

<p>On Windows, <code class="language-plaintext highlighter-rouge">plt_seek</code> calls <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-setfilepointerex"><code class="language-plaintext highlighter-rouge">SetFilePointerEx</code></a>. I learned the
hard way that the behavior of calling it on a non-file is undefined, not
an error, so at least one <code class="language-plaintext highlighter-rouge">GetFileType</code> call is mandatory. I also learned
that Windows will successfully seek all the way to <code class="language-plaintext highlighter-rouge">INT64_MAX</code>. If the
file system doesn’t support that offset, it’s a write failure <em>later</em>. For
correct operation, rexxd must take care not to overflow its own internal
file position tracking near these offsets with Windows allowing seeks to
operate at the edge until the first flush. Tests run on a virtual file
system thanks to the platform layer, and some tests permit huge seeks and
simulate impossibly enormous files in order to probe behavior at the
extremes.</p>

<p>This is in contrast to Linux, where seeks beyond the underlying file
system’s supported file size is a seek error. For example, on ext4 with
the default configuration:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo ffffffff000: 00 | rexxd -x -r - somefile
open("somefile", O_CREAT|O_WRONLY, 0666) = 1
read(0, ..., 4096) = 16
lseek(1, 17592186040320, SEEK_SET) = 17592186040320
read(0, ..., 4096) = 0
write(1, "\0", 1) = -1
exit(3) = ?
</code></pre></div></div>

<p>We can see the seek succeeded then the write failed because it went one
byte beyond the file system limit. While seeking one byte further will
cause the seek to fail (22 <code class="language-plaintext highlighter-rouge">EINVAL</code>), and rexxd falls back on write until
it fills the storage and runs out of space:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ echo ffffffff001: 00 | rexxd -x -r - somefile
open("somefile", O_CREAT|O_WRONLY, 0666) = 1
read(0, ..., 4096) = 16
lseek(1, 17592186040321, SEEK_SET) = -1
write(1, "\0\0\0\0\0\0...\0\0\0\0\0\0", 4096) = 4096
write(1, "\0\0\0\0\0\0...\0\0\0\0\0\0", 4096) = 4096
...
</code></pre></div></div>

<p>Mostly for fun, I wrote a libc-free platform layer using <a href="/blog/2023/03/23/">raw Linux system
calls</a>, and it maps <em>almost</em> perfectly onto the kernel interface:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Plt</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">fds</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span> <span class="p">};</span>

<span class="n">b32</span> <span class="nf">plt_open</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="n">plt</span><span class="p">,</span> <span class="n">i32</span> <span class="n">fd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">path</span><span class="p">,</span> <span class="n">b32</span> <span class="n">trunc</span><span class="p">,</span> <span class="n">Arena</span> <span class="o">*</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">i32</span> <span class="n">mode</span> <span class="o">=</span> <span class="n">fd</span> <span class="o">?</span> <span class="n">O_CREAT</span><span class="o">|</span><span class="n">O_WRONLY</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">mode</span> <span class="o">|=</span> <span class="n">trunc</span> <span class="o">?</span> <span class="n">O_TRUNC</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">plt</span><span class="o">-&gt;</span><span class="n">fds</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span><span class="n">syscall3</span><span class="p">(</span><span class="n">SYS_open</span><span class="p">,</span> <span class="p">(</span><span class="n">uz</span><span class="p">)</span><span class="n">path</span><span class="p">,</span> <span class="n">mode</span><span class="p">,</span> <span class="mo">0666</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">plt</span><span class="o">-&gt;</span><span class="n">fds</span><span class="p">[</span><span class="n">fd</span><span class="p">]</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">i64</span> <span class="nf">plt_seek</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="n">plt</span><span class="p">,</span> <span class="n">i32</span> <span class="n">fd</span><span class="p">,</span> <span class="n">i64</span> <span class="n">off</span><span class="p">,</span> <span class="n">i32</span> <span class="n">whence</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">syscall3</span><span class="p">(</span><span class="n">SYS_lseek</span><span class="p">,</span> <span class="n">plt</span><span class="o">-&gt;</span><span class="n">fds</span><span class="p">[</span><span class="n">fd</span><span class="p">],</span> <span class="n">off</span><span class="p">,</span> <span class="n">whence</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">i32</span> <span class="nf">plt_read</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="n">plt</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">i32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span><span class="n">syscall3</span><span class="p">(</span><span class="n">SYS_read</span><span class="p">,</span> <span class="n">plt</span><span class="o">-&gt;</span><span class="n">fds</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="p">(</span><span class="n">uz</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">b32</span> <span class="nf">plt_write</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="n">plt</span><span class="p">,</span> <span class="n">i32</span> <span class="n">fd</span><span class="p">,</span> <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="n">i32</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">len</span> <span class="o">==</span> <span class="n">syscall3</span><span class="p">(</span><span class="n">SYS_write</span><span class="p">,</span> <span class="n">plt</span><span class="o">-&gt;</span><span class="n">fds</span><span class="p">[</span><span class="n">fd</span><span class="p">],</span> <span class="p">(</span><span class="n">uz</span><span class="p">)</span><span class="n">buf</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">plt_exit</span><span class="p">(</span><span class="n">Plt</span> <span class="o">*</span><span class="p">,</span> <span class="n">i32</span> <span class="n">r</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">syscall3</span><span class="p">(</span><span class="n">SYS_exit</span><span class="p">,</span> <span class="n">r</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>On Windows I use the <a href="/blog/2023/05/31/">artisanal function prototypes</a> of which I’ve
grown so fond. It’s also my first time using w64devkit’s <code class="language-plaintext highlighter-rouge">-lmemory</code> in a
serious application. I’m using <a href="/blog/2024/02/05/"><code class="language-plaintext highlighter-rouge">-lchkstk</code></a> in the “xxd as a DLL”
platform layer, too, but that one’s just a toy. In that one I use <code class="language-plaintext highlighter-rouge">alloca</code>
to allocate an arena, which is a rather novel combination, and the large
stack frame requires a stack probe. Otherwise none of rexxd requires stack
probes.</p>

<p>w64devkit’s new <code class="language-plaintext highlighter-rouge">xxd.exe</code> is delightfully tidy as viewed by <a href="/blog/2024/06/30/">peports</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ du -h xxd.exe
28.0K   xxd.exe
$ peports xxd.exe
KERNEL32.dll
        0       CreateFileW
        0       ExitProcess
        0       GetCommandLineW
        0       GetFileType
        0       GetStdHandle
        0       MultiByteToWideChar
        0       ReadFile
        0       SetFilePointerEx
        0       VirtualAlloc
        0       WideCharToMultiByte
        0       WriteFile
SHELL32.dll
        0       CommandLineToArgvW
</code></pre></div></div>

<h3 id="other-notes">Other notes</h3>

<p><a href="/blog/2023/02/13/">Buffered output</a> and buffered input is custom tailored for rexxd.
When parsing line-oriented input, like <code class="language-plaintext highlighter-rouge">-r</code>, it attempts to parse from of
a <em>view</em> of the input buffer, no copying. The view is the <a href="/blog/2025/01/19/">usual string
representation</a>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>typedef struct {
    u8 *data;
    iz  len;
} Str;
</code></pre></div></div>

<p>Does it fail if the line is longer than the buffer? If it straddles reads,
does that hurt efficiency? The answer to both is “no” due to the spillover
arena. <code class="language-plaintext highlighter-rouge">Input</code> is the buffered input struct, and here’s the interface to
get the next line:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>Str nextline(Input *, Arena *);
</code></pre></div></div>

<p>If the line isn’t entirely contained in the input buffer, the complete
line is <a href="/blog/2024/05/25/">concatenated</a> in the arena. So it comfortably handles
huge lines while no-copy optimizing for typical short, non-straddling
lines. With a per-iteration arena, any arena-backed line is automatically
freed at the end of the iteration, so it’s all transparent:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="n">Arena</span> <span class="n">scratch</span> <span class="o">=</span> <span class="n">perm</span><span class="p">;</span>
        <span class="n">Str</span> <span class="n">line</span> <span class="o">=</span> <span class="n">nextline</span><span class="p">(</span><span class="n">b</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="p">);</span>
        <span class="c1">// ... line may point into an Input or scratch ...</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>If the line doesn’t fit in the arena, it triggers OOM handling. That is,
it calls <code class="language-plaintext highlighter-rouge">plt_exit</code> and something platform-appropriate happens without
returning. Beats the pants off <a href="https://man7.org/linux/man-pages/man3/getline.3.html">old <code class="language-plaintext highlighter-rouge">getline</code></a>!</p>

<p>I came up with a <code class="language-plaintext highlighter-rouge">maxof</code> macro that evaluates the maximum of any integral
type, signed or unsigned. It appears in <a href="/blog/2024/05/24/">overflow checks</a> and more,
I really like how it turned out. For example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">if</span> <span class="p">(</span><span class="n">pos</span> <span class="o">&gt;</span> <span class="n">maxof</span><span class="p">(</span><span class="n">i64</span><span class="p">)</span> <span class="o">-</span> <span class="n">off</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// overflow</span>
    <span class="p">}</span>
    <span class="n">pos</span> <span class="o">+=</span> <span class="n">off</span><span class="p">;</span>
</code></pre></div></div>

<p>Or:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">i32</span> <span class="nf">trunc32</span><span class="p">(</span><span class="n">iz</span> <span class="n">n</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">n</span><span class="o">&gt;</span><span class="n">maxof</span><span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="o">?</span> <span class="n">maxof</span><span class="p">(</span><span class="n">i32</span><span class="p">)</span> <span class="o">:</span> <span class="p">(</span><span class="n">i32</span><span class="p">)</span><span class="n">n</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that I have <code class="language-plaintext highlighter-rouge">-lmemory</code> and generally solved string function issues for
myself, I leaned into <code class="language-plaintext highlighter-rouge">__builtin_memset</code> and <code class="language-plaintext highlighter-rouge">__builtin_memcpy</code> for this
project. Despite <code class="language-plaintext highlighter-rouge">restrict</code>, it’s surprisingly difficult to get compilers
to optimize loops into semantically equivalent string function calls. An
explicit built-in solves that. It also produces faster debug builds, which
is what I run while I work. At <code class="language-plaintext highlighter-rouge">-O0</code>, rexxd is about half the speed of a
release build.</p>

<p>Other than <code class="language-plaintext highlighter-rouge">-x</code>, I don’t plan on inventing new features. I’d like to
maintain compatibility with the <code class="language-plaintext highlighter-rouge">xxd</code> found everywhere else, and I don’t
expect adoption beyond w64devkit. Overall the project took about twice as
long as I anticipated — two weekends instead of one — but it turned out
better than I expected and I’m very pleased with the results.</p>


    