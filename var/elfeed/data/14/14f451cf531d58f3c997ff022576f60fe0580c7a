
<p>Hi nerds, I'm back from <a href="https://systemsdistributed.com/" target="_blank">Systems Distributed</a>! I'd heartily recommend it, wildest conference I've been to in years. I have a lot of work to catch up on, so this will be a short newsletter.</p>
<p>In an earlier version of my talk, I had a gag about unit tests. First I showed the test <code>f([1,2,3]) == 3</code>, then said that this was satisfied by <code>f(l) = 3</code>, <code>f(l) = l[-1]</code>, <code>f(l) = len(l)</code>, <code>f(l) = (129*l[0]-34*l[1]-617)*l[2] - 443*l[0] + 1148*l[1] - 182</code>. Then I progressively rule them out one by one with more unit tests, except the last polynomial which stubbornly passes every single test.</p>
<p>If you're given some function of <code>f(x: int, y: int, â€¦): int</code> and a set of unit tests asserting <a href="https://buttondown.com/hillelwayne/archive/oracle-testing/" target="_blank">specific inputs give specific outputs</a>, then you can find a polynomial that passes every single unit test.</p>
<p>To find the gag, and as <a href="https://en.wikipedia.org/wiki/Satisfiability_modulo_theories" target="_blank">SMT</a> practice, I wrote a Python program that finds a polynomial that passes a test suite meant for <code>max</code>. It's hardcoded for three parameters and only finds 2nd-order polynomials but I think it could be generalized with enough effort.</p>
<h2>The code</h2>
<p>Full code <a href="https://gist.github.com/hwayne/0ed045a35376c786171f9cf4b55c470f" target="_blank">here</a>, breakdown below.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">from</span><span class="w"> </span><span class="nn">z3</span><span class="w"> </span><span class="kn">import</span> <span class="o">*</span>  <span class="c1"># type: ignore</span>
<span class="n">s1</span><span class="p">,</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">Solver</span><span class="p">(),</span> <span class="n">Solver</span><span class="p">()</span>
</code></pre></div>
<p><a href="https://microsoft.github.io/z3guide/" target="_blank">Z3</a> is just the particular SMT solver we use, as it has good language bindings and a lot of affordances.</p>
<p>As part of learning SMT I wanted to do this two ways. First by putting the polynomial "outside" of the SMT solver in a python function, second by doing it "natively" in Z3. I created two solvers so I could test both versions in one run. </p>
<div class="codehilite"><pre><span></span><code><span class="n">a0</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Consts</span><span class="p">(</span><span class="s1">'a0 a b c d e f'</span><span class="p">,</span> <span class="n">IntSort</span><span class="p">())</span>
<span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Ints</span><span class="p">(</span><span class="s1">'x y z'</span><span class="p">)</span>
<span class="n">t</span> <span class="o">=</span> <span class="s2">"a*x+b*y+c*z+d*x*y+e*x*z+f*y*z+a0"</span>
</code></pre></div>
<p>Both <code>Const('x', IntSort())</code> and <code>Int('x')</code> do the exact same thing, the latter being syntactic sugar for the former. I did not know this when I wrote the program. </p>
<p>To keep the two versions in sync I represented the equation as a string, which I later <code>eval</code>. This is one of the rare cases where eval is a good idea, to help us experiment more quickly while learning. The polynomial is a "2nd-order polynomial", even though it doesn't have <code>x^2</code> terms, as it has <code>xy</code> and <code>xz</code> terms.</p>
<div class="codehilite"><pre><span></span><code><span class="n">lambdamax</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">:</span> <span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">)</span>

<span class="n">z3max</span> <span class="o">=</span> <span class="n">Function</span><span class="p">(</span><span class="s1">'z3max'</span><span class="p">,</span> <span class="n">IntSort</span><span class="p">(),</span> <span class="n">IntSort</span><span class="p">(),</span> <span class="n">IntSort</span><span class="p">(),</span>  <span class="n">IntSort</span><span class="p">())</span>
<span class="n">s1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">ForAll</span><span class="p">([</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">],</span> <span class="n">z3max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)</span> <span class="o">==</span> <span class="nb">eval</span><span class="p">(</span><span class="n">t</span><span class="p">)))</span>
</code></pre></div>
<p><code>lambdamax</code> is pretty straightforward: create a lambda with three parameters and <code>eval</code> the string. The string "<code>a*x</code>" then becomes the python expression <code>a*x</code>, <code>a</code> is an SMT symbol, while the <code>x</code> SMT symbol is shadowed by the lambda parameter. To reiterate, a terrible idea in practice, but a good way to learn faster.</p>
<p><code>z3max</code> function is a little more complex. <code>Function</code> takes an identifier string and N "sorts" (roughly the same as programming types). The first <code>N-1</code> sorts define the parameters of the function, while the last becomes the output. So here I assign the string identifier <code>"z3max"</code> to be a function with signature <code>(int, int, int) -&gt; int</code>.</p>
<p>I can load the function into the model by specifying constraints on what <code>z3max</code> <em>could</em> be. This could either be a strict input/output, as will be done later, or a <code>ForAll</code> over all possible inputs. Here I just use that directly to say "for all inputs, the function should match this polynomial." But I could do more complicated constraints, like commutativity (<code>f(x, y) == f(y, x)</code>) or monotonicity (<code>Implies(x &lt; y, f(x) &lt;= f(y))</code>).</p>
<p>Note <code>ForAll</code> takes a list of z3 symbols to quantify over. That's the only reason we need to define <code>x, y, z</code> in the first place. The lambda version doesn't need them. </p>
<div class="codehilite"><pre><span></span><code><span class="n">inputs</span> <span class="o">=</span> <span class="p">[(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">),</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">)]</span>

<span class="k">for</span> <span class="n">g</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
    <span class="n">s1</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">z3max</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">))</span>
    <span class="n">s2</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">lambdamax</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">)</span> <span class="o">==</span> <span class="nb">max</span><span class="p">(</span><span class="o">*</span><span class="n">g</span><span class="p">))</span>
</code></pre></div>
<p>This sets up the joke: adding constraints to each solver that the polynomial it finds must, for a fixed list of triplets, return the max of each triplet.</p>
<div class="codehilite"><pre><span></span><code><span class="k">for</span> <span class="n">s</span><span class="p">,</span> <span class="n">func</span> <span class="ow">in</span> <span class="p">[(</span><span class="n">s1</span><span class="p">,</span> <span class="n">z3max</span><span class="p">),</span> <span class="p">(</span><span class="n">s2</span><span class="p">,</span> <span class="n">lambdamax</span><span class="p">)]:</span>
    <span class="k">if</span> <span class="n">s</span><span class="o">.</span><span class="n">check</span><span class="p">()</span> <span class="o">==</span> <span class="n">sat</span><span class="p">:</span>
        <span class="n">m</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">model</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span> <span class="ow">in</span> <span class="n">inputs</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"max([</span><span class="si">{</span><span class="n">x</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">y</span><span class="si">}</span><span class="s2">, </span><span class="si">{</span><span class="n">z</span><span class="si">}</span><span class="s2">]) ="</span><span class="p">,</span> <span class="n">m</span><span class="o">.</span><span class="n">evaluate</span><span class="p">(</span><span class="n">func</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">)))</span>
        <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s2">"max([x, y, z]) = </span><span class="si">{</span><span class="n">m</span><span class="p">[</span><span class="n">a</span><span class="p">]</span><span class="si">}</span><span class="s2">x + </span><span class="si">{</span><span class="n">m</span><span class="p">[</span><span class="n">b</span><span class="p">]</span><span class="si">}</span><span class="s2">y"</span><span class="p">,</span>
            <span class="sa">f</span><span class="s2">"+ </span><span class="si">{</span><span class="n">m</span><span class="p">[</span><span class="n">c</span><span class="p">]</span><span class="si">}</span><span class="s2">z +"</span><span class="p">,</span> <span class="c1"># linebreaks added for newsletter rendering</span>
            <span class="sa">f</span><span class="s2">"</span><span class="si">{</span><span class="n">m</span><span class="p">[</span><span class="n">d</span><span class="p">]</span><span class="si">}</span><span class="s2">xy + </span><span class="si">{</span><span class="n">m</span><span class="p">[</span><span class="n">e</span><span class="p">]</span><span class="si">}</span><span class="s2">xz + </span><span class="si">{</span><span class="n">m</span><span class="p">[</span><span class="n">f</span><span class="p">]</span><span class="si">}</span><span class="s2">yz + </span><span class="si">{</span><span class="n">m</span><span class="p">[</span><span class="n">a0</span><span class="p">]</span><span class="si">}</span><span class="se">\n</span><span class="s2">"</span><span class="p">)</span>
</code></pre></div>
<p>Output:</p>
<div class="codehilite"><pre><span></span><code>max([1, 2, 3]) = 3
# etc
max([x, y, z]) = -133x + 130y + -10z + -2xy + 62xz + -46yz + 0

max([1, 2, 3]) = 3
# etc
max([x, y, z]) = -17x + 16y + 0z + 0xy + 8xz + -6yz + 0
</code></pre></div>
<p>I find that <code>z3max</code> (top) consistently finds larger coefficients than <code>lambdamax</code> does. I don't know why.</p>
<h3>Practical Applications</h3>
<p><strong>Test-Driven Development</strong> recommends a strict "red-green refactor" cycle. Write a new failing test, make the new test pass, then go back and refactor. Well, the easiest way to make the new test pass would be to paste in a new polynomial, so that's what you should be doing. You can even do this all automatically: have a script read the set of test cases, pass them to the solver, and write the new polynomial to your code file. All you need to do is write the tests!</p>
<h3>Pedagogical Notes</h3>
<p>Writing the script took me a couple of hours. I'm sure an LLM could have whipped it all up in five minutes but I really want to <em>learn</em> SMT and <a href="https://www.sciencedirect.com/science/article/pii/S0747563224002541" target="_blank">LLMs <em>may</em> decrease learning retention</a>.<sup id="fnref:caveat"><a class="footnote-ref" href="#fn:caveat">1</a></sup> Z3 documentation is not... great for non-academics, though, and most other SMT solvers have even worse docs. One useful trick I use regularly is to use Github code search to find code using the same APIs and study how that works. Turns out reading API-heavy code is a lot easier than writing it!</p>
<p>Anyway, I'm very, very slowly feeling like I'm getting the basics on how to use SMT. I don't have any practical use cases yet, but I wanted to learn this skill for a while and glad I finally did.</p>
<div class="footnote">
<hr/>
<ol>
<li id="fn:caveat">
<p>Caveat I have not actually <em>read</em> the study, for all I know it could have a sample size of three people, I'll get around to it eventuallyÂ <a class="footnote-backref" href="#fnref:caveat" title="Jump back to footnote 1 in the text">â†©</a></p>
</li>
</ol>
</div>
