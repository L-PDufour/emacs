<html><head></head><body><p><em>Note: This article series was written by me, with LLMs helping to refine the style and structure.</em></p>
<p>This is the final article in my series on working with LLMs at scale. <a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part1-pain-points">Part 1</a> through <a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part4-experiments">Part 4</a> focused on <em>building</em> with LLMs—managing sessions, ensuring quality, coordinating parallel work.</p>
<p>This article explores a different theme: <strong>the place of learning in the era of LLMs</strong>.</p>
<p><strong>Series Navigation:</strong> <a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part4-experiments">← Part 4: Rapid Evolution</a></p>
<h2>
  The Learning Paradox
  <a href="#the-learning-paradox">
    <i></i>
  </a>
</h2>
<p>Here’s the uncomfortable truth: to be effective with LLMs today, you need to know the craft. When using Claude to write code, I rely on decades of software engineering experience—I know what good code looks like, what patterns to avoid, what trade-offs matter.</p>
<p>But people training today don’t have the same need to learn that I did. Why spend years mastering the intricacies of memory management, algorithmic complexity, or API design when an LLM can handle most of it?</p>
<p>This creates a void in expertise. If fewer people develop deep craft knowledge because LLMs handle the implementation details, where does the next generation of experts come from? The ones who can steer the LLMs, evaluate their output, and make good architectural decisions?</p>
<p>It’s likely a temporary problem. There’s no reason to think that I myself—and my ways of thinking—cannot eventually be replaced by LLMs. The “steering” and “judgment” I provide today may be automated tomorrow.</p>
<p>But for now, we’re in this transition. And I still value learning deeply. It’s been a core motivation for me throughout my career.</p>
<p>So here’s how I use LLMs to accelerate my own learning, working with my fallible human brain that still needs repetition, reinforcement, and deliberate practice to internalize complex ideas.</p>
<h2>
  Prompting as a Learned Skill
  <a href="#prompting-as-a-learned-skill">
    <i></i>
  </a>
</h2>
<p>I’ve had over 2,000 conversations with AI. I’m still learning how to prompt better. It’s a skill, and one I recommend others invest in.</p>
<p>Good prompts aren’t just about getting answers—they’re about shaping the learning experience to match how you learn best. Here are some examples from my own learning journey.</p>
<h3>
  Example 1: Catching Up on React
  <a href="#example-1-catching-up-on-react">
    <i></i>
  </a>
</h3>
<p>I used React when it first started, but it’s changed dramatically. Instead of asking “explain React hooks,” I framed it as a structured learning path:</p>
<pre><code>I used React at the beginning when it started but now it has changed a lot.
Do you think you can help me be up to speed with all the concepts in a few
bite-size lectures with example code?

I am interested to cover at least: hooks, effects, callbacks, routing,
state management, async operations, axios, reusable components, performance,
and the history of the framework.
</code></pre><p>Key elements of this prompt:</p>
<ul>
<li><strong>Context</strong>: I’m not a beginner, I’m catching up</li>
<li><strong>Format</strong>: Bite-size lectures with code</li>
<li><strong>Scope</strong>: Specific topics I need to cover</li>
<li><strong>Goal</strong>: Get up to speed, not comprehensive mastery</li>
</ul>
<p>This gave me a structured curriculum tailored to my experience level.</p>
<h3>
  Example 2: Understanding Anthropic
  <a href="#example-2-understanding-anthropic">
    <i></i>
  </a>
</h3>
<p>When I wanted to learn about Anthropic as a company, I didn’t ask for a Wikipedia-style overview. I asked for serialized, digestible stories:</p>
<pre><code>I want you to give me bite-size stories about Anthropic, the AI company.
The stories have to come in chronological order, one at a time (wait for me
to say continue). They have to be few paragraphs long to cater to the low
attention span of human beings in the 21st century.

Cover: the origin of the company, the founders, key people, Claude, ethics,
Sonnet and Opus, Claude Code, etc. Aim for 10 stories total for now.
</code></pre><p>Key elements:</p>
<ul>
<li><strong>Format</strong>: Serialized stories, not a wall of text</li>
<li><strong>Pacing</strong>: One at a time, controlled by me</li>
<li><strong>Tone</strong>: Acknowledges modern attention spans</li>
<li><strong>Coverage</strong>: Specific topics I care about</li>
<li><strong>Scope</strong>: 10 stories sets expectations</li>
</ul>
<p>This turned learning into an interactive experience rather than passive reading.</p>
<h2>
  Pattern 1: Heavily-Annotated Code (Worksheets)
  <a href="#pattern-1-heavily-annotated-code-worksheets">
    <i></i>
  </a>
</h2>
<p>When learning a new codebase or pattern, I ask Claude to generate <strong>worksheets</strong>—code with extensive inline comments explaining every decision.</p>
<p>This works because code with explanations serves as a learning artifact you can read, annotate, and reference later. The key is being specific about what you want explained:</p>
<pre><code>Generate [concept] code with inline comments explaining:
- Why this approach (vs alternatives)
- Common mistakes
- Performance considerations
- When to use / not use
- How it connects to [related concept]
</code></pre><p>I’ve used this pattern to learn:</p>
<ul>
<li>Rust’s ownership system</li>
<li>Clojure’s transducers</li>
<li>Kubernetes operators</li>
<li>Distributed system patterns</li>
<li>Database indexing strategies</li>
</ul>
<h2>
  Pattern 2: Flashcards for Spaced Repetition
  <a href="#pattern-2-flashcards-for-spaced-repetition">
    <i></i>
  </a>
</h2>
<p>Reading annotated code helps understanding, but doesn’t ensure <em>retention</em>. For that, I use <strong>flashcards</strong> with spaced repetition.</p>
<h3>
  The Flashcard System
  <a href="#the-flashcard-system">
    <i></i>
  </a>
</h3>
<p>I built a flashcard CLI that implements spaced repetition algorithms (SM-2, Leitner boxes).</p>
<p>But manually creating flashcards is tedious. So I ask Claude to generate them.</p>
<h3>
  Example: Learning System Design
  <a href="#example-learning-system-design">
    <i></i>
  </a>
</h3>
<pre><code>Generate flashcards for distributed systems concepts. Format as JSON.
Focus on: CAP theorem, consensus algorithms, partitioning strategies.

Each card should have:
- A precise question
- A complete answer
- Tags for organization
- Notes with additional context
</code></pre><p>Claude generates:</p>
<div class="highlight"><pre><code class="language-json"><span><span>[
</span></span><span><span>  {
</span></span><span><span>    <span>"question"</span>: <span>"In the CAP theorem, what does 'Partition Tolerance' actually mean?"</span>,
</span></span><span><span>    <span>"answer"</span>: <span>"The system continues to operate despite network partitions (messages between nodes being lost or delayed). You must choose: consistency (all nodes see same data) or availability (all requests get responses) during a partition."</span>,
</span></span><span><span>    <span>"tags"</span>: [<span>"cap-theorem"</span>, <span>"distributed-systems"</span>, <span>"fundamentals"</span>],
</span></span><span><span>    <span>"notes"</span>: <span>"Common misconception: You can't 'give up' partition tolerance—network partitions will happen. You choose between CP (consistent but not available during partition) or AP (available but inconsistent during partition)."</span>
</span></span><span><span>  },
</span></span><span><span>  {
</span></span><span><span>    <span>"question"</span>: <span>"What is the key difference between Raft and Paxos consensus algorithms?"</span>,
</span></span><span><span>    <span>"answer"</span>: <span>"Raft uses leader election + log replication (simpler to understand). Paxos uses proposal numbers + acceptors (more flexible but complex). Raft is easier to implement correctly."</span>,
</span></span><span><span>    <span>"tags"</span>: [<span>"consensus"</span>, <span>"raft"</span>, <span>"paxos"</span>, <span>"algorithms"</span>],
</span></span><span><span>    <span>"notes"</span>: <span>"Raft was explicitly designed to be more understandable than Paxos. In practice, most systems use Raft (etcd, Consul) or Raft-like algorithms (Zab in ZooKeeper)."</span>
</span></span><span><span>  },
</span></span><span><span>  {
</span></span><span><span>    <span>"question"</span>: <span>"When should you use hash-based partitioning vs range-based partitioning?"</span>,
</span></span><span><span>    <span>"answer"</span>: <span>"Hash partitioning: Uniform distribution, good for random access. Range partitioning: Preserves ordering, good for range queries. Choose based on your query patterns."</span>,
</span></span><span><span>    <span>"tags"</span>: [<span>"partitioning"</span>, <span>"sharding"</span>, <span>"database"</span>],
</span></span><span><span>    <span>"notes"</span>: <span>"Real example: User IDs → hash partition (uniform load). Timestamps → range partition (range queries like 'last 24 hours'). Hybrid approaches exist (compound keys)."</span>
</span></span><span><span>  }
</span></span><span><span>]
</span></span></code></pre></div><p>I import these directly into my flashcard system:</p>
<div class="highlight"><pre><code class="language-bash"><span><span>cat system_design_cards.json | ./flashcards bulk-create --project system-design
</span></span></code></pre></div><p>Now I can quiz myself:</p>
<div class="highlight"><pre><code class="language-bash"><span><span>$ ./flashcards quiz --project system-design --limit <span>5</span>
</span></span><span><span>
</span></span><span><span>Question 1/5: In the CAP theorem, what does <span>'Partition Tolerance'</span> actually mean?
</span></span><span><span>
</span></span><span><span><span>[</span>Show answer? y/n<span>]</span>
</span></span></code></pre></div><h3>
  The Spaced Repetition Loop
  <a href="#the-spaced-repetition-loop">
    <i></i>
  </a>
</h3>
<p>Here’s how the system works:</p>
<ol>
<li><strong>Generate flashcards</strong> from concept (Claude)</li>
<li><strong>Import into flashcard CLI</strong></li>
<li><strong>Quiz yourself</strong> (spaced repetition schedules reviews)</li>
<li><strong>Rate confidence</strong> (1-5): Low = see again soon, High = see much later</li>
<li><strong>Repeat</strong> over days/weeks until internalized</li>
</ol>
<p>The beauty: I can generate flashcards for <em>any</em> technical topic in minutes. No manual card creation. No finding existing decks that don’t quite match my needs.</p>
<h2>
  The Meta-Pattern: AI as a Learning Compiler
  <a href="#the-meta-pattern-ai-as-a-learning-compiler">
    <i></i>
  </a>
</h2>
<p>These patterns share a common insight:</p>
<p><strong>LLMs can transform any learning goal into a personalized learning artifact.</strong></p>
<p>You provide a concept to learn, your preferred style (flashcards, annotated code), and your knowledge gaps. Claude generates materials tailored to you—at the right complexity, in the format you learn best from.</p>
<h2>
  Practical Workflow
  <a href="#practical-workflow">
    <i></i>
  </a>
</h2>
<p>My typical learning workflow:</p>
<ol>
<li><strong>Generate annotated code</strong>: Complete implementation with explanatory comments</li>
<li><strong>Extract flashcards</strong>: Key concepts become cards for spaced repetition</li>
<li><strong>Quiz over time</strong>: Spaced repetition embeds knowledge long-term</li>
</ol>
<p>This takes 30-60 minutes to generate materials, then ongoing review. Traditional learning (reading papers, watching videos, manual note-taking) would take hours or days to achieve the same depth.</p>
<h2>
  The Flashcard System Details
  <a href="#the-flashcard-system-details">
    <i></i>
  </a>
</h2>
<p>Since I mentioned my flashcard system, here’s how it works:</p>
<p><strong>Features:</strong></p>
<ul>
<li>Multiple spaced repetition algorithms (SM-2, Leitner, fixed intervals)</li>
<li>Project organization (tag by topic)</li>
<li>Adaptive quiz sessions (repeat failed items immediately)</li>
<li>JSON import/export (easy to generate with LLMs)</li>
<li>CLI for terminal-based studying</li>
</ul>
<p><strong>Usage:</strong></p>
<div class="highlight"><pre><code class="language-bash"><span><span><span># Create from Claude-generated JSON</span>
</span></span><span><span>flashcards bulk-create --file cards.json --project rust
</span></span><span><span>
</span></span><span><span><span># Start adaptive quiz session</span>
</span></span><span><span>flashcards quiz --project rust --limit <span>10</span>
</span></span><span><span>
</span></span><span><span><span># Review a specific card</span>
</span></span><span><span>flashcards review &lt;id&gt; --confidence <span>4</span>
</span></span><span><span>
</span></span><span><span><span># See statistics</span>
</span></span><span><span>flashcards stats --project rust
</span></span></code></pre></div><p>The adaptive sessions are key: if you get a card wrong (confidence &lt; 3), it immediately re-queues it. You practice until you get it right, then spaced repetition takes over for long-term retention.</p>
<h2>
  Key Learnings
  <a href="#key-learnings">
    <i></i>
  </a>
</h2>
<p>After a year of using LLMs for learning:</p>
<p><strong>Annotated code beats plain code.</strong> The “why” matters more than the “what.”</p>
<p><strong>Flashcards with spaced repetition work.</strong> Generate hundreds of cards in minutes, internalize them over weeks.</p>
<p><strong>Active learning beats passive.</strong> Quizzing yourself is more effective than rereading notes.</p>
<h2>
  Conclusion: Beyond Code Generation
  <a href="#conclusion-beyond-code-generation">
    <i></i>
  </a>
</h2>
<p>This series has been about working with LLMs at scale—managing multiple sessions, ensuring quality, building coordination patterns. But it’s also been about a fundamental shift in how we work with code and knowledge.</p>
<p>LLMs aren’t just code generators. They’re:</p>
<ul>
<li>Productivity multipliers (Part 2)</li>
<li>Quality enforcers (Part 3)</li>
<li>Coordination layers (Part 3)</li>
<li>Learning accelerators (Part 5)</li>
</ul>
<p>The developers who thrive in this new world won’t be the ones who use LLMs as fancy autocomplete. They’ll be the ones who build workflows, tooling, and patterns that let them work at 10x their previous speed while maintaining quality and continuously learning.</p>
<p>My system—tmux integration, telemetry, memento, smoke tests, code review workflows, flashcards—is just one approach. Yours will look different based on your needs, your style, your projects.</p>
<p>But the core principles apply:</p>
<ul>
<li>Make the invisible visible (ergonomics, telemetry)</li>
<li>Enforce quality automatically (smoke tests)</li>
<li>Share context between sessions (memento)</li>
<li>Learn continuously (flashcards, annotated code)</li>
</ul>
<p>The future of software development is human-AI collaboration. Not humans being replaced, but humans being amplified. The question isn’t whether to use LLMs—it’s how to use them most effectively.</p>
<p>I hope this series has given you ideas, tools, and patterns you can adapt to your own workflow.</p>
<p>Now go build something amazing.</p>
<hr>
<p><em>If you’re interested in any of the tools or patterns mentioned in this series, feel free to reach out. I’m happy to discuss what you find compelling and share more details.</em></p>
</body></html>