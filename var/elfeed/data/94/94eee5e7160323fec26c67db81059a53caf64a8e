<div><img width="300" height="128" src="https://blog.sigplan.org/wp-content/uploads/2025/01/decidable-wide-1-300x128.png" class="attachment-medium size-medium wp-post-image" alt="" style="margin-bottom:15px;margin-left:15px;float:right;" decoding="async" loading="lazy" /></div><p>Recursive types, generics (sometimes called parametric polymorphism), and subtyping are all essential features for modern programming languages across numerous paradigms. Whereas recursive types describe unbounded data structures, generics are used to define parametrized data structures by abstracting from the concrete types on which they operate. Subtyping provides flexibility by enabling a more specific data type to be treated as its more general supertype, promoting code reuse. Structural subtyping is especially flexible and expressive.</p>
<p>The combination of these features is present to varying degrees in many of today’s widely used languages, such as Scala, Go, Rust, TypeScript, and Java, but this combination is difficult to manage. In particular, structural subtyping is <em>undecidable</em> in the presence of recursive types and generics. To overcome this difficulty, various restrictions on types’ structure have been proposed. We contend that these restrictions can be too limiting or unintuitive in practice.</p>
<p>In <a href="https://doi.org/10.1145/3632932">our POPL 2024 paper</a> and its accompanying <a href="https://bitbucket.org/structural-types/polyte">implementation</a>, we propose a reconstruction of the interaction between recursive types, generics, and structural subtyping from first principles. We present a notion of parametricity for type constructors that forms the basis of a suitable, <em>decidable</em> fragment of structural subtyping, which we call <em>parametric subtyping</em>.</p>
<p>Parametric subtyping establishes that a pair of type constructors t[α<sub>1</sub>,…,α<sub>n</sub>] and u[β<sub>1</sub>,…,β<sub>m</sub>] is considered parametric if the subtyping problem t[α<sub>1</sub>,…,α<sub>n</sub>] ⩽ u[β<sub>1</sub>,…,β<sub>m</sub>] can be reduced to (finitely many) subtyping problems among the arguments α<sub>1</sub>,…,α<sub>n</sub> and β<sub>1</sub>,…,β<sub>m</sub> alone.  In this sense, parametric subtyping constitutes a clear and simple declarative characterization of subtyping where:<br />
<img loading="lazy" decoding="async" class="aligncenter wp-image-2908" src="https://blog.sigplan.org/wp-content/uploads/2025/01/slogan-1024x98.png" alt="Related type arguments are mapped to related type results." width="512" height="49" />Parametric subtyping thus adapts <a href="https://people.mpi-sws.org/~dreyer/tor/papers/reynolds.pdf">Reynolds&#8217;s</a> characterization of parametric functions as those that <em>map related arguments to related results</em>, modifying it for parametric type constructors.</p>
<p>(For a comparison of parametric subtyping with the forms of subtyping available in Java and Scala, please see the end of this post.)</p>
<h1>A First Look at Parametric Subtyping</h1>
<p><div id="attachment_2942" style="width: 410px" class="wp-caption alignright"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-2942" class="wp-image-2942" src="https://blog.sigplan.org/wp-content/uploads/2025/01/stack-maybe-defns-1-1024x242.png" alt="" width="400" height="94" /><p id="caption-attachment-2942" class="wp-caption-text">Definitions of types stack[α] and maybe[κ]</p></div>To delve into parametric subtyping, consider an interface for stack objects, parameterized by a type α of stack elements.  A stack is an object that offers push and pop methods, where the pop method accounts for the possibility that the stack may be empty by using the auxiliary constructor maybe[κ].</p>
<p><div id="attachment_2949" style="width: 410px" class="wp-caption alignleft"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-2949" class="wp-image-2949" src="https://blog.sigplan.org/wp-content/uploads/2025/01/pushes-pops-defns-1024x244.png" alt="" width="400" height="95" /><p id="caption-attachment-2949" class="wp-caption-text">Definitions of types pushes[β] and pops[γ]</p></div>Programmers sometimes want to ensure that a stack can be used according to a particular protocol, and subtyping plays a crucial role in ensuring that stacks are compatible regardless of the particular protocol they follow. For example, when implementing a queue with a pair of stacks, the stacks should adhere to the protocol that all pushes occur before all pops. This protocol can be described by the pushes[β] and pops[γ] type constructors. Whenever the first pop from a stack of type pushes[β] occurs, the remaining stack has type pushes[β], which does not offer a push method.</p>
<p>Under the standard structural subtyping rules, there exists an infinite derivation of stack[α] ⩽ pushes[β] whenever α and β are mutual subtypes. This gives rise to an admissible subtyping rule:<br />
<img loading="lazy" decoding="async" class="aligncenter wp-image-2910 size-full" src="https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pushes.png" alt="Admissible subtyping rule: stack α &lt;: pushes β if β &lt;: α and α &lt;: β." width="1911" height="383" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pushes.png 1911w, https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pushes-1280x257.png 1280w, https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pushes-980x196.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pushes-480x96.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) and (max-width: 1280px) 1280px, (min-width: 1281px) 1911px, 100vw" />This rule is admissible in the sense that the corresponding infinite derivation of stack[α] ⩽ pushes[β] can always be inlined in its place. More importantly, this is a valid <em>parametric</em> subtyping rule because the premises involve only arguments, α and β.</p>
<p>Similarly, there exists an infinite derivation of stack[α] ⩽ pops[γ] whenever α ⩽ γ, which gives rise to an admissible subtyping rule:<br />
<img loading="lazy" decoding="async" class="aligncenter size-full wp-image-2911" src="https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pops.png" alt="Admissible subtyping rule: stack α &lt;: pops γ if α &lt;: γ." width="1911" height="383" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pops.png 1911w, https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pops-1280x257.png 1280w, https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pops-980x196.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/admissible-rule-pops-480x96.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) and (max-width: 1280px) 1280px, (min-width: 1281px) 1911px, 100vw" /></p>
<p>As an example of a subtyping rule that is <em>not</em> parametric, consider a type natstack and the rule “nat ⩽ γ implies natstack ⩽ pops[γ]”:<br />
<img loading="lazy" decoding="async" class="aligncenter wp-image-2912 size-large" src="https://blog.sigplan.org/wp-content/uploads/2025/01/non-example-1024x390.png" alt="Example of a non-parametric subtyping rule." width="1024" height="390" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/non-example-980x374.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/non-example-480x183.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" />This rule is <em>not</em> parametric because it relates a type argument, γ, to another, non-argument type, nat.</p>
<h1>Deciding Structural Subtyping for Monomorphic Types</h1>
<p>Before we delve into any more specifics of parametric subtyping, let&#8217;s revisit structural subtyping using a simpler, familiar example: even and odd natural numbers. This example operates within the realm of monomorphic types (i.e., types without type parameters), where structural subtyping is decidable. We now sketch a saturation-based decision procedure for <em>structural</em> subtyping of <em>monomorphic</em> types that will serve as a stepping stone for understanding how the decision procedure for <em>parametric</em> subtyping works in the <em>polymorphic</em> setting.</p>
<div id="attachment_2953" style="width: 285px" class="wp-caption alignright"><img loading="lazy" decoding="async" aria-describedby="caption-attachment-2953" class="wp-image-2953" src="https://blog.sigplan.org/wp-content/uploads/2025/01/nat-even-odd-defns-1024x387.png" alt="" width="275" height="104" /><p id="caption-attachment-2953" class="wp-caption-text">Definitions of types nat, even, and odd</p></div>
<p>Consider a type nat of natural numbers. Natural numbers can be built in two ways: either as zero or as the successor of another natural number. Similarly, an even number is either zero or the successor of an odd number, whereas an odd number is always the successor of an even number.</p>
<p>To prove that the types even and odd are subtypes of nat, we will use saturating <em>forward inference</em>. Intuitively, we will assume that even ⩽ nat and try to find a contradiction by inferring more and more consequences of this assumption. Once we have saturated by inferring all the facts we can, if we still have not uncovered a contradiction, then we will know that the type even is indeed a subtype of nat.</p>
<p>For this purpose, we keep a database with the assumed subtyping relations and proceed by forward inference. More specifically, we start by assuming that even ⩽ nat, expand according to definitions, invert structural subtyping rules, and conclude that the subtyping odd ⩽ nat should be further analyzed.<br />
<img loading="lazy" decoding="async" class="aligncenter size-large wp-image-2913" src="https://blog.sigplan.org/wp-content/uploads/2025/01/even-nat-1024x179.png" alt="Forward inference for even &lt;: nat, part 1." width="1024" height="179" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/even-nat-980x171.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/even-nat-480x84.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" /></p>
<p>Now we can consider odd ⩽ nat, once more expanding according to definitions and inverting structural subtyping rules. We conclude that odd ⩽ nat holds only if even ⩽ nat holds. However, this new instance of even ⩽ nat is subsumed by the one that already exists in the database:<br />
<img loading="lazy" decoding="async" class="aligncenter size-large wp-image-2914" src="https://blog.sigplan.org/wp-content/uploads/2025/01/odd-nat-1024x179.png" alt="Forward inference for even &lt;: nat, part 2." width="1024" height="179" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/odd-nat-980x171.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/odd-nat-480x84.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" /></p>
<p>At this point, we have reached saturation — no new facts can be inferred from even ⩽ nat and odd ⩽ nat. Because we still haven’t uncovered a contradiction, we may conclude that the types even and odd are indeed subtypes of nat. Saturation is guaranteed because a given program uses finitely many type names.</p>
<h1>Deciding Parametric Subtyping</h1>
<p>Unfortunately, we can’t just use the previous algorithm to decide structural subtyping once we have <em>generics</em> (i.e., recursive parameterized type constructors). Saturation is <em>not</em> guaranteed because, with type constructors and type nesting, infinitely many pairs of types can be formed. For example, we might infer t[nat] ⩽ u[nat] and later infer t[t[nat]] ⩽ u[u[nat]] and so on.</p>
<p>In our POPL 2024 paper, we prove that structural subtyping is <em>undecidable</em> for recursive type constructors. To mitigate this, we propose <em>parametric subtyping</em>, a fragment of structural subtyping in which the accepted subtypings are exactly those that hold <em>parametrically</em>, i.e., those that map related type arguments to related type results. We provide a relatively simple declarative characterization of parametric subtyping and present an effective <em>decision procedure</em> for it.</p>
<h2>Saturation-Based Decision Procedure</h2>
<p>Leveraging the structure of the forward-inference algorithm for deciding structural subtyping of monomorphic types, we now present a related algorithm for deciding <em>parametric</em> subtyping of <em>polymorphic</em> types.</p>
<p>The decision procedure consists of two phases: the first phase uses saturating forward inference to derive the most general admissible parametric rules for each pair of defined type constructors; the second phase uses these rules and backward proof construction to build a finite derivation to decide a parametric subtyping problem.</p>
<p>As an example, let&#8217;s verify that stack[maybe[even]] ⩽ pops[maybe[nat]] is valid under parametric subtyping.</p>
<h3>First Phase: Forward Inference</h3>
<p>The parametricity of parametric subtyping means that we first look at the more general stack[α] ⩽ pops[γ]. We will assume that it holds and use saturating forward inference to discover the set of constraints on α and γ that must be satisfied for stack[α] ⩽ pops[γ] to hold. As for the monomorphic case, we expand according to definitions and invert structural subtyping rules, identifying a new pair of type constructors to add to the database: namely, maybe[κ] ⩽ maybe[κ&#8217;].<br />
<img loading="lazy" decoding="async" class="aligncenter wp-image-2915 size-large" src="https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-1-1024x274.png" alt="Forward inference of stack α &lt;: pops γ, part 1." width="1024" height="274" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-1-980x262.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-1-480x128.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" /></p>
<p>At this point, we leave the last subtyping on hold and proceed with the saturation procedure to determine the set of constraints on κ and κ&#8217; that must be satisfied for maybe[κ] ⩽ maybe[κ&#8217;] to hold:<br />
<img loading="lazy" decoding="async" class="aligncenter size-large wp-image-2916" src="https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-2-1024x283.png" alt="Forward inference of stack α &lt;: pops γ, part 2." width="1024" height="283" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-2-980x271.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-2-480x133.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" /></p>
<p>Updating the assumed subtypings with the constraint κ ⩽ κ&#8217; that must be satisfied for maybe[κ] ⩽ maybe[κ&#8217;] to hold, we can now return to the postponed judgment, instantiating the constraints for the maybe constructor. Thus, it must be that α ⨉ stack[α] ⩽ γ ⨉ pops[γ]. From this, we infer the constraint α ⩽ γ, update the assumed subtyping, and reach saturation.<br />
<img loading="lazy" decoding="async" class="aligncenter size-large wp-image-2917" src="https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-3-1024x242.png" alt="Forward inference of stack α &lt;: pops γ, part 3." width="1024" height="242" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-3-980x231.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-3-480x113.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" /></p>
<p>Because we have reached saturation, the necessary consequences described by the assumed subtypings are, in fact, sufficient and we arrive at the admissible rules:<br />
<img loading="lazy" decoding="async" class="aligncenter size-large wp-image-2918" src="https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-4-1024x302.png" alt="Forward inference of stack α &lt;: pops γ, part 4." width="1024" height="302" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-4-980x289.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/phase1-4-480x142.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" /></p>
<h3>Second Phase: Backward Construction</h3>
<p>Using the admissible subtyping rules inferred in the first phase, and also the admissible subtyping rule for the types even and nat, we can now proceed by backward construction to build a derivation for stack[maybe[even]] ⩽ pops[maybe[nat]]:<br />
<img loading="lazy" decoding="async" class="aligncenter wp-image-2919 size-large" src="https://blog.sigplan.org/wp-content/uploads/2025/01/phase2-1024x242.png" alt="Backward construction for stack (maybe even) &lt;: pops (maybe nat)." width="1024" height="242" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/phase2-980x231.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/phase2-480x113.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" /></p>
<h3>Three possible outcomes: parametric subtype, not a structural subtype, or not a parametric subtype</h3>
<p>All in all, our saturation-based procedure for deciding the parametric subtyping problem A ⩽ B yields one of three possible outcomes:</p>
<ul>
<li><strong>Yes, A is a <em>parametric</em> subtype of B.</strong> If forward inference saturates without revealing a contradiction and backward construction succeeds (as in the cases illustrated above), then the decision procedure concludes that A is a parametric subtype of B.</li>
<li><strong>No, A is <em>not</em> a <em>structural</em> subtype of B.</strong> If forward inference identifies a type mismatch, then the decision procedure concludes that A is <em>not</em> a <em>structural</em> subtype of B. For example, forward inference from an assumed nat ⩽ odd identifies a type mismatch and exhibits a contradiction:<br />
<img loading="lazy" decoding="async" class="aligncenter wp-image-2920 size-large" src="https://blog.sigplan.org/wp-content/uploads/2025/01/nat-not-sub-odd-1024x183.png" alt="Revealing a contradiction when trying to derive nat &lt;: odd." width="1024" height="183" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/nat-not-sub-odd-980x175.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/nat-not-sub-odd-480x86.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" />The decision procedure concludes that nat is <em>not</em> a <em>structural</em> subtype of odd.</li>
<li><strong>No, A is <em>not</em> a <em>parametric</em> subtype of B.</strong> If forward inference exhibits a contradiction because of non-parametricity, then the decision procedure concludes that A is <em>not</em> a <em>parametric</em> subtype of B. But it cannot definitively conclude whether or not A is a <em>structural</em> subtype of B. For example, a monomorphic type natstack would not be a <em>parametric</em> subtype of pops[nat] because forward inference from natstack ⩽ pops[γ] would detect nat ⩽ γ, which violates parametricity.<br />
<img loading="lazy" decoding="async" class="aligncenter size-large wp-image-2921" src="https://blog.sigplan.org/wp-content/uploads/2025/01/natstack-pops-1024x261.png" alt="Revealing a contradiction for the non-parametric subtyping natstack &lt;: pops γ." width="1024" height="261" srcset="https://blog.sigplan.org/wp-content/uploads/2025/01/natstack-pops-980x250.png 980w, https://blog.sigplan.org/wp-content/uploads/2025/01/natstack-pops-480x123.png 480w" sizes="auto, (min-width: 0px) and (max-width: 480px) 480px, (min-width: 481px) and (max-width: 980px) 980px, (min-width: 981px) 1024px, 100vw" /></li>
</ul>
<p>Although our implementation currently does not distinguish between the two categories of contradiction, we could easily incorporate this distinction.</p>
<h1>Further Details</h1>
<p>For proofs and further details of parametric subtyping&#8217;s declarative characterization, decision procedure, and other technical aspects, as well as additional examples and a brief discussion of the implementation, we refer the interested reader to <a href="https://doi.org/10.1145/3632932">our POPL 2024 paper</a>.  For our implementation of the decision procedure described in the paper, please see <a href="https://bitbucket.org/structural-types/polyte">our online repository</a>.</p>
<h1>A Brief Comparison of Parametric Subtyping with Java and Scala</h1>
<p>Java and Scala take a primarily <em>nominal</em> approach to subtyping. Generally, the programmer must anticipate and declare upfront any subtyping relationships that may be needed in the future, <em>at the time that the subclass is defined</em> (by using the <code>extends</code> keyword). In contrast, the above system of parametric subtyping is structural, allowing types to be defined independently and be used as subtypes whenever the compiler can verify the subtyping relationship, which is arguably more flexible.</p>
<p>(Scala does include <em>duck typing</em>, as a limited form of structural subtyping, but this duck typing does not support recursive types and requires the result to be an anonymous trait, making it significantly less expressive than our parametric subtyping. Furthermore, Scala&#8217;s duck typing is only fully verified at runtime.)</p>
<p>The limitations of subtyping with generics in Java are well-known and can be quite restrictive, regardless of the variance. To mitigate these limitations, Scala permits the programmer to annotate type parameters with variances. In contrast, parametric subtyping naturally infers these variances for free as part of the subtyping algorithm.</p>
<p>On the other hand, Scala&#8217;s subtyping includes several features that the above system of parametric subtyping does not. Scala permits non-parametric subtypings (nominally), such as <code>NatStack extends Stack[Nat]</code>; not covering non-parametric subtypings is the price that our system pays for its expressive, decidable <em>structural</em> subtyping. Scala also supports intersection and union types and type bounds, which are not part of the above notion of parametric subtyping, but which we hope to explore in future work.</p>
<p><strong>About the authors:</strong> <a href="https://cs.cmu.edu/~hdeyoung/">Henry DeYoung</a> is an adjunct professor in the Computer Science Department at Carnegie Mellon University. His research interests center around programming languages and type systems for concurrent programs, with an emphasis on logic-based approaches. <a href="https://www.di.fc.ul.pt/~amordido/">Andreia Mordido</a> is an assistant professor in the Department of Informatics of the Faculty of Sciences, University of Lisbon, and an integrated researcher at LASIGE. Her research focuses on programming languages and type systems for the specification and verification of communication protocols and programs. <a href="https://cs.cmu.edu/~fp/">Frank Pfenning</a> is a professor in the Computer Science Department at Carnegie Mellon University. His research interests include programming languages, substructural logics, type theory, logical frameworks, and concurrency. <a href="https://ankushdas.github.io/">Ankush Das</a> is an assistant professor in the Computer Science Department at Boston University (formerly at Amazon). His research interests are in the intersection of programming languages with cryptographic protocols, distributed systems, and probabilistic and machine learning models.</p>
<p><strong>Disclaimer:</strong> <em>These posts are written by individual contributors to share their thoughts on the SIGPLAN blog for the benefit of the community. Any views or opinions represented in this blog are personal, belong solely to the blog author and do not represent those of ACM SIGPLAN or its parent organization, ACM.</em></p>