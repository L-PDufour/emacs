<p>In a recent, real world problem I needed to load a heterogeneous sequence
of records from a buffer. Record layout is defined in a header before the
sequence. Each field is numeric, with a unique name composed of non-empty
alphanumeric period-delimited segments, where segments signify nested
structure. Field names are a comma-delimited list, in order of the record
layout. The catch motivating this article is that nested structures are
not necessarily contiguous. In my transformed representation I needed
nested structures to be contiguous. For illustrative purposes here, it
will be for JSON output. I came up with what I think is an interesting
solution, which I’ve implemented in C using <a href="/blog/2025/01/19/">techniques previously
discussed</a>.</p>

<p>The above description is probably confusing on its own, and an example is
worth a thousand words, so here’s a listing naming 7 fields:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timestamp,point.x,point.y,foo.bar.z,point.z,foo.bar.y,foo.bar.x
</code></pre></div></div>

<p>Where <code class="language-plaintext highlighter-rouge">point</code> is a substructure, as is <code class="language-plaintext highlighter-rouge">foo</code> and <code class="language-plaintext highlighter-rouge">bar</code>, but note they’re
interleaved in the record. So if a record contains these values:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{1758158348, 1.23, 4.56, -100, 7.89, -200, -300}
</code></pre></div></div>

<p>The JSON representation would look like:</p>

<div class="language-json highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">{</span><span class="w">
  </span><span class="nl">"timestamp"</span><span class="p">:</span><span class="w"> </span><span class="mi">1758158348</span><span class="p">,</span><span class="w">
  </span><span class="nl">"point"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mf">1.23</span><span class="p">,</span><span class="w">
    </span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mf">4.56</span><span class="p">,</span><span class="w">
    </span><span class="nl">"z"</span><span class="p">:</span><span class="w"> </span><span class="mf">7.89</span><span class="w">
  </span><span class="p">},</span><span class="w">
  </span><span class="nl">"foo"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
    </span><span class="nl">"bar"</span><span class="p">:</span><span class="w"> </span><span class="p">{</span><span class="w">
      </span><span class="nl">"z"</span><span class="p">:</span><span class="w"> </span><span class="mi">-100</span><span class="p">,</span><span class="w">
      </span><span class="nl">"y"</span><span class="p">:</span><span class="w"> </span><span class="mi">-200</span><span class="p">,</span><span class="w">
      </span><span class="nl">"x"</span><span class="p">:</span><span class="w"> </span><span class="mi">-300</span><span class="w">
    </span><span class="p">}</span><span class="w">
  </span><span class="p">}</span><span class="w">
</span><span class="p">}</span><span class="w">
</span></code></pre></div></div>

<p>Notice <code class="language-plaintext highlighter-rouge">point.z</code> moved up and <code class="language-plaintext highlighter-rouge">foo.bar.z</code> down, so that substructures are
contiguous in this representation as required for JSON. Sorting the field
names lexicographically would group them together as a simple solution.
However, as an additional constraint I want to retain the original field
order as much as possible. For example, <code class="language-plaintext highlighter-rouge">timestamp</code> is first in both the
original and JSON representations, but sorting would put it last. If all
substructures are already contiguous, nothing should change.</p>

<h3 id="solution-with-string-interning">Solution with string interning</h3>

<p>My solution is to intern the segment strings, assigning each a unique,
monotonic integral token in the order they’re observed. In my program,
zero is reserved as a special “root” token, and so the first string has
the value 1. The concrete values aren’t important, only that they’re
assigned monotonically.</p>

<p>The trick is that a string is always interned in the “namespace” of a
previous token. That is, we’re building a <code class="language-plaintext highlighter-rouge">(token, string) -&gt; token</code> map.
For our segments that namespace is the token for the parent structure, and
the top-level fields are interned in the reserved “root” namespace. When
applied to the example, we get the token sequences:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timestamp  -&gt; 1
point.x    -&gt; 2 3
point.y    -&gt; 2 4
foo.bar.z  -&gt; 5 6 7
point.z    -&gt; 2 8
foo.bar.y  -&gt; 5 6 9
foo.bar.x  -&gt; 5 6 10
</code></pre></div></div>

<p>And our map looks like:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{0, "timestamp"} -&gt; 1
{0, "point"}     -&gt; 2
{2, "x"}         -&gt; 3
{2, "y"}         -&gt; 4
{0, "foo"}       -&gt; 5
{5, "bar"}       -&gt; 6
{6, "z"}         -&gt; 7
{2, "z"}         -&gt; 8
{6, "y"}         -&gt; 9
{6, "x"}         -&gt; 10
</code></pre></div></div>

<p>Notice how <code class="language-plaintext highlighter-rouge">"x"</code> is assigned 3 and 10 due to different namespaces. That’s
important because otherwise the fields of <code class="language-plaintext highlighter-rouge">foo.bar</code> would sort in the same
order as <code class="language-plaintext highlighter-rouge">point</code>. Namespace gives these fields unique identities.</p>

<p>Once we have the token representation, sort lexicographically <em>by token</em>.
That pulls <code class="language-plaintext highlighter-rouge">point.z</code> up to its siblings.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>timestamp  -&gt; 1
point.x    -&gt; 2 3
point.y    -&gt; 2 4
point.z    -&gt; 2 8
foo.bar.z  -&gt; 5 6 7
foo.bar.y  -&gt; 5 6 9
foo.bar.x  -&gt; 5 6 10
</code></pre></div></div>

<p>Now we have the “output” order with minimal re-ordering. If substructures
were already contiguous, nothing changes. Assuming a reasonable map, this
is <code class="language-plaintext highlighter-rouge">O(n log n)</code>, primarily due to sorting.</p>

<h4 id="alternatives">Alternatives</h4>

<p>Before I thought of namespaces, my initial idea was to intern the whole
prefix of a segment. The sequence of look-ups would be:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>"timestamp"    -&gt; 1  -&gt; {1}
"point"        -&gt; 2
"point.x"      -&gt; 3  -&gt; {2, 3}
"point"        -&gt; 2
"point.y"      -&gt; 4  -&gt; {2, 4}
"foo"          -&gt; 5
"foo.bar"      -&gt; 6
"foo.bar.z"    -&gt; 7  -&gt; {5, 6, 7}
"point"        -&gt; 2
"point.z"      -&gt; 8  -&gt; {2, 8}
"foo"          -&gt; 5
"foo.bar"      -&gt; 6
"foo.bar.y"    -&gt; 9  -&gt; {5, 6, 9}
"foo"          -&gt; 5
"foo.bar"      -&gt; 6
"foo.bar.x"    -&gt; 10 -&gt; {5, 6, 10}
</code></pre></div></div>

<p>Ultimately it produces the same tokens, and this is a more straightforward
<code class="language-plaintext highlighter-rouge">string -&gt; string</code> map. The prefixes are acting as namespaces. However, I
wrote it this way as a kind of visual proof: Notice the right triangle
shape formed by the strings for each field. From the area we can see that
processing prefixes as strings is <code class="language-plaintext highlighter-rouge">O(n^2)</code> quadratic time on the number of
segments! In my real problem the inputs were never large enough for this
to matter, but I hate <a href="https://randomascii.wordpress.com/category/quadratic/">leaving behind avoidable quadratic algorithms</a>.
Using a token as a namespace flattens the prefix to a constant size.</p>

<p>Another option is a different map for each namespace. So for <code class="language-plaintext highlighter-rouge">foo.bar.z</code>
lookup the <code class="language-plaintext highlighter-rouge">"foo"</code> map <code class="language-plaintext highlighter-rouge">(string -&gt; map)</code> in the root <code class="language-plaintext highlighter-rouge">(string -&gt; map)</code>,
then within that lookup the <code class="language-plaintext highlighter-rouge">"bar"</code> table <code class="language-plaintext highlighter-rouge">(string -&gt; token)</code> (since this
is the penultimate segment), then intern <code class="language-plaintext highlighter-rouge">"z"</code> within that to get its
token. That wouldn’t have quadratic time complexity, but it seems quite a
bit more complicated than a single, flat <code class="language-plaintext highlighter-rouge">(token, string) -&gt; token</code> map.</p>

<h3 id="implementation-in-c">Implementation in C</h3>

<p>Because <a href="/blog/2023/02/11/">the standard library has little useful for us</a>, I am
building on <a href="/blog/2025/01/19/"><strong>previously-established definitions</strong></a>, so refer to
that article for basic definitions like <code class="language-plaintext highlighter-rouge">Str</code>. To start off, tokens will
be a size-typed integer so we never need to worry about overflowing the
token counter. We’d run out of memory first:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">ptrdiff</span> <span class="n">Token</span><span class="p">;</span>
</code></pre></div></div>

<p>We’re building a <code class="language-plaintext highlighter-rouge">(token, string) -&gt; token)</code> map, so we’ll need a hash
function for such keys:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">uint64_t</span> <span class="nf">hash</span><span class="p">(</span><span class="n">Token</span> <span class="n">t</span><span class="p">,</span> <span class="n">Str</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint64_t</span> <span class="n">r</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">t</span> <span class="o">&lt;&lt;</span> <span class="mi">8</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ptrdiff</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">r</span> <span class="o">^=</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">r</span> <span class="o">*=</span> <span class="mi">1111111111111111111u</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The map itself is a forever-useful <a href="/blog/2023/09/30/">hash trie</a>.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="n">Map</span> <span class="n">Map</span><span class="p">;</span>
<span class="k">struct</span> <span class="n">Map</span> <span class="p">{</span>
    <span class="n">Map</span>  <span class="o">*</span><span class="n">child</span><span class="p">[</span><span class="mi">4</span><span class="p">];</span>
    <span class="n">Token</span> <span class="n">namespace</span><span class="p">;</span>
    <span class="n">Str</span>   <span class="n">segment</span><span class="p">;</span>
    <span class="n">Token</span> <span class="n">token</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Token</span> <span class="o">*</span><span class="nf">upsert</span><span class="p">(</span><span class="n">Map</span> <span class="o">**</span><span class="n">m</span><span class="p">,</span> <span class="n">Token</span> <span class="n">namespace</span><span class="p">,</span> <span class="n">Str</span> <span class="n">segment</span><span class="p">,</span> <span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">h</span> <span class="o">=</span> <span class="n">hash</span><span class="p">(</span><span class="n">ns</span><span class="p">,</span> <span class="n">segment</span><span class="p">);</span> <span class="o">*</span><span class="n">m</span><span class="p">;</span> <span class="n">h</span> <span class="o">&lt;&lt;=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">namespace</span><span class="o">==</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">namespace</span> <span class="o">&amp;&amp;</span> <span class="n">equals</span><span class="p">(</span><span class="n">segment</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">segment</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">m</span> <span class="o">=</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">child</span><span class="p">[</span><span class="n">h</span><span class="o">&gt;&gt;</span><span class="mi">62</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="o">*</span><span class="n">m</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Map</span><span class="p">);</span>
    <span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">namespace</span> <span class="o">=</span> <span class="n">namespace</span><span class="p">;</span>
    <span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">segment</span> <span class="o">=</span> <span class="n">segment</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="p">(</span><span class="o">*</span><span class="n">m</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">token</span><span class="p">;</span>  <span class="c1">// caller will assign</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’ll use this map to convert a string naming a field into a sequence of
tokens, so we’ll <a href="/blog/2025/06/26/">need a slice</a>. Fields also have an offset within
the record and a type, which we’ll track via its original ordering, which
I’ll do with an <code class="language-plaintext highlighter-rouge">index</code> field (e.g. into the original header). Also track
the original name.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Str</span>          <span class="n">name</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span>    <span class="n">index</span><span class="p">;</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Token</span><span class="p">)</span> <span class="n">tokens</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Field</span><span class="p">;</span>
</code></pre></div></div>

<p>To sort fields we’ll need a comparator:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">ptrdiff_t</span> <span class="nf">field_compare</span><span class="p">(</span><span class="n">Field</span> <span class="n">a</span><span class="p">,</span> <span class="n">Field</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">ptrdiff_t</span> <span class="n">len</span> <span class="o">=</span> <span class="n">min</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Token</span> <span class="n">d</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">tokens</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">tokens</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">d</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">tokens</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Because field names are unique, each token sequence is unique, and so we
need not use <code class="language-plaintext highlighter-rouge">index</code> in the comparator.</p>

<p>Finally down to business: <a href="/blog/2025/03/02/">cut up the list</a> and build the token
sequences with the established <code class="language-plaintext highlighter-rouge">push</code> macro. The sort function isn’t
interesting, and could be as simple as libc <code class="language-plaintext highlighter-rouge">qsort</code> with the above
comparator (and adapter), so I’m only listing the prototype.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">field_sort</span><span class="p">(</span><span class="n">Slice</span><span class="p">(</span><span class="n">Field</span><span class="p">),</span> <span class="n">Arena</span> <span class="n">scratch</span><span class="p">);</span>

<span class="n">Slice</span><span class="p">(</span><span class="n">Field</span><span class="p">)</span> <span class="n">parse_fields</span><span class="p">(</span><span class="n">Str</span> <span class="n">fieldlist</span><span class="p">,</span> <span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Field</span><span class="p">)</span> <span class="n">fields</span>  <span class="o">=</span> <span class="p">{};</span>
    <span class="n">Map</span>         <span class="o">*</span><span class="n">strtab</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span>    <span class="n">ntokens</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">Cut</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{.</span><span class="n">tail</span><span class="o">=</span><span class="n">fieldlist</span><span class="p">,</span> <span class="p">.</span><span class="n">ok</span><span class="o">=</span><span class="nb">true</span><span class="p">};</span> <span class="n">c</span><span class="p">.</span><span class="n">ok</span><span class="p">;)</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="sc">','</span><span class="p">);</span>
        <span class="n">Field</span> <span class="n">field</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="n">field</span><span class="p">.</span><span class="n">name</span>  <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
        <span class="n">field</span><span class="p">.</span><span class="n">index</span> <span class="o">=</span> <span class="n">fields</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>

        <span class="n">Token</span> <span class="n">prev</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">Cut</span> <span class="n">f</span> <span class="o">=</span> <span class="p">{.</span><span class="n">tail</span><span class="o">=</span><span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">,</span> <span class="p">.</span><span class="n">ok</span><span class="o">=</span><span class="nb">true</span><span class="p">};</span> <span class="n">f</span><span class="p">.</span><span class="n">ok</span><span class="p">;)</span> <span class="p">{</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">f</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="sc">'.'</span><span class="p">);</span>
            <span class="n">Token</span> <span class="o">*</span><span class="n">token</span> <span class="o">=</span> <span class="n">upsert</span><span class="p">(</span><span class="o">&amp;</span><span class="n">strtab</span><span class="p">,</span> <span class="n">prev</span><span class="p">,</span> <span class="n">f</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!*</span><span class="n">token</span><span class="p">)</span> <span class="p">{</span>
                <span class="o">*</span><span class="n">token</span> <span class="o">=</span> <span class="o">++</span><span class="n">ntokens</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="o">*</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">field</span><span class="p">.</span><span class="n">tokens</span><span class="p">)</span> <span class="o">=</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>
            <span class="n">prev</span> <span class="o">=</span> <span class="o">*</span><span class="n">token</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="o">*</span><span class="n">push</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fields</span><span class="p">)</span> <span class="o">=</span> <span class="n">field</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">field_sort</span><span class="p">(</span><span class="n">fields</span><span class="p">,</span> <span class="o">*</span><span class="n">a</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">fields</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Usage here suggests <code class="language-plaintext highlighter-rouge">Cut::ok</code> should be inverted to <code class="language-plaintext highlighter-rouge">Cut::done</code> so that it
better zero-initializes. Something I’ll need to consider. Because it’s all
allocated from an arena, no need for destructors or anything like that, so
this is the complete implementation. Back to the example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Str</span> <span class="n">fieldlist</span> <span class="o">=</span> <span class="n">S</span><span class="p">(</span>
        <span class="s">"timestamp,"</span>
        <span class="s">"point.x,"</span>
        <span class="s">"point.y,"</span>
        <span class="s">"foo.bar.z,"</span>
        <span class="s">"point.z,"</span>
        <span class="s">"foo.bar.y,"</span>
        <span class="s">"foo.bar.x"</span>
    <span class="p">);</span>
    <span class="n">Slice</span><span class="p">(</span><span class="n">Field</span><span class="p">)</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">parse_fields</span><span class="p">(</span><span class="n">fieldlist</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">scratch</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">fields</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Str</span> <span class="n">name</span> <span class="o">=</span> <span class="n">fields</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">name</span><span class="p">;</span>
        <span class="n">fwrite</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">name</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">stdout</span><span class="p">);</span>
        <span class="n">putchar</span><span class="p">(</span><span class="sc">'\n'</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>This program will print the proper output field order. In a real program
we’d hold onto the string table, define an inverse lookup to translate
tokens back into strings, and use it when in producing output. I do just
that in my exploratory program, <a href="https://github.com/skeeto/scratch/blob/master/rec2json/rec2json.c"><strong><code class="language-plaintext highlighter-rouge">rec2json.c</code></strong></a>, written a little
differently than presented above. It uses the sorted tokens to compile a
simple bytecode program that, when run against a record, produces its JSON
representation. It compiles the example to:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>OPEN          # print '{'
KEY     1     # print token 1 as a key, i.e. "timestamp:"
READ    0     # print double at record offset 0
COMMA         # print ','
KEY     2     # print token 2 as a key, i.e. "point:"
OPEN
KEY     3
READ    8     # print double at record offset 8
COMMA
KEY     4
READ    16
COMMA
KEY     8
READ    32
CLOSE         # print '}'
COMMA
KEY     5
OPEN
KEY     6
OPEN
KEY     7
READ    24
COMMA
KEY     9
READ    40
COMMA
KEY     10
READ    48
CLOSE
CLOSE
CLOSE
</code></pre></div></div>

<p>Seeing it written out, I notice more room for improvement. An optimization
pass could coalesce instructions so that, for instance, <code class="language-plaintext highlighter-rouge">OPEN</code> then <code class="language-plaintext highlighter-rouge">KEY</code>
<a href="/blog/2024/05/25/">concatenate</a> to a single string at compile time so that it only needs
one instruction. This program could be 15 instructions instead of 31. In
my real case I didn’t need anything quite this sophisticated, but it was
fun to explore.</p>


    