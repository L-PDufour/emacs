
<p class=" text-justify drop-cap">I’m sure you’ve found yourself in this situation: you want to edit something, but in multiple places, and at the same time. You’re busy; you don’t want to repeat yourself, and this is the twenty-first century and we <em>do</em> have the technology to do this!</p>
<p class=" text-justify">I’ve talked about this too-common problem before: <a href="/article/iedit-interactive-multi-occurrence-editing-in-your-buffer" class=" article-link">multi-occurrence editing with iedit</a> is one such package; the ubiquitous, and excellent, <a href="https://github.com/magnars/multiple-cursors.el" class=" article-link">multiple cursors</a> package is another common one.</p>
<p class=" text-justify">Editing multiple occurrences either simultaneously or in sequence is not a new invention. Good, old <code>C-M-%</code> (<code>M-x query-replace-regexp</code>) is sometimes the right choice if you can capture your matches and desired replacements with a regular expression. If that approach does not work, then why not reach out and touch a bunch of stuff with multiple cursors? If you dislike multiple cursors, you can confect a <a href="/article/keyboard-macros-are-misunderstood" class=" article-link">fancy keyboard macro</a> to do the work instead (sadly, the fans of keyboard macros are far too occupied to join us right now, as they are busy trying to re-record or edit the macro steps so it works properly.)</p>
<p class=" text-justify">No matter the tool, you’re still limited by your ability to collect the <em>right</em> places to edit. These tools can in principle drop cursors anywhere you want them to, but the problem is that outside of a handful of obvious things (same column offset on each line; each word or symbol matching something; the cadence of text using <code>forward-word</code>; etc.) you must compel these tools to place the cursors where you want them to, and that is often manual, verging on tedious, and not always possible.</p>
<p class=" text-justify">That’s where <a href="/article/tree-sitter-complications-of-parsing-languages" class=" article-link">tree-sitter</a> and its concrete syntax tree of your source code enter the frame.</p>
<figure>
<img src="/static/uploads/combobulate/combobulate-field-editor-rename.gif" alt="/static/uploads/combobulate/combobulate-field-editor-rename.gif" class=" center-block">
<figcaption>Here I am using Combobulate’s node editor, bound to <code>C-c o t x</code>, to pick the node at point’s text (here named <code>n</code>) and then I progressively expand the search scope for similarly-named nodes before renaming them all using Combobulate’s new field editor. More on that below.</figcaption>
</figure>
<p class=" text-justify">In <a href="/article/combobulate-intuitive-structured-navigation-treesitter" class=" article-link">Combobulate, my easy-to-use package</a> that adds navigation and editing to tree-sitter-supported languages, that was one of the first things I wanted to support way back in the day when I first built the prototype version.</p>
<p class=" text-justify">You see, with a concrete syntax tree, it’s trivial to throw down a cursor at every member of an array, for example, but <em>precisely</em> so there’s no worry about accidentally picking things that may <em>look</em> like an array element – something that is bound to happen if you were to try and do this using more naive means, like with imperative code or regular expressions – but isn’t. If you’ve ever over- or under-selected stuff with a keyboard macro or the likes of multiple cursors, then you know what I mean!</p>
<p class=" text-justify">That’s why I want to talk about Combobulate’s cursor editing functionality; some of the unexpected challenges around building it; and a new method of doing cursor editing without relying on third-party tools like multiple cursors.</p>
<H2 id="picking-the-right-things-with-a-query">Picking the Right Things With a Query</H2>
<p class=" text-justify">Before I get into all the ways that Combobulate can help you edit with multiple cursors, I want to first outline some of the challenges around picking things the things you want to edit. For all the talk I did around how much better a concrete syntax tree is – and it <em>is</em> infinitely better – there are snags.</p>
<p class=" text-justify">Combobulate, when I first set out to write it, had to work uniformly across a wide range of languages that I used professionally: Python, bash, Typescript + TSX, HTML, CSS, etc.</p>
<p class=" text-justify">If you’re at all familiar with tree-sitter, you probably know that you can build s-expression-alike queries, and that is one of the main ways of interfacing with the tree it makes.</p>
<p class=" text-justify">Here’s one such made-up example, and it (or something akin to it) is a common thing to want to edit. Given the following query and a starting node, you can tag nodes in the query with <code>@mytag</code> to indicate that you want tree-sitter to return said nodes, provided there are matches of course:</p>
<pre><code>(object
   (pair
      key: (_) @match))</code></pre>
<p class=" text-justify">How do you edit the keys in an object/dictionary without tree-sitter? It’s easy enough with traditional tools if the keys line up in your buffer with surgical precision. But what if they don’t? Perhaps they’re disordered and not formatted well, so you can’t just go to the next line with the same offset, or hope <code>forward-sexp</code> and friends can get you there. Tree-sitter makes it a cinch to pluck them anyway.</p>
<p class=" text-justify">The example above works by tagging any node that matches <code>(_)</code> (we could limit it to <code>(string)</code> also, for example, to collect only string keys) using the <code>key:</code> field, which is inside a <code>pair</code>, which is also inside an <code>object</code>. Here <code>@match</code> is a made-up tag, so we’d have to do some leg work to feed it to multiple cursors, of course, but that is not terribly hard.</p>
<p class=" text-justify">That’s also how TS-based syntax highlighting works: you tag stuff with the name of the face (such as <code>@font-lock-string-face</code>) you want, and Emacs’s font lock engine colors the matches according to the list of queries you have given it. Same query engine, distinct use cases.</p>
<p class=" text-justify">It’s a defining feature of tree-sitter. I doubt it would have seen much adoption without it, to be honest. Combobulate has an excellent <a href="/article/combobulate-editing-searching-new-query-builder" class=" article-link">interactive query builder</a> complete with code completion and syntax highlighting, so you can try it out yourself. (Spoiler alert: you can tell Combobulate to edit stuff based on a query. Give it a try!)</p>
<p class=" text-justify">For all the marvelous benefits of tree-sitter’s query matching engine, it has a humongous, frustrating black mark against it.</p>
<H3 id="when-queries-fail">When Queries Fail</H3>
<p class=" text-justify">Can you guess what it is?</p>
<p class=" text-justify">Let me show you a picture — it’ll give it away:</p>
<figure>
<img src="/static/uploads/combobulate/combobulate-query-matches-all-keys.png" alt="/static/uploads/combobulate/combobulate-query-matches-all-keys.png" class=" center-block">
<figcaption>Combobulate’s query builder (<code>C-c o B q</code>) is highlighting all the matches using the aforementioned query. Observe how it matches all nested keys also.</figcaption>
</figure>
<p class=" text-justify">It’s recursive. That is a useful property for highlighters or general-purpose “sally forth and find me all matches” needs, which is admittedly a large tract of why you’d use the query engine.</p>
<p class=" text-justify">But it is not so useful if you want to edit just <em>one</em> level of keys in an object, or – as I discovered when I started using it in anger – the start and end elements in HTML or TSX. Any sort of self-similar nodes (nested <em>anything</em>, like HTML tags) are immediately snared by this feature.</p>
<p class=" text-justify">You know, I just wanted to add basic multi-editing to early versions of Combobulate: simultaneously renaming matching HTML tags. That sort of thing. The query system seemed like the perfect abstraction. I could <em>literally describe what I wanted to edit</em>.</p>
<p class=" text-justify">Womp, womp. Except I couldn’t. Not with the query engine, mind — not without attempting error-prone post-processing to weed out false positives, somehow. But that, in my mind, ran against the philosophy of capturing the requirements in a declarative query, and that Combobulate should not special-case code for each language it supports. (That is an adamantine rule that still stands.)</p>
<p class=" text-justify">The workaround, if you can call it that, is to anchor the query to the root node – that “disables”, by way of exclusively matching all of a node’s parents, for there is just one root node in a tree – the recursive check. Thus, given a node in a tree, it is possible to construct a query that matches <em>just</em> that node, though you would have to describe the entire relationship of the tree, from leaf-to-trunk, and all its siblings along the way.</p>
<p class=" text-justify">So to match an object, without recursion gumming things up, in Javascript, nested in a function somewhere, would look like this, but far more complex in real life:</p>
<pre><code>(program
  (some_function
     (something_else
       (...
          (object ...)))))</code></pre>
<p class=" text-justify">Alas, that is not exactly a solution worth talking about.</p>
<p class=" text-justify">So how to fix it, then?</p>
<H3 id="the-query-fix">The Query “Fix”</H3>
<p class=" text-justify">So I “fixed” it by reimplementing a large proportion of the tree-sitter query engine in elisp. That was a complex project that took quite a long time to get “right”, for some definition of right, when I wrote it some years ago now. The implementation surely still has bugs. I know it does, because tree-sitter’s <em>official</em> query builder still has a steady stream of bug fixes getting merged. And if <em>that</em> is still buggy, then so is mine!</p>
<p class=" text-justify">It’s also kinda slow, so it’s never going to help you font lock your code! I also decided to take a few of the lesser-used features of Emacs core that are perfect for this type of Computer Science problem for a spin: generator functions using <code>iter-defun</code> and friends. Generators are implemented entirely using Lisp macros, which is kind of neat. Writing all that <em>Lisp macrology</em> must’ve been a fun hobby project to build and design, for sure, but it’s not so fun to use: it feels quite slow and cannot be debugged easily. And good luck understanding the macroexpanded code it makes. <em>Yikes</em>.</p>
<p class=" text-justify">So. Combobulate’s query engine is not designed to replace tree-sitters’. It’s now a complement to the little declarative mini-language in Combobulate that I settled on so I could support <a href="/article/combobulate-intuitive-structured-navigation-treesitter" class=" article-link">intuitive, structured navigation</a> (called the <em>procedures</em>).</p>
<p class=" text-justify">That means it’s possible to ask Combobulate to find stuff the normal way, and then use its (or TS’) query language for finesse:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode commonlisp"><code class="sourceCode commonlisp"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1" class=" article-link"></a>(procedures-sequence</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1" class=" article-link"></a>   '((:activation-nodes</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1" class=" article-link"></a>      ((:nodes (<span class="st">"tag_name"</span>) :position any :has-ancestor (<span class="st">"element"</span>)))</span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1" class=" article-link"></a>      :selector (:choose parent :match-query</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1" class=" article-link"></a>                         (:query</span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1" class=" article-link"></a>                          (_ (start_tag (tag_name) @match)</span>
<span id="cb3-7"><a href="#cb3-7" aria-hidden="true" tabindex="-1" class=" article-link"></a>                             (end_tag (tag_name) @match))</span>
<span id="cb3-8"><a href="#cb3-8" aria-hidden="true" tabindex="-1" class=" article-link"></a>                          :engine combobulate)))))</span></code></pre></div>
<p class=" text-justify">For example, you can use <code>C-c o t c</code> (cursor edit by sequence) to edit matching HTML tags, and when you do so, this is the DSL declaration it “runs” to determine what to do. (If you’re inside a <code>tag_name</code> and it has an ancestor <code>element</code> then trigger the <code>:selector</code>)</p>
<p class=" text-justify">The underlying query (see <code>:query</code>), such as it is, works fine in TS’s query engine also, but with the side-effect of being recursive.</p>
<p class=" text-justify">I wrote the query engine back when I thought queries would play a much larger role in Combobulate. Back then, I naively assumed (as you do) that with the bountiful choices made available by a concrete syntax tree, all I had to do was write The Right Query and I could avoid a lot of imperative hand-wringing.</p>
<p class=" text-justify">As it turns out, the query engines (plural) are useless for most things related to structured navigation and editing. So despite the <em>theoretical</em> utility of the query engines, in reality I am slowly replacing most of the queries – the few that still remain today – with the DSL.</p>
<p class=" text-justify">The DSL is ironically better at picking things, despite its imperative-yet-declarative nature than an all-singing, all-dancing but weirdly limiting set of query engines.</p>
<p class=" text-justify">One example of where the DSL wins is <a href="/article/combobulate-intuitive-structured-navigation-treesitter" class=" article-link">sibling navigation</a>, a topic I have covered at length before. Before I came up with the DSL, I’d started the arduous task of using building queries to pick all the keys in a dictionary; the arguments in a function definition; and so on, and so forth. Far too tedious as the query language is too limiting.</p>
<p class=" text-justify">Who knew?</p>
<p class=" text-justify">So, today, the query engines remain useful mostly for ad hoc highlighting; bulk editing, yes, still; and deft selection of nodes when the mini-DSL fails to do the job.</p>
<p class=" text-justify">You might wonder why I haven’t just extended my query language to suit my every need.</p>
<p class=" text-justify">The answer is that I feel that it is not really feasible to express these ideas in a language that – if we are to hew somewhat close to the original intent of the tree-sitter query language, and if we do not do that, then my DSL is already such a language! – is boxed in by its desire to be (as it should be!) a pattern matching language with a bunch of deterministic finite automata tacked on to solve the unenviable problem of having to support optional matches, quantifiers, negation, and so on.</p>
<p class=" text-justify">The DSL meanwhile relies on the idea of doing simple node type matching and then ascending or descending the tree to match other things based on simple set-theoretic filters and a handful of hardcoded instructions, such as “give me all the things that can go in an <code>if</code> statement except for this or that and then give me all siblings that match something else entirely”.</p>
<p class=" text-justify">So that is a brief summary of how the query engine looks like a panacea, but is ultimately not a great fit for most multi-cursor editing tasks, and indeed most precision editing and movement tasks, as you’d have to fight it and write a lot of imperative code anyway.</p>
<p class=" text-justify">Right. Let’s talk about some fun things instead.</p>
<H2 id="cursor-editing">Cursor Editing</H2>
<p class=" text-justify">Combobulate’s had cursor editing for a long time. I recently rewrote the system to get rid of what was formerly known as <em>cluster editing</em>: basically the stuff you just read about. Like editing matching HTML tags.</p>
<p class=" text-justify">That feature is now called <em>sequence editing</em>, which uses the procedure system to edit any <em>sequence</em> Combobulate knows about, such as the oft-repeated HTML tags.</p>
<p class=" text-justify">My impetus for doing this is that the bulk of the cluster editors I’d written were a parallel way of doing sibling editing before I had proper, reliable <a href="/article/combobulate-intuitive-structured-navigation-treesitter" class=" article-link">sibling navigation</a>.</p>
<p class=" text-justify">Sibling navigation is one of the most important keystone features in Combobulate as it is such a powerful catalyst for nearly all other editing and movement features in Combobulate, surprising as that may sound!</p>
<p class=" text-justify">Case in point: keys in a dictionary; elements in an array; function arguments. They are all siblings. They should be editable <em>as</em> siblings. And now they are.</p>
<p class=" text-justify">The <code>C-c o t s</code> command invokes the sibling editor. It works in any place where regular <code>C-M-n</code> and <code>C-M-p</code> sibling navigation works, as it uses the same code base.</p>
<figure>
<img src="/static/uploads/combobulate/combobulate-query-edit-shorthand.gif" alt="/static/uploads/combobulate/combobulate-query-edit-shorthand.gif" class=" center-block">
<figcaption>Here’s a simple example where I drop in and edit the shorthands in Typescript using the sibling editing command and multiple cursors.</figcaption>
</figure>
<p class=" text-justify">If I <em>didn’t</em> use the sibling system, I would’ve had to build a custom cluster query to mark the nodes instead. Tedium squared.</p>
<p class=" text-justify">But that’s all gone now. Except…</p>
<H3 id="clusters-sequences">Clusters &amp; Sequences</H3>
<p class=" text-justify">The tag names in HTML tags (the <code>div</code> in <code>&lt;div&gt;</code>) are <em>not</em> siblings:</p>
<pre><code>(element
  (start_tag (tag_name))
  (end_tag (tag_name)))</code></pre>
<p class=" text-justify">Start and end tag <em>are</em> siblings, but we do not sibling navigate by start or end tag, but <code>element</code>. (There are good reasons for this.) So a call to <code>C-c o t s</code> with point at <code>&lt;div&gt;</code> would instead edit all <em>sibling elements</em> and not the two tag names. That, and the point would be in the wrong place: it should be here: <code>-!-div</code>. Not to the left of <code>&lt;</code> in <code>&lt;div&gt;</code> and <code>&lt;/div&gt;</code>. You can’t even <code>C-f</code> once to correct for it, as closing tags terminate with <code>&lt;/</code> and not <code>&lt;</code>, so you’d be off by one!</p>
<p class=" text-justify">That’s why we still need some form of “clustered editing”. Though in this case I scried an opportunity to improve navigation <em>as well as</em> retaining tag editing.</p>
<p class=" text-justify">New to the latest version of Combobulate is <em>sequence navigation</em>, bound to <code>M-n</code> and <code>M-p</code>. Most nodes lack a <em>sequent</em>; it is not a general purpose movement command, as it only applies in situations where nodes are sequences but not strictly speaking siblings.</p>
<p class=" text-justify">Put point inside a <code>&lt;tag&gt;</code> and you can use <code>M-n/p</code> to cycle between the start and end tag. That is <em>super helpful</em> if you work with SGML-alike languages. Use <code>C-c o t c</code> to sequence edit them.</p>
<p class=" text-justify">Now you have useful navigation <em>and</em> editing capabilities for places where things are not-quite-adjacent (like JSX and HTML). (If you can think of other cases, do raise a Github issue.)</p>
<p class=" text-justify">Ironically, this is a fine use case for the DSL <em>and</em> Combobulate’s query engine to ensure I drill down and pluck the tag names from the start and end tags.</p>
<H4 id="sequence-scanning">Sequence Scanning</H4>
<p class=" text-justify">16+ years ago I wrote an awful lot of Borland Delphi for a living. I won’t get into how amazing the UI development experience was except to say that where that was the zenith of productivity, its garbage-tier code editor was surely the nadir. It didn’t even <em>indent your code for you</em>. Bah.</p>
<p class=" text-justify">It was a terrible editing experience, except for one little feature I loved in a third-party plugin: keyword scanning. If you pressed <code>M-p</code> or <code>M-n</code> on any identifier in the editor, it’d jump to it, but without the obsequiously stupid “Find Dialog” getting in your way to “help you find what you want”.</p>
<p class=" text-justify">I loved it so much it was one of the first things I wrote in Emacs Lisp, and talked about much later here. I called it <a href="/article/smart-scan-jump-symbols-buffer" class=" article-link">Smart Scan: Jump between symbols in a buffer</a>.</p>
<p class=" text-justify">I still use it. But it annoyed me that I didn’t have a similar feature in Combobulate so others can benefit from its utility, and that the two keys the new sequence key bindings are now bound to conflict with smart scan.</p>
<p class=" text-justify">So I merged the features. If your point is in one of the few supported <em>sequences</em>, Combobulate will abide and only move between them. Try to move outside the “range” of valid options, and you’re shown an error: tap the key <em>again</em> without hesitation, and it switches to free-form scanning for that keyword anywhere in the buffer and “outside” the reign of tree-sitter. (It’s effectively akin to regexp searching for <code>\&lt;foo\&gt;</code>.)</p>
<p class=" text-justify">Use it anywhere else, and it launches into a freeform search mode for the symbol at point without first raising an error. The end result is you can safely navigate sequences and not worry about getting pulled away from what you’re looking for, while still having the freedom to do search out of bounds, so to speak, if you tap the key again.</p>
<H3 id="bulk-editing-with-combobulate">Bulk Editing with Combobulate</H3>
<p class=" text-justify">There’s a handful of bulk editing commands that come with Combobulate.</p>
<table style="width:86%;" class=" table">
<colgroup>
<col style="width: 43%">
<col style="width: 43%">
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Key Bindings</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>C-c o t t</code></td>
<td>Edit by node type DWIM</td>
</tr>
<tr class="odd">
<td><code>C-c o t x</code></td>
<td>Edit by node text DWIM</td>
</tr>
<tr class="even">
<td><code>C-c o t c</code></td>
<td>Edit sequence</td>
</tr>
<tr class="odd">
<td><code>C-c o t s</code></td>
<td>Edit siblings</td>
</tr>
<tr class="even">
<td><code>C-c o B q</code></td>
<td>Open query builder (interactive query building)</td>
</tr>
<tr class="odd">
<td><code>C-c o B r</code></td>
<td>Display query from root to point</td>
</tr>
<tr class="even">
<td><code>C-c o B p</code></td>
<td>Display query that matches node text at point</td>
</tr>
</tbody>
</table>
<p class=" text-justify">Aside from a handful of defaults in the <code>C-c o t</code> keymap, there are commands that build queries you can use as a baseline to create your own custom editors. My article on <a href="/article/combobulate-editing-searching-new-query-builder" class=" article-link">Editing and Searching with the new Query Builder</a> goes into more detail on those.</p>
<p class=" text-justify">Most commands that “Do What I Mean” require a context locus that serves as a limit for cursor editing. You rarely want to edit the whole buffer. That way you can limit your node editing to just the current statement or function, for example, without having to manually remove cursors after the fact.</p>
<figure>
<img src="/static/uploads/combobulate/combobulate-expand-edit.gif" alt="/static/uploads/combobulate/combobulate-expand-edit.gif" class=" center-block">
<figcaption>Edit nodes by type with <code>C-c o t t</code>. You’re asked to confirm the locus (how far Combobulate should go look for nodes of the same type) to edit in one go, starting with just the element pair.</figcaption>
</figure>
<H4 id="multiple-cursors">Multiple Cursors</H4>
<p class=" text-justify">I like multiple cursors, and it’s a tool I use all the time, but it <em>is</em> an external, though optional, dependency in Combobulate, and while I’m OK with that, it’s also something I feel shouldn’t be <em>required</em> for basic bulk editing. I want people to at least be able to use Combobulate’s editing facilities without requiring multiple cursors.</p>
<p class=" text-justify">Having said that, multiple cursors is well integrated into Combobulate. Every node has a start and an end, for example, so having the ability to insert a cursor at either end is especially useful.</p>
<table style="width:86%;" class=" table">
<colgroup>
<col style="width: 43%">
<col style="width: 43%">
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Modifier Arguments</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><em>None</em></td>
<td>Place cursor at the start (default)</td>
</tr>
<tr class="odd">
<td><code>C-u</code></td>
<td>Place cursor at the end</td>
</tr>
<tr class="even">
<td><code>C-u C-u</code></td>
<td>Mark the node</td>
</tr>
</tbody>
</table>
<p class=" text-justify">You can control the placement of the cursors for any of the <em>edit</em> commands in the <code>C-c o t</code> key map by giving it a prefix key. By default cursors are placed at the start of a node; a single <code>C-u</code> argument changes that to the end.</p>
<p class=" text-justify">One of the benefits of multiple cursors is that it supports non-contiguous regions, so each cursor can have its own region. To mark things instead, prefix with <code>C-u C-u</code> instead. At that point you can use <code>C-x C-x</code> to swap point and mark to move between the start and end of the node.</p>
<H4 id="combobulates-field-editor">Combobulate’s Field Editor</H4>
<figure>
<img src="/static/uploads/combobulate/combobulate-field-number.gif" alt="/static/uploads/combobulate/combobulate-field-number.gif" class=" center-block">
<figcaption>Appending and prepending text with the field editor.</figcaption>
</figure>
<p class=" text-justify">Combobulate has an advanced snippet templating tool feature called <em>envelopes</em> (check out <code>C-c o e ...</code>.) It has been around for a long time now (and more on that in another post!) and, like any good templating tool, it supports <em>fields</em>, but with an important difference: it uses the minibuffer prompt mechanism to query for input instead of expecting you to type into an overlay dyed and imbued with special properties in your buffer. Unlike the abandoned <em>Tempo</em> and <em>Skeleton</em> templating packages in Emacs, Combobulate updates the fields as you type in the minibuffer.</p>
<p class=" text-justify">Because Combobulate already has a templating tool, it was a snap reusing the code as a cursor editing system that works a little bit like a trad templating tool crossed with <code>C-x r t</code> (<code>M-x string-rectangle</code>), another Emacs classic that uses the rectangle system in Emacs to prefix text. The string rectangle feature’s a little too basic on its own — it’s useful, for sure, but I figured I could make Combobulate’s editor a bit more ergonomic and flexible than simply reinventing such a basic mechanic.</p>
<p class=" text-justify">A large part of the edits I make when I use multiple cursors are simple append/prepend operations to the existing text. Not always, but often. To facilitate that sort of editing, I needed a placeholder symbol in the minibuffer to represent each node’s text. Otherwise, I’d have no way of prepending <em>and</em> appending in the minibuffer: there is one minibuffer prompt, after all, but more than one node field to update, and each may have vastly different text.</p>
<p class=" text-justify">Ergo, there must be a generic placeholder that represents each field’s node text. Thinking about it some more, I realized that this is really not all that different from the replace regexp’s capturing group feature found in, among other places, <code>C-M-%</code>.</p>
<p class=" text-justify">So why not just use that? You gain a number of other ancillary benefits for “free” (well, it required more coding, but they’re benefits to <em>you</em>) when you start thinking about each node as its own capturing group.</p>
<table style="width:58%;" class=" table">
<colgroup>
<col style="width: 29%">
<col style="width: 29%">
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Feature</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>\0</code></td>
<td>Inserts the original text for each field</td>
</tr>
<tr class="odd">
<td><code>\N</code></td>
<td>Inserts the Nth field’s text</td>
</tr>
<tr class="even">
<td><code>\#</code></td>
<td>Inserts the number of the field, starting from 0</td>
</tr>
<tr class="odd">
<td><code>\,FORM</code></td>
<td><p class=" text-justify">Evaluates the elisp form FORM.</p>
<p class=" text-justify">Capturing groups are valid inside the form.</p></td>
</tr>
</tbody>
</table>
<p class=" text-justify">With a regular replace regexp, the <code>\N</code> notation represents the N’th match, with the number <code>0</code> being the whole match string. In Combobulate, <code>\0</code> now represents the match string for each localized field you’re editing. So the default prompt value in Combobulate is <code>\0</code> meaning: just insert the original text you started with.</p>
<p class=" text-justify">All other numbers represent that particular node’s text. So <code>\1</code> is the first node; <code>\2</code> is the second, and so forth.</p>
<p class=" text-justify">That means it’s possible to not only replace every match with the content of a particular field, but also combine them. Maybe you want to merge the second and third fields’ text?</p>
<p class=" text-justify">Another regexp feature is the ability to insert the match number. By counting from the top-most field, you can insert the index of each field with <code>\#</code> as a practical and cheap way of enumerating things. It counts from 0.</p>
<p class=" text-justify"><code>C-M-%</code> has a really cool – and quite hidden – feature: <a href="/article/evaluating-lisp-forms-regular-expressions" class=" article-link">it can evaluate Lisp Forms inside Regular Expressions</a>. I’ve written about it before; it’s such an underrated feature. I do not need it often, but when I do, it’s nice to know I can combine the power of elisp with regexp search and replace.</p>
<figure>
<img src="/static/uploads/combobulate/combobulate-field-editor-eval-form.gif" alt="/static/uploads/combobulate/combobulate-field-editor-eval-form.gif" class=" center-block">
<figcaption>Evaluating forms in Combobulate’s field editor works much the same as it does in <code>C-M-%</code>. Here I’m uppercasing all the fields’ names using <code>upcase</code> and the <code>\0</code> capturing group.</figcaption>
</figure>
<p class=" text-justify">In addition to <em>all that</em>, there are key bindings in the field editor minibuffer (you can also see the key bindings by tapping <code>C-h</code> in the prompt):</p>
<table style="width:86%;" class=" table">
<colgroup>
<col style="width: 43%">
<col style="width: 43%">
</colgroup>
<tbody>
<tr class="odd">
<td><strong>Key Bindings</strong></td>
<td><strong>Description</strong></td>
</tr>
<tr class="even">
<td><code>C-n</code></td>
<td>Move to next field</td>
</tr>
<tr class="odd">
<td><code>C-p</code></td>
<td>Move to previous field</td>
</tr>
<tr class="even">
<td><code>C-v</code></td>
<td>Toggle the current field on or off</td>
</tr>
<tr class="odd">
<td><code>C-i</code></td>
<td>Invert fields’ editable state</td>
</tr>
<tr class="even">
<td><code>C-h</code></td>
<td>Show the help</td>
</tr>
</tbody>
</table>
<p class=" text-justify">You can scroll through the fields with <code>C-n/p</code>. You’ll need these if you want a closer look at the matched fields. You’re free to just switch to the buffer and scroll also, of course!</p>
<p class=" text-justify"><em>Unlike</em> multiple cursors, you can toggle the fields on or off. Do you want to bulk edit all the keys in a JSON object <em>except</em> one key? Now you can. Just move with <code>C-n/p</code> to the field in question and toggle it with <code>C-v</code>. <code>C-i</code> does much the same: it inverts the state of all fields.</p>
<p class=" text-justify">The field editor’s not perfect, but then nor is multiple cursors.</p>
<H4 id="a-quick-comparison-between-the-two">A quick Comparison between the two</H4>
<p class=" text-justify">Multiple cursors is, to me, an indispensable tool, and I will continue to use it for things that warrant it.</p>
<p class=" text-justify">The field editor is better for explicit, bulk edits where you do not require the flexibility or precision you get by having a point placed at every field.</p>
<p class=" text-justify">It is not possible to gingerly delete some characters or operate on partial node text matches with the field editor. (Though I suppose you could try with the Lisp form evaluation.)</p>
<p class=" text-justify">Simultaneously, it is not so easy to quickly prepend or append to the node text with MC. In fact, there is (to my knowledge) no way of declaring a ‘range’ to a cursor. Once it is created it is subject to the whims of the editing and movement you do in the buffer.</p>
<p class=" text-justify">You <em>can</em> use the <code>C-u C-u</code> argument to mark the nodes, which does give you some control over the start and end, but explicitly inserting something at the start of the node and then the end is perhaps not possible at all, if the node is not something you can quickly find the ‘end of’ with either Combobulate’s movement commands or Emacs’.</p>
<p class=" text-justify">MC does support some form of killing and yanking, but I find it awful and borderline unusable. If you want to merge or join nodes’ text together, you’re better off with a keyboard macro or the field editor.</p>
<p class=" text-justify">The other major advantage of the field editor is that it ships with Combobulate. It is also relatively easy to add new, explicit, commands to do things in the future.</p>
<p class=" text-justify">So. There are trade-offs to both approaches, but now you at least have a choice of what to use.</p>
<p class=" text-justify">Let me know what you think.</p>
<p class=" text-justify">Happy (bulk) editing!</p>
