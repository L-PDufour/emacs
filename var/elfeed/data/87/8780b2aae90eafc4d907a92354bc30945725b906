<html><head></head><body><p>I don’t know why I haven’t shared this little helper before, but here it is.</p>
<pre><code class="language-emacs-lisp">(defun mu-date-at-point (date)
  "Insert current DATE at point via `completing-read'."
  (interactive
   (let* ((formats '("%Y%m%d" "%F" "%Y%m%d%H%M" "%Y-%m-%dT%T"))
          (vals (mapcar #'format-time-string formats))
          (opts
           (lambda (string pred action)
             (if (eq action 'metadata)
                 '(metadata (display-sort-function . identity))
               (complete-with-action action vals string pred)))))
     (list (completing-read "Insert date: " opts nil t))))
  (insert date))
</code></pre>
<p>What <code>mu-date-at-point</code> does is formatting the current date in four different ways with <code>format-time-string</code>  and then offering them as options to <code>completing-read</code>.</p>
<p>The interesting part is how <code>opts</code> is built. It’s a nice trick to ensure its content is always sorted according to the order in <code>formats</code>. Without leveraging <code>completion-metadata</code> the completion system would take care of sorting the items for me.</p>
<p>For the record, I learned how to tweak <code>completion-metadata</code> on <a href="https://emacs.stackexchange.com/a/41808">Emacs StackExchange</a>. I suggest reading <code>C-h f completing-read</code> and <code>C-h f completion-metadata</code> to know more.</p>
</body></html>