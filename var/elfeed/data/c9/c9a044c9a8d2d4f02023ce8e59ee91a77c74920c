<p>It began as a <a href="https://www.coolmathgames.com/blog/how-to-play-lipuzz-water-sort">water sort puzzle</a> solver, constructed similarly to
<a href="/blog/2020/10/19/">my British Square solver</a>. It was nearly playable, so I added a user
interface <a href="/blog/2023/01/08/">with SDL2</a>. My wife enjoyed it on her desktop, but wished
to play on her phone. So then I needed to either rewrite it in JavaScript
and hope the solver was still fast enough for real-time use, or figure out
WebAssembly (Wasm). I succeeded, and now <a href="/water-sort/">my game runs in browsers</a>
(<a href="https://github.com/skeeto/scratch/tree/master/water-sort">source</a>). Like <a href="/blog/2025/03/06/">before</a>, next I ported <a href="/blog/2023/01/18/">my pkg-config clone</a>
to the Wasm System Interface (<a href="https://wasi.dev/">WASI</a>), whipped up a proof-of-concept UI,
and <a href="https://skeeto.github.io/u-config/">it too runs in browsers</a>. Neither use a language runtime,
resulting in little 8kB and 28kB Wasm binaries respectively. In this
article I share my experiences and techniques.</p>

<p>Wasm is a <a href="https://webassembly.github.io/spec/">specification</a> defining an abstract stack machine with a
Harvard architecture, and related formats. There are just four types, i32,
i64, f32, and f64. It also has “linear” octet-addressable memory starting
at zero, with no alignment restrictions on loads and stores. Address zero
is a valid, writable address, which resurfaces some, old school, high
level language challenges regarding null pointers. There are 32-bit and
64-bit flavors, though the latter remains experimental. That suits me: I
appreciate smaller pointers on 64-bit hosts, and I wish I could opt into
more often (e.g. x32).</p>

<p>As browser tech goes, they chose an apt name: WebAssembly is to the web as
JavaScript is to Java.</p>

<p>There are distinct components at play, and much of the online discussion
doesn’t do a great job drawing lines between them:</p>

<ul>
  <li>
    <p>Wasm module: A compiled and linked image — like ELF or PE — containing
sections for code, types, globals, import table, export table, and so
on. The export table lists the module’s entry points. It has an optional
<em>start section</em> indicating which function initializes a loaded image.
(In practice almost nobody actually uses the start section.) A Wasm
module can only affect the outside world through imported functions.
Wasm itself defines no external interfaces for Wasm programs, not even
printing or logging.</p>
  </li>
  <li>
    <p>Wasm runtime: Loads Wasm modules, linking import table entries into the
module. Because Wasm modules include types, the runtime can type check
this linkage at load time. With imports resolved, it executes the start
function, if any, then executes zero or more of its entry points, which
hopefully invokes import functions such a way as to produce useful
results, or perhaps simply return useful outputs.</p>
  </li>
  <li>
    <p>Wasm compiler: Converts a high-level language to low-level Wasm. In
order to do so, it requires some kind of Application Binary Interface
(ABI) to map the high-level language concepts onto the machine. This
typically introduces additional execution elements, and it’s important
that we distinguish them from the abstract machine’s execution elements.
Clang is the only compiler we’ll be discussing in this article, though
there are many. During compilation the <em>function indices</em> are yet
unknown and so references will need to be patched in by a linker.</p>
  </li>
  <li>
    <p>Wasm linker: Settles the shape of the Wasm module and links up the
functions emitted by the compiler. LLVM comes with <code class="language-plaintext highlighter-rouge">wasm-ld</code>, and it
goes hand-in-hand with Clang as a compiler.</p>
  </li>
  <li>
    <p>Language runtime: Unless you’re hand-writing raw Wasm, your high-level
language probably has a standard library with operating system
interfaces. C standard library, POSIX interfaces, etc. This runtime
likely maps onto some standardized set of imports, most likely the
aforementioned WASI, which defines a set of POSIX-like functions that
Wasm modules may import. Because I <a href="/blog/2023/02/11/">think we could do better</a>,
<a href="/blog/2023/02/15/">as usual</a> <a href="/blog/2023/03/23/">around here</a>, in this article we’re going to
eschew the language runtime and code directly against raw WASI. You
still have <a href="/blog/2025/01/19/">easy access hash tables and dynamic arrays</a>.</p>
  </li>
</ul>

<p>A combination of compiler-linker-runtime is conventionally called a
<em>toolchain</em>. However, because almost any Clang installation can target
Wasm out-of-the-box, and we’re skipping the language runtime, you can
compile any of programs discussed in this article, including my game, with
nothing more than Clang (invoking <code class="language-plaintext highlighter-rouge">wasm-ld</code> implicitly). If you have a
Wasm runtime, which includes your browser, you can run them, too! Though
this article will mostly focus on WASI, and you’ll need a WASI-capable
runtime to run those examples, which doesn’t include browsers (short of
implementing the API with JavaScript).</p>

<p>I wasn’t particularly happy with the Wasm runtimes I tried, so I cannot
enthusiastically recommend one. I’d love if I could point to one and say,
“Use the same Clang to compile the runtime that you’re using to compile
Wasm!” Alas, I had issues compiling, the runtime was buggy, or WASI was
incomplete. However, <a href="https://wazero.io/">wazero</a> (Go) was the easiest for me to use and it
worked well enough, so I will use it in examples:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ go install github.com/tetratelabs/wazero/cmd/wazero@latest
</code></pre></div></div>

<p>The Wasm Binary Toolkit (<a href="https://github.com/WebAssembly/wabt">WABT</a>) is good to have on hand when working
with Wasm, particularly <code class="language-plaintext highlighter-rouge">wasm2wat</code> to inspect Wasm modules, sort of like
<code class="language-plaintext highlighter-rouge">objdump</code> or <code class="language-plaintext highlighter-rouge">readelf</code>. It converts Wasm to the WebAssembly Text Format
(WAT).</p>

<p>Learning Wasm I had quite some difficultly finding information. Outside of
the Wasm specification, which, despite its length, is merely a narrow
slice of the ecosystem, important technical details are scattered all over
the place. Some is only available as source code, some buried comments in
GitHub issues, and some lost behind dead links as repositories have moved.
Large parts of LLVM are undocumented beyond an mention of existence. WASI
has no documentation in a web-friendly format — so I have nothing to link
from here when I mention its system calls — just some IDL sources in a Git
repository. An old <a href="https://github.com/WebAssembly/wasi-libc/blob/e9524a09/libc-bottom-half/headers/public/wasi/api.h"><code class="language-plaintext highlighter-rouge">wasi.h</code></a> was the most readable, complete
source of truth I could find.</p>

<p>Fortunately Wasm is old enough that <a href="/blog/2024/11/10/">LLMs</a> are well-versed in it, and
simply asking questions, or for usage examples, was more effective than
searching online. If you’re stumped on how to achieve something in the
Wasm ecosystem, try asking a state-of-the-art LLM for help.</p>

<h3 id="example-programs">Example programs</h3>

<p>Let’s go over concrete examples to lay some foundations. Consider this
simple C function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">norm</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">x</span><span class="o">*</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="o">*</span><span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To compile to Wasm (32-bit) with Clang, we use the <code class="language-plaintext highlighter-rouge">--target=wasm32</code>:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang -c --target=wasm32 -O example.c
</code></pre></div></div>

<p>The object file <code class="language-plaintext highlighter-rouge">example.o</code> is in Wasm format, so WABT can examine it.
Here’s the output of <code class="language-plaintext highlighter-rouge">wasm2wat -f</code>, where <code class="language-plaintext highlighter-rouge">-f</code> produces output in the
“folded” format, which is how I prefer to read it.</p>

<div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">module</span>
  <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">f32</span> <span class="nv">f32</span><span class="p">)</span> <span class="p">(</span><span class="nf">result</span> <span class="nv">f32</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">import</span> <span class="s">"env"</span> <span class="s">"__linear_memory"</span> <span class="p">(</span><span class="nf">memory</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">func</span> <span class="nv">$norm</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">f32</span> <span class="nv">f32</span><span class="p">)</span> <span class="p">(</span><span class="nf">result</span> <span class="nv">f32</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">f32</span><span class="o">.</span><span class="nv">add</span>
      <span class="p">(</span><span class="nf">f32</span><span class="o">.</span><span class="nv">mul</span>
        <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">))</span>
      <span class="p">(</span><span class="nf">f32</span><span class="o">.</span><span class="nv">mul</span>
        <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">1</span><span class="p">)))))</span>
</code></pre></div></div>

<p>We can see <a href="https://github.com/WebAssembly/tool-conventions/blob/main/BasicCABI.md">the ABI</a> taking shape: Clang has predictably mapped
<code class="language-plaintext highlighter-rouge">float</code> into <code class="language-plaintext highlighter-rouge">f32</code>. It similarly maps <code class="language-plaintext highlighter-rouge">char</code>, <code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">long</code>
onto <code class="language-plaintext highlighter-rouge">i32</code>. In 64-bit Wasm, the Clang ABI is LP64 and maps <code class="language-plaintext highlighter-rouge">long</code> onto
<code class="language-plaintext highlighter-rouge">i64</code>. There’s a also <code class="language-plaintext highlighter-rouge">$norm</code> function which takes two <code class="language-plaintext highlighter-rouge">f32</code> parameters
and returns an <code class="language-plaintext highlighter-rouge">f32</code>.</p>

<p>Getting a little more complex:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__attribute</span><span class="p">((</span><span class="n">import_name</span><span class="p">(</span><span class="s">"f"</span><span class="p">)))</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">);</span>

<span class="n">__attribute</span><span class="p">((</span><span class="n">export_name</span><span class="p">(</span><span class="s">"example"</span><span class="p">)))</span>
<span class="kt">void</span> <span class="nf">example</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">f</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">import_name</code> function attribute indicates the module will not define
it, even in another translation unit, and that it intends to import it.
That is, <code class="language-plaintext highlighter-rouge">wasm-ld</code> will place it in the import table. The <code class="language-plaintext highlighter-rouge">export_name</code>
function attribute indicates it’s an entry point, and so <code class="language-plaintext highlighter-rouge">wasm-ld</code> will
list it in the export table. Linking it will make things a little clearer:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang --target=wasm32 -nostdlib -Wl,--no-entry -O example.c
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">-nostdlib</code> is because we won’t be using a language runtime, and
<code class="language-plaintext highlighter-rouge">--no-entry</code> to tell the linker not to implicitly export a function
(default: <code class="language-plaintext highlighter-rouge">_start</code>) as an entry point. You might think this is connected
with the Wasm <em>start function</em>, but <code class="language-plaintext highlighter-rouge">wasm-ld</code> does not support the <em>start
section</em> at all! We’ll have use for an entry point later. The folded WAT:</p>

<div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">module</span> <span class="nv">$a</span><span class="o">.</span><span class="nv">out</span>
  <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">i32</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">import</span> <span class="s">"env"</span> <span class="s">"f"</span> <span class="p">(</span><span class="nf">func</span> <span class="nv">$f</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">0</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">func</span> <span class="nv">$example</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">local</span> <span class="nv">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">global</span><span class="o">.</span><span class="nv">set</span> <span class="nv">$__stack_pointer</span>
      <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">tee</span> <span class="mi">1</span>
        <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">sub</span>
          <span class="p">(</span><span class="nf">global</span><span class="o">.</span><span class="nv">get</span> <span class="nv">$__stack_pointer</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">16</span><span class="p">))))</span>
    <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">store</span> <span class="nv">offset=12</span>
      <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">1</span><span class="p">)</span>
      <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">call</span> <span class="nv">$f</span>
      <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">add</span>
        <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">12</span><span class="p">)))</span>
    <span class="p">(</span><span class="nf">global</span><span class="o">.</span><span class="nv">set</span> <span class="nv">$__stack_pointer</span>
      <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">add</span>
        <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">1</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">16</span><span class="p">))))</span>
  <span class="p">(</span><span class="nf">table</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="mi">1</span> <span class="mi">1</span> <span class="nv">funcref</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">memory</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="mi">2</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">global</span> <span class="nv">$__stack_pointer</span> <span class="p">(</span><span class="nf">mut</span> <span class="nv">i32</span><span class="p">)</span> <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">66560</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">export</span> <span class="s">"memory"</span> <span class="p">(</span><span class="nf">memory</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">export</span> <span class="s">"example"</span> <span class="p">(</span><span class="nf">func</span> <span class="nv">$example</span><span class="p">)))</span>
</code></pre></div></div>

<p>There’s a lot to unfold:</p>

<ul>
  <li>
    <p>Pointers were mapped onto <code class="language-plaintext highlighter-rouge">i32</code>. Pointers are a high-level concept, and
linear memory is addressed by an integral offset. This is typical of
assembly after all.</p>
  </li>
  <li>
    <p>There’s now a <code class="language-plaintext highlighter-rouge">__stack_pointer</code>, which is part of the Clang ABI, not
Wasm. The Wasm abstract machine is a stack machine, but that stack
doesn’t exist in linear memory. So you cannot take the address of values
on the Wasm stack. There are lots of things C needs from a stack that
Wasm doesn’t provide. So, <em>in addition to the Wasm stack</em>, Clang
maintains another downward-growing stack in linear memory for these
purposes, and the <code class="language-plaintext highlighter-rouge">__stack_pointer</code> global is the stack register of its
ABI. We can see it’s allocated something like 64kB for the stack. (It’s
a little more because program data is placed below the stack.)</p>
  </li>
  <li>
    <p>It should be mostly readable without knowing Wasm: The function
subtracts a 16-byte stack frame, stores a copy of the argument in it,
then uses its memory offset for the first parameter to the import <code class="language-plaintext highlighter-rouge">f</code>.
Why 16 bytes when it only needs 4? Because the stack is kept 16-byte
aligned. Before returning, the function restores the stack pointer.</p>
  </li>
</ul>

<p>As mentioned earlier, address zero is valid as far as the Wasm runtime is
concerned, though dereferences are still undefined in C. This makes it
more difficult to catch bugs. Given a null pointer this function would
most likely read a zero at address zero and the program keeps running:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="nf">get</span><span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="n">p</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In WAT:</p>

<div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="nf">func</span> <span class="nv">$get</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">i32</span><span class="p">)</span> <span class="p">(</span><span class="nf">result</span> <span class="nv">i32</span><span class="p">)</span>
  <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">load</span>
    <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">)))</span>
</code></pre></div></div>

<p>Since the “hardware” won’t fault for us, ask Clang to do it instead:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang ... -fsanitize=undefined -fsanitize-trap ...
</code></pre></div></div>

<p>Now in WAT:</p>

<div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">module</span>
  <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">i32</span><span class="p">)</span> <span class="p">(</span><span class="nf">result</span> <span class="nv">i32</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">import</span> <span class="s">"env"</span> <span class="s">"__linear_memory"</span> <span class="p">(</span><span class="nf">memory</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">func</span> <span class="nv">$get</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">i32</span><span class="p">)</span> <span class="p">(</span><span class="nf">result</span> <span class="nv">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">block</span>  <span class="c1">;; label = @1</span>
      <span class="p">(</span><span class="nf">block</span>  <span class="c1">;; label = @2</span>
        <span class="p">(</span><span class="nf">br_if</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">;@2;</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">eqz</span>
            <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="p">(</span><span class="nf">br_if</span> <span class="mi">1</span> <span class="p">(</span><span class="nf">;@1;</span><span class="p">)</span>
          <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">eqz</span>
            <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">and</span>
              <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">)</span>
              <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">3</span><span class="p">)))))</span>
      <span class="p">(</span><span class="nf">unreachable</span><span class="p">))</span>
    <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">load</span>
      <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">))))</span>
</code></pre></div></div>

<p>Given a null pointer, <code class="language-plaintext highlighter-rouge">get</code> executes the <code class="language-plaintext highlighter-rouge">unreachable</code> instruction,
causing the runtime to trap. In practice this is unrecoverable. Consider:
nothing will restore <code class="language-plaintext highlighter-rouge">__stack_pointer</code>, and so the stack will “leak” the
existing frames. (This can be worked around by exporting <code class="language-plaintext highlighter-rouge">__stack_pointer</code>
and <code class="language-plaintext highlighter-rouge">__stack_high</code> via the <code class="language-plaintext highlighter-rouge">--export</code> linker flag, then restoring the
stack pointer in the runtime after traps.)</p>

<p>Wasm was extended with <a href="https://github.com/WebAssembly/bulk-memory-operations">bulk memory operations</a>, and so there are
single instructions for <code class="language-plaintext highlighter-rouge">memset</code> and <code class="language-plaintext highlighter-rouge">memmove</code>, which Clang maps onto the
built-ins:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">clear</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buf</span><span class="p">,</span> <span class="kt">long</span> <span class="n">len</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">__builtin_memset</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>(<a href="https://releases.llvm.org/20.1.0/docs/ReleaseNotes.html#changes-to-the-webassembly-backend">Below LLVM 20</a> you will need the undocumented <code class="language-plaintext highlighter-rouge">-mbulk-memory</code>
option.) In WAT we see this as <code class="language-plaintext highlighter-rouge">memory.fill</code>:</p>

<div class="language-racket highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">(</span><span class="k">module</span>
  <span class="p">(</span><span class="nf">type</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="p">(</span><span class="nf">func</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">i32</span> <span class="nv">i32</span><span class="p">)))</span>
  <span class="p">(</span><span class="nf">import</span> <span class="s">"env"</span> <span class="s">"__linear_memory"</span> <span class="p">(</span><span class="nf">memory</span> <span class="p">(</span><span class="nf">;0;</span><span class="p">)</span> <span class="mi">0</span><span class="p">))</span>
  <span class="p">(</span><span class="nf">func</span> <span class="nv">$clear</span> <span class="p">(</span><span class="nf">type</span> <span class="mi">0</span><span class="p">)</span> <span class="p">(</span><span class="nf">param</span> <span class="nv">i32</span> <span class="nv">i32</span><span class="p">)</span>
    <span class="p">(</span><span class="nf">block</span>  <span class="c1">;; label = @1</span>
      <span class="p">(</span><span class="nf">br_if</span> <span class="mi">0</span> <span class="p">(</span><span class="nf">;@1;</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">eqz</span>
          <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">1</span><span class="p">)))</span>
      <span class="p">(</span><span class="nf">memory</span><span class="o">.</span><span class="nv">fill</span>
        <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">i32</span><span class="o">.</span><span class="nv">const</span> <span class="mi">0</span><span class="p">)</span>
        <span class="p">(</span><span class="nf">local</span><span class="o">.</span><span class="nv">get</span> <span class="mi">1</span><span class="p">)))))</span>
</code></pre></div></div>

<p>That’s great! I wish this worked so well outside of Wasm. It’s one reason
<a href="https://github.com/skeeto/w64devkit">w64devkit</a> has <code class="language-plaintext highlighter-rouge">-lmemory</code>, after all. Similarly <code class="language-plaintext highlighter-rouge">__builtin_trap()</code> maps
onto the <code class="language-plaintext highlighter-rouge">unreachable</code> instruction, so we can reliably generate those as
well.</p>

<p>What about structures? They’re passed by address. Parameter structures go
on the stack, then its address passed. To return a structure, a function
accepts an implicit <em>out</em> parameter in which to write the return. This
isn’t unusual, except that it’s challenging to manage across module
boundaries, i.e. in imports and exports, because caller and callee are in
different address spaces. It’s especially tricky to return a structure
from an export, as the caller must somehow allocate space in the callee’s
address space for the result. The <a href="https://github.com/WebAssembly/multi-value/blob/master/proposals/multi-value/Overview.md">multi-value extension</a>
solves this, but using it in C involves an ABI change, which is still
experimental.</p>

<h3 id="water-sort-game">Water Sort Game</h3>

<p>Something you might not have expected: My water sort game imports no
functions! It only exports three functions:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span>      <span class="nf">game_init</span><span class="p">(</span><span class="n">i32</span> <span class="n">seed</span><span class="p">);</span>
<span class="n">DrawList</span> <span class="o">*</span><span class="nf">game_render</span><span class="p">(</span><span class="n">i32</span> <span class="n">width</span><span class="p">,</span> <span class="n">i32</span> <span class="n">height</span><span class="p">,</span> <span class="n">i32</span> <span class="n">mousex</span><span class="p">,</span> <span class="n">i32</span> <span class="n">mousey</span><span class="p">);</span>
<span class="kt">void</span>      <span class="nf">game_update</span><span class="p">(</span><span class="n">i32</span> <span class="n">input</span><span class="p">,</span> <span class="n">i32</span> <span class="n">mousex</span><span class="p">,</span> <span class="n">i32</span> <span class="n">mousey</span><span class="p">,</span> <span class="n">i64</span> <span class="n">now</span><span class="p">);</span>
</code></pre></div></div>

<p>The game uses <a href="https://www.youtube.com/watch?v=DYWTw19_8r4">IMGUI-style</a> rendering. The caller passes in the
inputs, and the game returns a kind of <em>display list</em> telling it what to
draw. In the SDL version these turn into SDL renderer calls. In the web
version, these turn into canvas draws, and “mouse” inputs may be touch
events. It plays and feels the same on both platforms. Simple!</p>

<p>I didn’t realize it at the time, but building the SDL version first was
critical to my productivity. <strong>Debugging Wasm programs is really dang
hard!</strong> Wasm tooling has yet to catch up with 1995, let alone 2025.
Source-level debugging is still experimental and impractical. Developing
applications on the Wasm platform. It’s about as ergonomic as <a href="/blog/2018/04/13/">developing
in MS-DOS</a>. Instead, develop on a platform much better suited for
it, then <em>port</em> your application to Wasm after you’ve <a href="/blog/2025/02/05/">got the issues
worked out</a>. The less Wasm-specific code you write, the better, even
if it means writing more code overall. Treat it as you would some weird
embedded target.</p>

<p>The game comes with 10,000 seeds. I generated ~200 million puzzles, sorted
them by difficulty, and skimmed the top 10k most challenging. In the game
they’re still sorted by increading difficulty, so it gets harder as you
make progress.</p>

<h3 id="wasm-system-interface">Wasm System Interface</h3>

<p>WASI allows us to get a little more hands on. Let’s start with a Hello
World program. A WASI application exports a traditional <code class="language-plaintext highlighter-rouge">_start</code> entry
point which returns nothing and takes no arguments. I’m also going to set
up some basic typedefs:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="kt">unsigned</span> <span class="kt">char</span>       <span class="n">u8</span><span class="p">;</span>
<span class="k">typedef</span>   <span class="kt">signed</span> <span class="kt">int</span>        <span class="n">i32</span><span class="p">;</span>
<span class="k">typedef</span>   <span class="kt">signed</span> <span class="kt">long</span> <span class="kt">long</span>  <span class="n">i64</span><span class="p">;</span>
<span class="k">typedef</span>   <span class="kt">signed</span> <span class="kt">long</span>       <span class="n">iz</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">wasm-ld</code> will automatically export this function, so we don’t need an
<code class="language-plaintext highlighter-rouge">export_name</code> attribute. This program successfully does nothing:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang --target=wasm32 -nostdlib -o hello.wasm hello.c
$ wazero run hello.wasm &amp;&amp; echo ok
ok
</code></pre></div></div>

<p>To write output WASI defines <code class="language-plaintext highlighter-rouge">fd_write()</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">u8</span> <span class="o">*</span><span class="n">buf</span><span class="p">;</span>
    <span class="n">iz</span>  <span class="n">len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">IoVec</span><span class="p">;</span>

<span class="cp">#define WASI(s) __attribute((import_module("wasi_unstable"),import_name(s)))
</span><span class="n">WASI</span><span class="p">(</span><span class="s">"fd_write"</span><span class="p">)</span>  <span class="n">i32</span>  <span class="nf">fd_write</span><span class="p">(</span><span class="n">i32</span><span class="p">,</span> <span class="n">IoVec</span> <span class="o">*</span><span class="p">,</span> <span class="n">iz</span><span class="p">,</span> <span class="n">iz</span> <span class="o">*</span><span class="p">);</span>
</code></pre></div></div>

<p>Technically those <code class="language-plaintext highlighter-rouge">iz</code> variables are supposed to be <code class="language-plaintext highlighter-rouge">size_t</code>, passed
through Wasm as <code class="language-plaintext highlighter-rouge">i32</code>, but this is a foreign function, I know the ABI, and
so <a href="/blog/2023/05/31/">I can do as I please</a>. I absolutely love that WASI barely uses
null-terminated strings, not even for paths, which is a breath of fresh
air, but they still <a href="https://www.youtube.com/watch?v=wvtFGa6XJDU">marred the API with unsigned sizes</a>. Which I
choose to ignore.</p>

<p>This function is shaped like <a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/writev.html">POSIX <code class="language-plaintext highlighter-rouge">writev()</code></a>. I’ve also set it
up for import, including a module name. The oldest, most stable version of
WASI is called <code class="language-plaintext highlighter-rouge">wasi_unstable</code>. (I suppose it shouldn’t be surprising that
finding information in this ecosystem is difficult.)</p>

<p>Every returning WASI function returns an <code class="language-plaintext highlighter-rouge">errno</code> value, with zero as
success rather than some kind of <a href="/blog/2016/09/23/">in-band signaling</a>. Hence the
final out parameter unlike POSIX <code class="language-plaintext highlighter-rouge">writev()</code>.</p>

<p>Armed with this function, let’s use it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">u8</span>    <span class="n">msg</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"hello world</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">IoVec</span> <span class="n">iov</span>   <span class="o">=</span> <span class="p">{</span><span class="n">msg</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">};</span>
    <span class="n">iz</span>    <span class="n">len</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">fd_write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang --target=wasm32 -nostdlib -o hello.wasm hello.c
$ wazero run hello.wasm
hello world
</code></pre></div></div>

<p>Keep going and you’ll have <a href="/blog/2023/02/13/">something like <code class="language-plaintext highlighter-rouge">printf</code></a> before long. If
the write fails, we should probably communicate the error with at least
the exit status. Because <code class="language-plaintext highlighter-rouge">_start</code> doesn’t return a status, we need to
exit, for which we have <code class="language-plaintext highlighter-rouge">proc_exit</code>. It doesn’t return, so no <code class="language-plaintext highlighter-rouge">errno</code>
return value.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WASI</span><span class="p">(</span><span class="s">"proc_exit"</span><span class="p">)</span> <span class="kt">void</span> <span class="nf">proc_exit</span><span class="p">(</span><span class="n">i32</span><span class="p">);</span>

<span class="kt">void</span> <span class="nf">_start</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">i32</span> <span class="n">err</span> <span class="o">=</span> <span class="n">fd_write</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">iov</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">len</span><span class="p">);</span>
    <span class="n">proc_exit</span><span class="p">(</span><span class="o">!!</span><span class="n">err</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>To get the command line arguments, call <code class="language-plaintext highlighter-rouge">args_sizes_get</code> to get the size,
allocate some memory, then <code class="language-plaintext highlighter-rouge">args_get</code> to read the arguments. Same goes for
the environment with a similar pair of functions. The sizes do not include
a null pointer terminator, which is sensible.</p>

<p>Now that you know how to find and use these functions, you don’t need me
to go through each one. However, <em>opening files</em> is a special, complicated
case:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">WASI</span><span class="p">(</span><span class="s">"path_open"</span><span class="p">)</span> <span class="n">i32</span> <span class="nf">path_open</span><span class="p">(</span><span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="p">,</span><span class="n">u8</span><span class="o">*</span><span class="p">,</span><span class="n">iz</span><span class="p">,</span><span class="n">i32</span><span class="p">,</span><span class="n">i64</span><span class="p">,</span><span class="n">i64</span><span class="p">,</span><span class="n">i32</span><span class="p">,</span><span class="n">i32</span><span class="o">*</span><span class="p">);</span>
</code></pre></div></div>

<p>That’s 9 parameters — and I had thought <a href="https://learn.microsoft.com/en-us/windows/win32/api/fileapi/nf-fileapi-createfilew">Win32 <code class="language-plaintext highlighter-rouge">CreateFileW</code></a> was
over the top. It’s even more complex than it looks. It works more like
<a href="https://pubs.opengroup.org/onlinepubs/9799919799/functions/openat.html">POSIX <code class="language-plaintext highlighter-rouge">openat()</code></a>, except there’s no current working directory
and so no <code class="language-plaintext highlighter-rouge">AT_FDCWD</code>. Every file and directory is opened <em>relative to</em>
another directory, and absolute paths are invalid. If there’s no
<code class="language-plaintext highlighter-rouge">AT_FDCWD</code>, how does one open the <em>first</em> directory? That’s called a
<em>preopen</em> and it’s core to the file system security mechanism of WASI.</p>

<p>The Wasm runtime preopens zero or more directories before starting the
program and assigns them the lowest numbered file descriptors starting at
file descriptor 3 (after standard input, output, and error). A program
intending to use <code class="language-plaintext highlighter-rouge">path_open</code> must first traverse the file descriptors,
probing for preopens with <code class="language-plaintext highlighter-rouge">fd_prestat_get</code> and retrieving their path name
with <code class="language-plaintext highlighter-rouge">fd_prestat_dir_name</code>. This name may or may not map back onto a real
system path, and so this is a kind of virtual file system for the Wasm
module. The probe stops on the first error.</p>

<p>To open an absolute path, it must find a matching preopen, then from it
construct a path relative to that directory. This part I much dislike, as
the module must contain complex path parsing functionality even in the
simple case. Opening files is the most complex piece of the whole API.</p>

<p>I mentioned before that program data is below the Clang stack. With the
stack growing down, this sounds like a bad idea. A stack overflow quietly
clobbers your data, and is difficult to recognize. More sensible to put
the stack at the bottom so that it overflows off the bottom of memory and
causes a fast fault. Fortunately there’s a switch for that:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ clang --target=wasm32 ... -Wl,--stack-first ...
</code></pre></div></div>

<p>This is what you want by default. The actual default layout is left over
from an early design flaw in <code class="language-plaintext highlighter-rouge">wasm-ld</code>, and it’s an oversight that it has
not yet been corrected.</p>

<h3 id="u-config">u-config</h3>

<p>The above is in action in the <a href="https://github.com/skeeto/u-config/blob/0c86829e/main_wasm.c">u-config Wasm port</a>. You can download
the Wasm module, <a href="https://skeeto.github.io/u-config/pkg-config.wasm">pkg-config.wasm</a>, used in the web demo to run it in
your favorite WASI-capable Wasm runtime:</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ wazero run pkg-config.wasm --modversion pkg-config
0.33.3
</code></pre></div></div>

<p>Though there are no preopens, so it cannot read any files. The <code class="language-plaintext highlighter-rouge">-mount</code>
option maps real file system paths to preopens. This mounts the entire
root file system read-only (<code class="language-plaintext highlighter-rouge">ro</code>) as <code class="language-plaintext highlighter-rouge">/</code>.</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>$ wazero run -mount /::ro pkg-config.wasm --cflags sdl2
-I/usr/include/SDL2 -D_REENTRANT
</code></pre></div></div>

<p>I doubt this is useful for anything, but it was a vehicle for learning and
trying Wasm, and the results are pretty neat.</p>

<p>In the next article I discuss <a href="/blog/2025/04/19/">allocating the allocator</a>.</p>


    