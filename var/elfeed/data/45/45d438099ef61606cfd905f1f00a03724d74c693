
<p>The new revision of <a href="https://codeberg.org/gustedt/ellipsis">eĿlipsis</a> (<code>20250219</code>) has a lot of cleanups, bugfixes etc, but one thing I&#8217;d like to emphasize is a new feature that I&#8217;d call meta-quotes in lack for a better idea of a name that implement exemption of tokens from macro replacement. So in C that would interact with translation phase 4.</p>



<p>The idea is to have two new quote characters <code>⸤</code> and <code>⸥</code> that protect everything between them to be macro expanded.</p>



<span id="more-4290"></span>



<div class="wp-block-jetpack-markdown"><p>When, after lexing, the input tokens are filtered by a C-like preprocessor, a nominal (identifier in C speak) that correspond to the name of a macro is expanded. C only has two exceptions from this:</p>
<ul>
<li>If the current filtering is the expansion of a macro named <code>ID</code>, other occurrences of that same name <code>ID</code> are not expanded. So preprocessing has no normal recursion.</li>
<li>If a macro name <code>ID</code> of a functional macro (that is a macro with a   parameter list) occurs and that name is not followed by an opening  parenthesis (possibly preceded by whitespace) then this token is not  expanded, either.</li>
</ul>
<p>The lack of the possibility to protect other nominals can result in a lot of irritation in contexts where names of identifiers are glued together by means of the token join operator <code>⨝</code> (<code>##</code> in C). You’d see things such as the following quite commonly in preprocessor
oriented C headers:</p>
</div>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
#define MYFUNC(F) hurlipurtz ## F
</pre></div>

<p>The user then expects the following</p>

<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
    void* MYFUNC(getone)();
</pre></div>

<p>to expand to</p>

<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
    void* hurlipurtzgetone();
</pre></div>


<p>But in fact it wouldn&#8217;t always. If this code is located in a header and another header is included that would define <code>hurlipurtz</code> to expand to <code>schnurtz</code>, the above function declaration would read.</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: plain; title: ; notranslate">
    void* schnurtzgetone();
</pre></div>


<p>not at all what was intended. Obviously for the given example this is highly unlikely but the smaller the name components that are used get, the higher the probability of collision. For example a lot of code would use the token <code>_</code> to glue together two name components, so whenever some smart colleague thinks they should overload that token with something funny, you are in trouble.</p>



<p>To protect against this effect, as an extension, eĿlipsis adds a third method for identifier protection, the <code>keep</code> and <code>peek</code> brackets <code>⸤</code> and <code>⸥</code>. Rewritten with these, the above definition would look</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
#define MYFUNC(F) ⸤hurlipurtz⸥ ## F
</pre></div>


<p>That is, here the funny brackets (<strong>BOTTOM LEFT HALF BRACKET</strong> and <strong>BOTTOM RIGHT HALF BRACKET</strong>) protect the nominal <code>hurlipurtz</code> to be expanded when <code>MYFUNC</code> is used. If you are programming in C and are allergic to Unicode characters you could also use the digraphs <code>&lt;|</code> and <code>|&gt;</code> that replace them.</p>



<p>These brackets have the following properties</p>



<ul class="wp-block-list">
<li>They don&#8217;t interact with tokenization. That is, the input stream is split up into tokens, first, and possible <code>keep</code> and <code>peek</code> brackets are identified during that process as tokens of their own. They only take their special role in the next phase, filtering, when macros are expanded and directives are interpreted.</li>



<li>During filtering they apply to arbitrary long sequences of tokens where they protect all nominals that appear in the sequence.</li>



<li>They can be nested as long <code>keep</code> and <code>peek</code> brackets nest properly.</li>



<li>If a construct appears between these brackets that is normally ended by an EOL character, the construct extends to the end of the outermost pair of <code>keep</code> and <code>peek</code> brackets.</li>
</ul>



<p>The latter can be in particular be useful for long macro definition that go over multiple lines</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
&lt;|
#define SWAP(NAME, T)
 ⸤void⸥ NAME ## ⸤_swap⸥(T* ⸤a⸥, T* ⸤b⸥) {
    T* ⸤tmp⸥ = ⸤a⸥;
    ⸤a⸥ = ⸤b⸥;
    ⸤b⸥ = ⸤tmp⸥;
 }
|&gt;
</pre></div>


<p>or equivalently</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
&lt;|
#define SWAP(NAME, T)
 ⸤void NAME ## _swap(T* a, T* b) {⸥
    ⸤T* tmp = a;⸥
    ⸤a = b;⸥
    ⸤b = tmp;⸥
 ⸤}⸥
|&gt;
</pre></div>


<p>or even</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: plain; title: ; notranslate">
&lt;|
#define SWAP(NAME, T)
 &lt;|void NAME ## _swap(T* a, T* b) {
    T* tmp = a;
    a = b;
    b = tmp;
 }|&gt;
|&gt;
</pre></div>


<p>Such a definition ensures that the text editor (IDE whatever) basically sees a function, and thus code indentation and highlighting should work as expected. The nested used of <code>keep</code> and <code>peek</code> brackets then also guarantees that the local identifiers <code>a</code>, <code>b</code> and <code>tmp</code> are not accidentally overwritten during macro expansion. So using this macro as <code>SWAP(fine, well)</code> would expand to</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
void fine_swap(well* a, well* b) {
    well* tmp = a;
    a = b;
    b = tmp;
}
</pre></div>


<p>regardless if somebody had defined a macro <code>tmp</code> before or not.</p>



<p>This new release of  eĿlipsis uses this new feature extensively in a completely revisited implementation of <a href="https://gustedt.gitlabpages.inria.fr/ellipsis/extensions.html#defer_desc">the <code>defer</code> feature</a> that should be quite robust now and that closely follows the bracketed structure of C (for brackets, braces and parenthesis). Namely there is now a feature (in C) to glue callbacks to this syntactic structure of the code called <code><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/ellipsis-blockstate_8h.html">BLOCKSTATE</a></code> that automatically tracks integer values that are associated to different levels. For example a macro invocation</p>


<div class="wp-block-syntaxhighlighter-code "><pre class="brush: cpp; title: ; notranslate">
__BLOCKSTATE_TST(MINE)
</pre></div>


<p>would check if a <code>MINE</code> value is set for the current level of <code>{}</code> (called <code>BRACE_LEVEL</code>) of <code>()</code> (called <code>__PARENTHESIS_DEPTH__</code>) and of <code>[]</code> (called <code>__BRACKET_LEVEL__</code>) and return that value or <code>0</code> if there wasn&#8217;t one, yet. Similarly there are macros <code>__BLOCKSTATE_SET0</code>, <code>__BLOCKSTATE_INC</code> etc to manipulate state that depends on the current block structure of the program.</p>



<p>The <code>defer</code> implementation uses this feature for example to keep track if the current level of braces is the body of a <code>for</code>-loop or rather a <code>switch</code> to deduce if an unwind of deferred blocks for a <code>continue</code> statement ends on this level of braces or has to go down on the next level.</p>



<p>To implement all of this, the new meta-quote feature has been really helpful. Otherwise I would easily have been lost in the expansion (or not) of all the name components that are glued together in that code.</p>



<p>Last but not least I&#8217;d also like to note that the eĿlipsis project is now to be found at <a href="https://codeberg.org">Codeberg</a> at </p>



<p class="has-text-align-center"><a href="https://codeberg.org/gustedt/ellipsis/">https://codeberg.org/gustedt/ellipsis/</a></p>



<p>Being previously at the gitlab of my employer, INRIA, has not proven to be much helpful. I am very grateful to the Codeberg initiative for providing such an open and free platform for open source development. If you don&#8217;t have an account there yet, go and get it.</p>



<p>The online documentation is still at the INRIA site, so the link hasn&#8217;t changed:</p>



<p class="has-text-align-center"><a href="https://gustedt.gitlabpages.inria.fr/ellipsis/">https://gustedt.gitlabpages.inria.fr/ellipsis/</a></p>
