<html><head></head><body><p><em>Note: This article series was written by me, with LLMs helping to refine the style and structure.</em></p>
<p><a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part1-pain-points">Part 1</a> identified the problems. <a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part2-ergonomics">Part 2</a> covered ergonomics. <a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part3-abstractions">Part 3</a> showed coordination patterns.</p>
<p>This article covers tools that became obsolete, workflows that didn’t pan out, and lessons learned from building at the edge of what works.</p>
<p><strong>Series Navigation:</strong> <a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part3-abstractions">← Part 3: Abstractions</a> | <a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part5-learning">Part 5: Learning →</a></p>
<h2>
  The Project Ingester: Solving Yesterday’s Problem
  <a href="#the-project-ingester-solving-yesterdays-problem">
    <i></i>
  </a>
</h2>
<p>Before Sonnet 4.5, exploring a codebase was slow. Reading 20 files meant 20 sequential API calls and 10+ minutes of setup time.</p>
<p>I built <code>project-ingest</code> to solve this—output a single markdown document with project structure, key file contents, and dependency graph. Claude could ingest it in one shot instead of reading files incrementally.</p>
<p><strong>Before (Sonnet 3.5):</strong></p>
<ul>
<li>Run <code>project-ingest</code> → 15 seconds</li>
<li>Claude reads summary → 5 seconds</li>
<li><strong>Total:</strong> 20 seconds</li>
</ul>
<p><strong>After (Sonnet 4.5):</strong></p>
<ul>
<li>Claude reads 20 files directly → 8 seconds</li>
<li><strong>Total:</strong> 8 seconds</li>
</ul>
<p>The tool became slower than the problem it solved.</p>
<h3>
  When It’s Still Useful
  <a href="#when-its-still-useful">
    <i></i>
  </a>
</h3>
<p>I haven’t deleted it. It’s valuable for:</p>
<ol>
<li><strong>Very large codebases</strong> (100+ files) - still faster for high-level view</li>
<li><strong>Project snapshots</strong> - capturing state at a point in time</li>
<li><strong>Documentation</strong> - overview for human readers</li>
<li><strong>Cross-project analysis</strong> - comparing architecture</li>
</ol>
<p>But for everyday “help me understand this project” tasks? Obsolete.</p>
<h3>
  The Lesson
  <a href="#the-lesson">
    <i></i>
  </a>
</h3>
<p>Build for today’s constraints. The tool was perfect for its time. Model improvements made it unnecessary. That’s success, not failure.</p>
<h2>
  Code Review Logger: Decoupling Discovery from Fixing
  <a href="#code-review-logger-decoupling-discovery-from-fixing">
    <i></i>
  </a>
</h2>
<p>When LLMs generate code at scale, you produce a lot of code fast. Too fast to carefully review every change in real-time.</p>
<p>The problem: I’m reading through hundreds of lines of Claude-generated code. I spot issues—unclear function names, generic error handling, repeated patterns. But I’m in discovery mode, trying to understand the whole picture. Stopping to craft detailed prompts for each fix kills momentum.</p>
<p>What I need: a fast way to point and give hints to steer in the right direction, then batch all the corrections and let Claude work on them later.</p>
<p>The workflow:</p>
<ol>
<li>Mark issues at exact lines while browsing</li>
<li>Keep reading without losing flow</li>
<li>Later, batch all issues together and have Claude fix them</li>
</ol>
<h3>
  The Emacs Integration
  <a href="#the-emacs-integration">
    <i></i>
  </a>
</h3>
<p>I built <code>code-review-logger.el</code>:</p>
<div class="highlight"><pre><code class="language-elisp"><span><span><span>;; While reviewing code in Emacs:</span>
</span></span><span><span><span>;; SPC r c - Log comment at current line</span>
</span></span><span><span><span>;; SPC r r - Log comment for selected region</span>
</span></span><span><span><span>;; SPC r o - Open review log</span>
</span></span><span><span>
</span></span><span><span>(<span>defun</span> <span>code-review-log-comment</span> (<span>comment</span>)
</span></span><span><span>  <span>"Log a review comment with file/line tracking"</span>
</span></span><span><span>  (<span>let*</span> ((<span>file</span> (<span>buffer-file-name</span>))
</span></span><span><span>         (<span>line</span> (<span>line-number-at-pos</span>)))
</span></span><span><span>    (<span>code-review-format-entry</span> <span>comment</span> <span>file</span> <span>line</span> <span>"TODO"</span>)))
</span></span></code></pre></div><p>This creates entries in <code>~/code_review.org</code>:</p>
<div class="highlight"><pre><code class="language-org"><span><span><span>**</span> TODO [[file:~/repos/memento/src/cli.py::127][cli.py:127]]
</span></span><span><span><span>   :PROPERTIES:
</span></span></span><span><span><span></span><span>   :PROJECT: memento
</span></span></span><span><span><span>   :TIMESTAMP: [2025-09-30 Mon 14:23]
</span></span></span><span><span><span></span><span>   :END:</span>
</span></span><span><span>   This error handling is too generic - catch specific exceptions
</span></span><span><span>
</span></span><span><span><span>**</span> TODO [[file:~/repos/memento/src/search.py::89][search.py:89]]
</span></span><span><span><span>   :PROPERTIES:
</span></span></span><span><span><span></span><span>   :PROJECT: memento
</span></span></span><span><span><span>   :TIMESTAMP: [2025-09-30 Mon 14:25]
</span></span></span><span><span><span></span><span>   :END:</span>
</span></span><span><span>   Add caching here - search is called repeatedly with same query
</span></span></code></pre></div><h3>
  The Workflow
  <a href="#the-workflow">
    <i></i>
  </a>
</h3>
<ol>
<li>Review code in Emacs (syntax highlighting, jump-to-def, all IDE features)</li>
<li>Mark issues as I find them (<code>SPC r c</code> for quick comment)</li>
<li>Trigger the automated fix process: <code>Read code-review-llm-prompt-template and follow it</code></li>
<li>Claude automatically:
<ul>
<li>Reads <code>~/code_review.org</code> for all TODO items</li>
<li>Fixes each issue in the actual code</li>
<li>Runs <code>make test</code> after every change</li>
<li>Marks items as DONE only when tests pass</li>
</ul>
</li>
</ol>
<p>The entire workflow is encoded in a memento note that Claude reads. Contains:</p>
<ul>
<li>Review format specification</li>
<li>Priority order (correctness → architecture → security → performance)</li>
<li>Testing requirements (always run <code>make test</code>, never leave tests failing)</li>
<li>Complete fix-and-verify process</li>
</ul>
<h3>
  Why This Works
  <a href="#why-this-works">
    <i></i>
  </a>
</h3>
<p><strong>Batch processing</strong> is more efficient than interactive fixes:</p>
<ul>
<li>Claude sees all issues at once, plans holistically</li>
<li>No back-and-forth during fixing</li>
<li>Tests run after every change</li>
<li>Clear audit trail</li>
</ul>
<p><strong>Emacs integration</strong> solves the “review without IDE” problem:</p>
<ul>
<li>In my editor with all tools</li>
<li>Jump to definitions, search references, check blame</li>
<li>Clickable org links to code</li>
</ul>
<p><strong>Structured format</strong> means precise instructions:</p>
<ul>
<li>Exact file paths and line numbers</li>
<li>Context about the issue</li>
<li>Project name for multi-repo workflows</li>
</ul>
<h3>
  Current State
  <a href="#current-state">
    <i></i>
  </a>
</h3>
<p>Fully automated for the fix workflow. I just say: <code>Read code-review-llm-prompt-template and follow it</code></p>
<p>Claude then processes all TODO items, fixes issues, runs tests, marks items DONE. Never leaves the codebase with failing tests.</p>
<h2>
  Key Learnings
  <a href="#key-learnings">
    <i></i>
  </a>
</h2>
<p><strong>Embrace obsolescence.</strong> If a tool becomes unnecessary because the problem disappeared, that’s progress.</p>
<p><strong>Perfect is the enemy of done.</strong> The code review logger works even though it’s not fully automated. Ship it.</p>
<p><strong>Build for constraints, not aspirations.</strong> Don’t future-proof. Solve today’s problem with today’s constraints.</p>
<p><strong>Fast feedback beats comprehensive coverage.</strong> Quick hints during review, batch fixes later. Speed of iteration matters more than perfection.</p>
<h2>
  The Future: Moving Beyond Supervision
  <a href="#the-future-moving-beyond-supervision">
    <i></i>
  </a>
</h2>
<p>The pattern of tools becoming obsolete points to something bigger. Right now, I’m building tools to supervise one or more LLMs working together. But this is a transitional phase.</p>
<p>We’re moving toward a different form of collaboration—one where we identify the tasks that absolutely have to come from a human, and delegate everything else.</p>
<p>What must remain human:</p>
<ul>
<li><strong>Steering direction</strong>: What problem are we actually solving?</li>
<li><strong>Final decisions on UX</strong>: How should this feel to users?</li>
<li><strong>Architectural trade-offs</strong>: What complexity is worth accepting?</li>
<li><strong>Quality standards</strong>: What level of polish matters for this?</li>
</ul>
<p>What LLMs can increasingly handle:</p>
<ul>
<li>Implementation details</li>
<li>Test coverage</li>
<li>Documentation</li>
<li>Refactoring</li>
<li>Performance optimization</li>
<li>Debugging</li>
</ul>
<p>The project ingester became obsolete because models got faster at reading files. The code review logger works because it focuses my human effort on spotting issues, not fixing them. The pattern: <strong>human judgment for direction, LLM execution for implementation</strong>.</p>
<p>As models improve, the boundary shifts. Tasks that require human oversight today become fully automated tomorrow. The tools we build now are scaffolding—useful for this moment, likely obsolete soon.</p>
<h3>
  The Societal Challenge
  <a href="#the-societal-challenge">
    <i></i>
  </a>
</h3>
<p>But we can’t ignore the larger implications. This shift isn’t just about productivity—it’s about what happens to the people whose expertise becomes less essential.</p>
<p>What does it mean when:</p>
<ul>
<li>Junior developers find fewer entry-level opportunities because LLMs handle beginner tasks?</li>
<li>Mid-level engineers see their core skills automated away faster than they can adapt?</li>
<li>The gap between “steering direction” and “writing code” leaves fewer rungs on the career ladder?</li>
</ul>
<p>The technical solutions—better tools, better workflows—are the easy part. The hard questions are political and societal:</p>
<p><strong>How do we ensure the gains from AI-augmented productivity are distributed fairly?</strong> If a small group of people supervising LLMs can do the work that previously required large teams, who benefits from that efficiency? The workers who are displaced, or the companies and shareholders who capture the value?</p>
<p><strong>What safety nets and retraining programs do we need?</strong> The pace of change is faster than traditional education and career transitions can handle. Moving people from “implementer” to “director” roles requires more than technical training—it requires fundamentally different skills and mindsets.</p>
<p><strong>How do we preserve the learning paths that create expertise?</strong> If LLMs handle all junior-level work, how do people develop the judgment needed for senior roles? Expertise comes from doing, debugging, and making mistakes. When those learning opportunities disappear, where do the next generation of experts come from?</p>
<p>I don’t have answers to these questions. I’m optimizing my own workflow, building tools that make me more productive. But I recognize that scaling these patterns across the industry has consequences beyond individual efficiency gains.</p>
<p>For a deeper exploration of where this trajectory leads, I recommend reading <a href="https://ai-2027.com/race">The Race to AI Supremacy</a>—it examines the broader societal and political implications of rapidly advancing AI capabilities.</p>
<p>The tools becoming obsolete is progress. But progress for whom, and at what cost? Those are questions we need to grapple with collectively, not just as individuals optimizing our workflows.</p>
<h2>
  What’s Next
  <a href="#whats-next">
    <i></i>
  </a>
</h2>
<p><strong>Part 5</strong> covers using Claude as a learning tool: generating flashcards, creating annotated worksheets, and building a spaced-repetition system for technical concepts.</p>
<hr>
<p><strong>Continue Reading:</strong> <a href="https://blog.laurentcharignon.com/post/2025-09-30-llm-workflow-part5-learning">Part 5: Learning and Knowledge Accumulation →</a></p>
<hr>
<p><em>If you’re interested in any of the tools or patterns mentioned in this series, feel free to reach out. I’m happy to discuss what you find compelling and share more details.</em></p>
</body></html>