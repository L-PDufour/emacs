<p><a href="https://en.wikipedia.org/wiki/Wavefront_.obj_file">Wavefront OBJ</a> is a line-oriented, text format for 3D geometry. It’s
widely supported by modeling software, easy to parse, and trivial to emit,
much like <a href="/blog/2017/11/03/">Netpbm for 2D image data</a>. Poke around hobby 3D graphics
projects and you’re likely to find a bespoke OBJ parser. While typically
only loading their own model data, so robustness doesn’t much matter, they
usually have hard limitations and don’t stand up to <a href="/blog/2025/02/05/">fuzz testing</a>.
This article presents a robust, partial OBJ parser in C with no hard-coded
limitations, written from scratch. Like <a href="/blog/2025/01/19/">similar articles</a>, it’s not
<em>really</em> about OBJ but demonstrating some techniques you’ve probably never
seen before.</p>

<p>If you’d like to see the ready-to-run full source: <a href="https://github.com/skeeto/scratch/blob/master/misc/objrender.c"><code class="language-plaintext highlighter-rouge">objrender.c</code></a>.
All images are screenshots of this program.</p>

<p>First let’s establish the requirements. By <em>robust</em> I mean no undefined
behavior for any input, valid or invalid; no out of bounds accesses, no
signed overflows. Input is otherwise not validated. Invalid input may load
as valid by chance, which will render as either garbage or nothing. The
behavior will also not vary by locale.</p>

<p>We’re also only worried about vertices, normals, and triangle faces with
normals. In OBJ these are <code class="language-plaintext highlighter-rouge">v</code>, <code class="language-plaintext highlighter-rouge">vn</code>, and <code class="language-plaintext highlighter-rouge">f</code> elements. Normals let us
light the model effectively while checking our work. A cube fitting this
subset of OBJ might look like:</p>

<pre><code class="language-obj">v  -1.00 -1.00 -1.00
v  -1.00 +1.00 -1.00
v  +1.00 +1.00 -1.00
v  +1.00 -1.00 -1.00
v  -1.00 -1.00 +1.00
v  -1.00 +1.00 +1.00
v  +1.00 +1.00 +1.00
v  +1.00 -1.00 +1.00

vn +1.00  0.00  0.00
vn -1.00  0.00  0.00
vn  0.00 +1.00  0.00
vn  0.00 -1.00  0.00
vn  0.00  0.00 +1.00
vn  0.00  0.00 -1.00

f   3//1  7//1  8//1
f   3//1  8//1  4//1
f   1//2  5//2  6//2
f   1//2  6//2  2//2
f   7//3  3//3  2//3
f   7//3  2//3  6//3
f   4//4  8//4  5//4
f   4//4  5//4  1//4
f   8//5  7//5  6//5
f   8//5  6//5  5//5
f   3//6  4//6  1//6
f   3//6  1//6  2//6
</code></pre>

<p><img src="/img/objrender/cube.png" alt="" /></p>

<p>Take note:</p>

<ul>
  <li>Some fields are separated by more than one space.</li>
  <li>Vertices and normals are fractional (floating point).</li>
  <li>Faces use 1-indexing instead of 0-indexing.</li>
  <li>Faces in this model lack a texture index, hence <code class="language-plaintext highlighter-rouge">//</code> (empty).</li>
</ul>

<p>Inputs may have other data, but we’ll skip over it, including face texture
indices, or face elements beyond the third. Some of the models I’d like to
test have <em>relative</em> indices, so I want to support those, too. A relative
index refers <em>backwards</em> from the last vertex, so the order of the lines
in an OBJ matter. For example, the cube faces above could have instead
been written:</p>

<pre><code class="language-obj">f  -6//-6 -2//-6 -1//-6
f  -6//-6 -1//-6 -5//-6
f  -8//-5 -4//-5 -3//-5
f  -8//-5 -3//-5 -7//-5
f  -2//-4 -6//-4 -7//-4
f  -2//-4 -7//-4 -3//-4
f  -5//-3 -1//-3 -4//-3
f  -5//-3 -4//-3 -8//-3
f  -1//-2 -2//-2 -3//-2
f  -1//-2 -3//-2 -4//-2
f  -6//-1 -5//-1 -8//-1
f  -6//-1 -8//-1 -7//-1
</code></pre>

<p>Due to this the parser cannot be blind to line order, and it must handle
negative indices. Relative indexing has the nice effect that we can group
faces, and those groups are <em>relocatable</em>. We can reorder them without
renumbering the faces, or concatenate models just by concatenating their
OBJ files.</p>

<h3 id="the-fundamentals">The fundamentals</h3>

<p>To start off, we’ll be <a href="/blog/2023/09/27/">using an arena</a> of course, trivializing
memory management while swiping aside all hard-coded limits. A quick
reminder of the interface:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define new(a, n, t)    (t *)alloc(a, n, sizeof(t), _Alignof(t))
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beg</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Arena</span><span class="p">;</span>

<span class="c1">// Always returns an aligned pointer inside the arena. Allocations are</span>
<span class="c1">// zeroed. Does not return on OOM (never returns a null pointer).</span>
<span class="kt">void</span> <span class="o">*</span><span class="nf">alloc</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">count</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">size</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">align</span><span class="p">);</span>
</code></pre></div></div>

<p>Also, no null terminated strings, perhaps the main source of problems with
bespoke parsers.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define S(s)    (Str){s, sizeof(s)-1}
</span>
<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">char</span>     <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Str</span><span class="p">;</span>
</code></pre></div></div>

<p>Pointer arithmetic is error prone, so the tricky stuff is relegated to a
handful of functions, each of which can be exhaustively validated almost
at a glance:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Str</span> <span class="nf">span</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">beg</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">end</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Str</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">r</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">beg</span><span class="p">;</span>
    <span class="n">r</span><span class="p">.</span><span class="n">len</span>  <span class="o">=</span> <span class="n">beg</span> <span class="o">?</span> <span class="n">end</span><span class="o">-</span><span class="n">beg</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">_Bool</span> <span class="nf">equals</span><span class="p">(</span><span class="n">Str</span> <span class="n">a</span><span class="p">,</span> <span class="n">Str</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="o">==</span><span class="n">b</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="o">!</span><span class="n">a</span><span class="p">.</span><span class="n">len</span> <span class="o">||</span> <span class="o">!</span><span class="n">memcmp</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">len</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">Str</span> <span class="nf">trimleft</span><span class="p">(</span><span class="n">Str</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="o">&lt;=</span><span class="sc">' '</span><span class="p">;</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="o">++</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Str</span> <span class="nf">trimright</span><span class="p">(</span><span class="n">Str</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span> <span class="o">&amp;&amp;</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">&lt;=</span><span class="sc">' '</span><span class="p">;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="o">--</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Str</span> <span class="nf">substring</span><span class="p">(</span><span class="n">Str</span> <span class="n">s</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">i</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">s</span><span class="p">.</span><span class="n">data</span> <span class="o">+=</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">s</span><span class="p">.</span><span class="n">len</span>  <span class="o">-=</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Each avoids the purposeless special cases around null pointers (i.e.
zero-initialized <code class="language-plaintext highlighter-rouge">Str</code> objects) that would otherwise work out naturally.
The space character and all control characters are treated as whitespace
for simplicity. When I started writing this parser, I didn’t define all
these functions up front. I defined them as needed. (A <a href="/blog/2023/02/11/">good standard
library</a> would have provided similar definitions out-of-the-box.) If
you’re worried about misuse, add the appropriate assertions.</p>

<p>A powerful and useful string function I’ve discovered, and which I use in
every string-heavy program, is <code class="language-plaintext highlighter-rouge">cut</code>, a concept I shamelessly stole <a href="https://pkg.go.dev/strings#Cut">from
the Go standard library</a>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Str</span>   <span class="n">head</span><span class="p">;</span>
    <span class="n">Str</span>   <span class="n">tail</span><span class="p">;</span>
    <span class="kt">_Bool</span> <span class="n">ok</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Cut</span><span class="p">;</span>

<span class="n">Cut</span> <span class="nf">cut</span><span class="p">(</span><span class="n">Str</span> <span class="n">s</span><span class="p">,</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Cut</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="k">return</span> <span class="n">r</span><span class="p">;</span>  <span class="c1">// null pointer special case</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">beg</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">end</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span> <span class="o">+</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">cut</span> <span class="o">=</span> <span class="n">beg</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">cut</span><span class="o">&lt;</span><span class="n">end</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">cut</span><span class="o">!=</span><span class="n">c</span><span class="p">;</span> <span class="n">cut</span><span class="o">++</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">r</span><span class="p">.</span><span class="n">ok</span>   <span class="o">=</span> <span class="n">cut</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span>
    <span class="n">r</span><span class="p">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">span</span><span class="p">(</span><span class="n">beg</span><span class="p">,</span> <span class="n">cut</span><span class="p">);</span>
    <span class="n">r</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">span</span><span class="p">(</span><span class="n">cut</span><span class="o">+</span><span class="n">r</span><span class="p">.</span><span class="n">ok</span><span class="p">,</span> <span class="n">end</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>It slices, it dices, it juliennes! Need to iterate over lines? Cut it up:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Cut</span> <span class="n">c</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">c</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">input</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">c</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="sc">'\n'</span><span class="p">);</span>
        <span class="n">Str</span> <span class="n">line</span> <span class="o">=</span> <span class="n">c</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
        <span class="c1">// ... process line ...</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>Need to iterate over the fields in a line? Cut the line on the field
separator. Then cut the field on the element separator. No allocation, no
mutation (<code class="language-plaintext highlighter-rouge">strtok</code>).</p>

<h3 id="reading-input">Reading input</h3>

<p>Unlike <a href="/blog/2025/02/17/">a program designed to process arbitrarily large inputs</a>, the
intention here is to load the entire model into memory. We don’t need to
fiddle around with loading a line of input at at time (<code class="language-plaintext highlighter-rouge">fgets</code>, <code class="language-plaintext highlighter-rouge">getline</code>,
etc.) — the usual approach with OBJ parsers. If the OBJ source cannot fit
in memory, then the model won’t fit in memory. This greatly simplifies the
parser, not to mention faster while lifting hard-coded limits like maximum
line length.</p>

<p>The simple arena I use makes whole-file loading <em>so easy</em>. Read straight
into the arena without checking the file size (<code class="language-plaintext highlighter-rouge">ftell</code>, etc.), which means
streaming inputs (i.e. pipes) work automatically.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Str</span> <span class="nf">loadfile</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">f</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Str</span> <span class="n">r</span>  <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">r</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">;</span>
    <span class="n">r</span><span class="p">.</span><span class="n">len</span>  <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">;</span>
    <span class="n">r</span><span class="p">.</span><span class="n">len</span>  <span class="o">=</span> <span class="n">fread</span><span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">f</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Without buffered input, you may need a loop around the read:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Str</span> <span class="nf">loadfile</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fd</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Str</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">r</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">beg</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span> <span class="n">cap</span> <span class="o">=</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">end</span> <span class="o">-</span> <span class="n">a</span><span class="o">-&gt;</span><span class="n">beg</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="kt">ptrdiff_t</span> <span class="n">r</span> <span class="o">=</span> <span class="n">read</span><span class="p">(</span><span class="n">fd</span><span class="p">,</span> <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="o">+</span><span class="n">r</span><span class="p">.</span><span class="n">len</span><span class="p">,</span> <span class="n">cap</span><span class="o">-</span><span class="n">r</span><span class="p">.</span><span class="n">len</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">r</span><span class="p">;</span>  <span class="c1">// ignoring read errors</span>
        <span class="p">}</span>
        <span class="n">r</span><span class="p">.</span><span class="n">len</span> <span class="o">+=</span> <span class="n">r</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>You might consider triggering an out-of-memory error if the arena was
filled to the brim, which almost certainly means the input was truncated.
Though that’s likely to happen anyway because the next allocation from
that arena will fail.</p>

<p>Side note: When using a multi GB arena, issuing such huge read requests
stress tests the underlying IO system. I’ve found libc bugs this way. In
this case I <a href="/blog/2023/01/08/">used SDL2</a> for the demo, and SDL lost the ability to
read files after I increased the arena size to 4GB in order to test a
<a href="https://casual-effects.com/data/">gigantic model</a> (“Power Plant”). I’ve run into this before, and
I assumed it was another Microsoft CRT bug. After investigating deeper for
this article, I learned it’s an ancient SDL bug that’s made it all the way
into SDL3. <code class="language-plaintext highlighter-rouge">-Wconversion</code> warns about it, but <a href="https://github.com/libsdl-org/SDL-historical-archive/commit/e6ab3592e">was accidentally squelched
in the 64-bit port back in 2009</a>. It seems nobody else loads files
this way, so watch out for platform bugs if you use this technique!</p>

<h3 id="parsing-data">Parsing data</h3>

<p>In practice, rendering systems limit counts to the 32-bit range, which is
reasonable. So in the OBJ parser, vertex and normal indices will be 32-bit
integers. Negatives will be needed for at least relative indexing. Parsing
from a <code class="language-plaintext highlighter-rouge">Str</code> means null-terminated functions like <code class="language-plaintext highlighter-rouge">strtol</code> are off limits.
So here’s a function to parse a signed integer out of a <code class="language-plaintext highlighter-rouge">Str</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int32_t</span> <span class="nf">parseint</span><span class="p">(</span><span class="n">Str</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">uint32_t</span> <span class="n">r</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int32_t</span>  <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'+'</span><span class="p">:</span>            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span> <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span> <span class="o">:</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">10</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span> <span class="o">*</span> <span class="n">sign</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="language-plaintext highlighter-rouge">uint32_t</code> means its free to overflow. If it overflows, the input was
invalid. If it doesn’t hold an integer, the input was invalid. In either
case it will read a harmless, garbage result. Despite being unsigned, it
works just fine with negative inputs thanks to two’s complement.</p>

<p>For floats I didn’t intend to parse exponential notation, but some models
I wanted to test actually <em>did</em> use it — probably by accident — so I added
it anyway. That requires a function to compute the exponent.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">expt10</span><span class="p">(</span><span class="kt">int32_t</span> <span class="n">e</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span>   <span class="n">y</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">float</span>   <span class="n">x</span> <span class="o">=</span> <span class="n">e</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">?</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span> <span class="o">:</span> <span class="n">e</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">?</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">int32_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">e</span><span class="o">&lt;</span><span class="mi">0</span> <span class="o">?</span> <span class="n">e</span> <span class="o">:</span> <span class="o">-</span><span class="n">e</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="n">n</span> <span class="o">/=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">y</span> <span class="o">*=</span> <span class="n">n</span><span class="o">%</span><span class="mi">2</span> <span class="o">?</span> <span class="n">x</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
        <span class="n">x</span> <span class="o">*=</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>That’s exponentiation by squaring, <a href="/blog/2024/05/24/">avoiding signed overflow</a> on the
exponent. Traditionally a negative exponent is inverted, but applying
unary <code class="language-plaintext highlighter-rouge">-</code> to an arbitrary integer might overflow (consider -2147483648).
So instead I iterate from the negative end. The negative range is larger
than the positive, after all. Finally we can parse floats:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">float</span> <span class="nf">parsefloat</span><span class="p">(</span><span class="n">Str</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">float</span> <span class="n">r</span>    <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">sign</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">exp</span>  <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="k">case</span> <span class="sc">'+'</span><span class="p">:</span>            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'-'</span><span class="p">:</span> <span class="n">sign</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'.'</span><span class="p">:</span> <span class="n">exp</span>  <span class="o">=</span>  <span class="mi">1</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="sc">'E'</span><span class="p">:</span>
        <span class="k">case</span> <span class="sc">'e'</span><span class="p">:</span> <span class="n">exp</span>  <span class="o">=</span> <span class="n">exp</span> <span class="o">?</span> <span class="n">exp</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">;</span>
                  <span class="n">exp</span> <span class="o">*=</span> <span class="n">expt10</span><span class="p">(</span><span class="n">parseint</span><span class="p">(</span><span class="n">substring</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)));</span>
                  <span class="n">i</span>    <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">len</span><span class="p">;</span>
                  <span class="k">break</span><span class="p">;</span>
        <span class="k">default</span> <span class="o">:</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">10</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="o">*</span><span class="n">r</span> <span class="o">+</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="sc">'0'</span><span class="p">);</span>
                  <span class="n">exp</span> <span class="o">*=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">1</span><span class="n">f</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">sign</span> <span class="o">*</span> <span class="n">r</span> <span class="o">*</span> <span class="p">(</span><span class="n">exp</span> <span class="o">?</span> <span class="n">exp</span> <span class="o">:</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Probably not as precise as <code class="language-plaintext highlighter-rouge">strtof</code>, but good enough for loading a model.
It’s also ~30% faster for this purpose than my system’s <code class="language-plaintext highlighter-rouge">strtof</code>. If it
hits an exponent, it combines <code class="language-plaintext highlighter-rouge">parseint</code> and <code class="language-plaintext highlighter-rouge">expt10</code> to augment the
result so far. At least for all the models I tried, the exponent only
appeared for tiny values. They round to zero with no visible effects, so
you can cut the implementation by more than half in one fell swoop if you
wish (no more <code class="language-plaintext highlighter-rouge">expt10</code> nor <code class="language-plaintext highlighter-rouge">substring</code> either):</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">switch</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">case</span> <span class="sc">'E'</span><span class="p">:</span>
        <span class="k">case</span> <span class="sc">'e'</span><span class="p">:</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>  <span class="c1">// probably small *shrug*</span>
        <span class="c1">// ...</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>Why not <code class="language-plaintext highlighter-rouge">strtof</code>? That has the rather annoying requirement that input is
null terminated, which is not the case here. Worse, it’s <a href="https://github.com/mpv-player/mpv/commit/1e70e82b">affected by the
locale</a> and doesn’t behave consistently nor reliably.</p>

<p>A vertex is three floats separated by whitespace. So combine <code class="language-plaintext highlighter-rouge">cut</code> and
<code class="language-plaintext highlighter-rouge">parsefloat</code> to parse one.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">float</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Vert</span><span class="p">;</span>

<span class="n">Vert</span> <span class="nf">parsevert</span><span class="p">(</span><span class="n">Str</span> <span class="n">s</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Vert</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">Cut</span> <span class="n">c</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">trimleft</span><span class="p">(</span><span class="n">s</span><span class="p">),</span> <span class="sc">' '</span><span class="p">);</span>
    <span class="n">r</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsefloat</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">trimleft</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">tail</span><span class="p">),</span> <span class="sc">' '</span><span class="p">);</span>
    <span class="n">r</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsefloat</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">trimleft</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">tail</span><span class="p">),</span> <span class="sc">' '</span><span class="p">);</span>
    <span class="n">r</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsefloat</span><span class="p">(</span><span class="n">c</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">cut</code> parses a field between every space, including empty fields between
adjacent spaces, so <code class="language-plaintext highlighter-rouge">trimleft</code> discards extra space before cutting. If the
line ends early, this passes empty strings into <code class="language-plaintext highlighter-rouge">parsefloat</code> which come
out as zeros. No special checks required for invalid input.</p>

<p>Faces are a set of three vertex indices and three normal indices, and
parses almost the same way. Relative indices are immediately converted to
absolute indices using the number of vertices/normals so far.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="kt">int32_t</span> <span class="n">v</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
    <span class="kt">int32_t</span> <span class="n">n</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">}</span> <span class="n">Face</span><span class="p">;</span>

<span class="k">static</span> <span class="n">Face</span> <span class="nf">parseface</span><span class="p">(</span><span class="n">Str</span> <span class="n">s</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">nverts</span><span class="p">,</span> <span class="kt">ptrdiff_t</span> <span class="n">nnorms</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Face</span> <span class="n">r</span>      <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">Cut</span>  <span class="n">fields</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">fields</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">s</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fields</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">trimleft</span><span class="p">(</span><span class="n">fields</span><span class="p">.</span><span class="n">tail</span><span class="p">),</span> <span class="sc">' '</span><span class="p">);</span>
        <span class="n">Cut</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">fields</span><span class="p">.</span><span class="n">head</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">);</span>
        <span class="n">r</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">parseint</span><span class="p">(</span><span class="n">elem</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">elem</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">);</span>  <span class="c1">// skip texture</span>
        <span class="n">elem</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">elem</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="sc">'/'</span><span class="p">);</span>
        <span class="n">r</span><span class="p">.</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">parseint</span><span class="p">(</span><span class="n">elem</span><span class="p">.</span><span class="n">head</span><span class="p">);</span>

        <span class="c1">// Process relative subscripts</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">r</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)(</span><span class="n">r</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">nverts</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">r</span><span class="p">.</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)(</span><span class="n">r</span><span class="p">.</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">+</span> <span class="n">nnorms</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Since <code class="language-plaintext highlighter-rouge">nverts</code> must be non-negative, and a relative index is negative by
definition, adding them together can never overflow. If there are too many
vertices, the result might be truncated, as indicated by the cast. That’s
fine. Just invalid input.</p>

<p>There’s an interesting interview question here: Consider this alternative
to the above, maintaining the explicit cast to dismiss the <code class="language-plaintext highlighter-rouge">-Wconversion</code>
warning.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">r</span><span class="p">.</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">+=</span> <span class="p">(</span><span class="kt">int32_t</span><span class="p">)(</span><span class="mi">1</span> <span class="o">+</span> <span class="n">nverts</span><span class="p">);</span>
</code></pre></div></div>

<p>Is it equivalent? Can this overflow? (Answers: No and yes.) If yes, under
what conditions? Unfortunately a fuzz test would never hit it.</p>

<h3 id="putting-it-together">Putting it together</h3>

<p>For this case, a model is three arrays of vertices, normals, and indices.
While faces only support 32-bit indexing, I use <code class="language-plaintext highlighter-rouge">ptrdiff_t</code> in order to
skip overflow checks. There cannot possibly be more vertices than bytes of
source, so these counts cannot overflow.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">Vert</span>     <span class="o">*</span><span class="n">verts</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span> <span class="n">nverts</span><span class="p">;</span>
    <span class="n">Vert</span>     <span class="o">*</span><span class="n">norms</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span> <span class="n">nnorms</span><span class="p">;</span>
    <span class="n">Face</span>     <span class="o">*</span><span class="n">faces</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span> <span class="n">nfaces</span><span class="p">;</span>
<span class="p">}</span> <span class="n">Model</span><span class="p">;</span>

<span class="n">Model</span> <span class="nf">parseobj</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="p">,</span> <span class="n">Str</span><span class="p">);</span>
</code></pre></div></div>

<p>They’d probably look a little nicer as <a href="/blog/2023/10/05/">dynamic arrays</a>, but we won’t
need that machinery. That’s because the parser makes two passes over the
OBJ source, the first time to count:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Model</span> <span class="n">m</span>     <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">Cut</span>   <span class="n">lines</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>

    <span class="n">lines</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">lines</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">lines</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="sc">'\n'</span><span class="p">);</span>
        <span class="n">Cut</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">trimright</span><span class="p">(</span><span class="n">lines</span><span class="p">.</span><span class="n">head</span><span class="p">),</span> <span class="sc">' '</span><span class="p">);</span>
        <span class="n">Str</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">fields</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">"v"</span><span class="p">),</span> <span class="n">kind</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">nverts</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">"vn"</span><span class="p">),</span> <span class="n">kind</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">nnorms</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">"f"</span><span class="p">),</span> <span class="n">kind</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">nfaces</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>It’s a lightweight pass, skipping over the numeric data. With that
information collected, we can allocate the model:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">m</span><span class="p">.</span><span class="n">verts</span>  <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">nverts</span><span class="p">,</span> <span class="n">Vert</span><span class="p">);</span>
    <span class="n">m</span><span class="p">.</span><span class="n">norms</span>  <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">nnorms</span><span class="p">,</span> <span class="n">Vert</span><span class="p">);</span>
    <span class="n">m</span><span class="p">.</span><span class="n">faces</span>  <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">nfaces</span><span class="p">,</span> <span class="n">Face</span><span class="p">);</span>
    <span class="n">m</span><span class="p">.</span><span class="n">nverts</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">nnorms</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">nfaces</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</code></pre></div></div>

<p>On the next pass we call <code class="language-plaintext highlighter-rouge">parsevert</code> and <code class="language-plaintext highlighter-rouge">parseface</code> to fill it out.</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">lines</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="n">obj</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">lines</span><span class="p">.</span><span class="n">tail</span><span class="p">.</span><span class="n">len</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">lines</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="sc">'\n'</span><span class="p">);</span>
        <span class="n">Cut</span> <span class="n">fields</span> <span class="o">=</span> <span class="n">cut</span><span class="p">(</span><span class="n">trimright</span><span class="p">(</span><span class="n">lines</span><span class="p">.</span><span class="n">head</span><span class="p">),</span> <span class="sc">' '</span><span class="p">);</span>
        <span class="n">Str</span> <span class="n">kind</span> <span class="o">=</span> <span class="n">fields</span><span class="p">.</span><span class="n">head</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">"v"</span><span class="p">),</span> <span class="n">kind</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">nverts</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsevert</span><span class="p">(</span><span class="n">fields</span><span class="p">.</span><span class="n">tail</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">"vn"</span><span class="p">),</span> <span class="n">kind</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">norms</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">nnorms</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">parsevert</span><span class="p">(</span><span class="n">fields</span><span class="p">.</span><span class="n">tail</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">equals</span><span class="p">(</span><span class="n">S</span><span class="p">(</span><span class="s">"f"</span><span class="p">),</span> <span class="n">kind</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">m</span><span class="p">.</span><span class="n">faces</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">nfaces</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">parseface</span><span class="p">(</span><span class="n">fields</span><span class="p">.</span><span class="n">tail</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">nverts</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">nnorms</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>At this point the model is parsed, though its not necessarily consistent.
Faces indices may still be out of range. The next step is to transform it
into a more useful representation.</p>

<h3 id="transformation">Transformation</h3>

<p>Rendering the model is the easiest way to verify it came out alright, and
it’s generally useful for debugging problems. Because it basically does
all the hard work for us, and doesn’t require <a href="https://www.khronos.org/opengl/wiki/OpenGL_Loading_Library">ridiculous contortions to
access</a>, I’m going to render with old school OpenGL 1.1. It provides a
<a href="https://registry.khronos.org/OpenGL-Refpages/gl2.1/xhtml/glInterleavedArrays.xml"><code class="language-plaintext highlighter-rouge">glInterleavedArrays</code></a> function with a bunch of predefined formats.
The one that interests me is <code class="language-plaintext highlighter-rouge">GL_N3F_V3F</code>, where each vertex is a normal
and a position. Each face is three such elements. I came up with this:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>  <span class="c1">// GL_N3F_V3F</span>
    <span class="n">Vert</span> <span class="n">n</span><span class="p">,</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span> <span class="n">N3FV3F</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>

<span class="k">typedef</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">N3FV3F</span>   <span class="o">*</span><span class="n">data</span><span class="p">;</span>
    <span class="kt">ptrdiff_t</span> <span class="n">len</span><span class="p">;</span>
<span class="p">}</span> <span class="n">N3FV3Fs</span><span class="p">;</span>

<span class="c1">// Transform a model into a GL_N3F_V3F representation.</span>
<span class="n">N3FV3Fs</span> <span class="nf">n3fv3fize</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="p">,</span> <span class="n">Model</span><span class="p">);</span>
</code></pre></div></div>

<p>If you’re being precise you’d use <code class="language-plaintext highlighter-rouge">GLfloat</code>, but this is good enough for
me. By using a different arena for this step, we can discard the OBJ data
once it’s in the “local” format. For example:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="n">Arena</span> <span class="n">perm</span>    <span class="o">=</span> <span class="p">{...};</span>
    <span class="n">Arena</span> <span class="n">scratch</span> <span class="o">=</span> <span class="p">{...};</span>

    <span class="n">N3FV3Fs</span> <span class="o">*</span><span class="n">scene</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perm</span><span class="p">,</span> <span class="n">nmodels</span><span class="p">,</span> <span class="n">N3FV3Fs</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">nmodels</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Arena</span> <span class="n">temp</span>  <span class="o">=</span> <span class="n">scratch</span><span class="p">;</span>  <span class="c1">// free OBJ at end of iteration</span>
        <span class="n">Str</span>   <span class="n">obj</span>   <span class="o">=</span> <span class="n">loadfile</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">path</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">Model</span> <span class="n">model</span> <span class="o">=</span> <span class="n">parseobj</span><span class="p">(</span><span class="o">&amp;</span><span class="n">temp</span><span class="p">,</span> <span class="n">obj</span><span class="p">);</span>
        <span class="n">scene</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>    <span class="o">=</span> <span class="n">n3fv3fize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">perm</span><span class="p">,</span> <span class="n">model</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>The conversion allocates the <code class="language-plaintext highlighter-rouge">GL_N3F_V3F</code> array, discards invalid faces,
and copies the valid faces into the array:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">N3FV3Fs</span> <span class="nf">n3fv3fize</span><span class="p">(</span><span class="n">Arena</span> <span class="o">*</span><span class="n">a</span><span class="p">,</span> <span class="n">Model</span> <span class="n">m</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">N3FV3Fs</span> <span class="n">r</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="n">r</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">new</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">.</span><span class="n">nfaces</span><span class="p">,</span> <span class="n">N3FV3F</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">ptrdiff_t</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">f</span> <span class="o">&lt;</span> <span class="n">m</span><span class="p">.</span><span class="n">nfaces</span><span class="p">;</span> <span class="n">f</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">_Bool</span> <span class="n">valid</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">valid</span> <span class="o">&amp;=</span> <span class="n">m</span><span class="p">.</span><span class="n">faces</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">faces</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">.</span><span class="n">nverts</span><span class="p">;</span>
            <span class="n">valid</span> <span class="o">&amp;=</span> <span class="n">m</span><span class="p">.</span><span class="n">faces</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&gt;</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">m</span><span class="p">.</span><span class="n">faces</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">&lt;=</span><span class="n">m</span><span class="p">.</span><span class="n">nnorms</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">valid</span><span class="p">)</span> <span class="p">{</span>
            <span class="kt">ptrdiff_t</span> <span class="n">t</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">len</span><span class="o">++</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">3</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">n</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">norms</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">faces</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">n</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
                <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">[</span><span class="n">t</span><span class="p">][</span><span class="n">i</span><span class="p">].</span><span class="n">v</span> <span class="o">=</span> <span class="n">m</span><span class="p">.</span><span class="n">verts</span><span class="p">[</span><span class="n">m</span><span class="p">.</span><span class="n">faces</span><span class="p">[</span><span class="n">f</span><span class="p">].</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">r</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Here’s what that looks like in OpenGL with <a href="https://chuck.stanford.edu/chugl/examples/data/models/suzanne.obj"><code class="language-plaintext highlighter-rouge">suzanne.obj</code></a> and
<a href="https://casual-effects.com/data/"><code class="language-plaintext highlighter-rouge">bmw.obj</code></a>:</p>

<p><img src="/img/objrender/suzanne.png" alt="" /></p>

<p><img src="/img/objrender/bmw.png" alt="" /></p>

<p>This was a fun little project, and perhaps you learned a new technique or
two after checking it out.</p>


    